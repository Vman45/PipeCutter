########################################
#
# HAL file for BeagleBone + BeBoPr cape with 4 steppers
#
# Derived from example hm2-stepper config
#
# ########################################

# start haltalk server
#loadusr -W haltalk -d 1
#loadusr -W haltalk -d 5
loadusr -W haltalk -d 5


# Launch the setup script to make sure hardware setup looks good
loadusr -w ./setup.sh


# ###################################
# Core EMC/HAL Loads
# ###################################

# kinematics
loadrt trivkins

# motion controller, get name and thread periods from ini file
# trajectory planner
loadrt tp
loadrt [EMCMOT]EMCMOT servo_period_nsec=[EMCMOT]SERVO_PERIOD num_joints=[TRAJ]AXES tp=tp kins=trivkins


# load low-level drivers
loadrt hal_bb_gpio output_pins=816,822,823,824,825,826,914,923,925,811 input_pins=807,808,809,810,817,911,913
loadrt [PRUCONF](DRIVER) prucode=$(HAL_RTMOD_DIR)/[PRUCONF](PRUBIN) [PRUCONF](CONFIG) halname=hpg
loadrt pid count=2
loadrt limit1 count=2

# Commented by Klemen
# Python user-mode HAL module to read ADC value and generate a thermostat output for PWM
# c = analog input channel and thermistor table
#
#loadusr -Wn Therm hal_temp_bbb -n Therm -c 04:epcos_B57560G1104,05:epcos_B57560G1104 -b CRAMPS


# ################################################
# THREADS
# ################################################

addf hpg.capture-position   			servo-thread
addf bb_gpio.read                       servo-thread
addf motion-command-handler             servo-thread
addf motion-controller                  servo-thread
addf pid.0.do-pid-calcs                 servo-thread
addf pid.1.do-pid-calcs                 servo-thread
addf limit1.0                           servo-thread
addf limit1.1                           servo-thread
addf hpg.update             			servo-thread
addf bb_gpio.write                      servo-thread


# ######################################################
# Axis-of-motion Specific Configs (not the GUI)
# ######################################################


# ################
# X [0] Axis
# ################

# axis enable chain
newsig emcmot.00.enable bit
sets emcmot.00.enable FALSE

net emcmot.00.enable <= axis.0.amp-enable-out
net emcmot.00.enable => hpg.stepgen.00.enable


# position command and feedback
net emcmot.00.pos-cmd <= axis.0.motor-pos-cmd
net emcmot.00.pos-cmd => hpg.stepgen.00.position-cmd

net motor.00.pos-fb <= hpg.stepgen.00.position-fb
net motor.00.pos-fb => axis.0.motor-pos-fb
#net emcmot.00.pos-cmd => axis.0.motor-pos-fb 



# timing parameters
setp hpg.stepgen.00.dirsetup        [AXIS_0]DIRSETUP
setp hpg.stepgen.00.dirhold         [AXIS_0]DIRHOLD

setp hpg.stepgen.00.steplen         [AXIS_0]STEPLEN
setp hpg.stepgen.00.stepspace       [AXIS_0]STEPSPACE

setp hpg.stepgen.00.position-scale  [AXIS_0]SCALE

setp hpg.stepgen.00.maxvel          [AXIS_0]STEPGEN_MAX_VEL
setp hpg.stepgen.00.maxaccel        [AXIS_0]STEPGEN_MAX_ACC

#setp hpg.stepgen.00.step_type       0
# P8.43 PRU1.out2
setp hpg.stepgen.00.steppin        813
# P8.44 PRU1.out4
setp hpg.stepgen.00.dirpin         812


# ################
# Y [1] Axis
# ################

# axis enable chain
newsig emcmot.01.enable bit
sets emcmot.01.enable FALSE

net emcmot.01.enable <= axis.1.amp-enable-out
net emcmot.01.enable => hpg.stepgen.01.enable


# position command and feedback
net emcmot.01.pos-cmd <= axis.1.motor-pos-cmd
net emcmot.01.pos-cmd => hpg.stepgen.01.position-cmd

net motor.01.pos-fb <= hpg.stepgen.01.position-fb
net motor.01.pos-fb => axis.1.motor-pos-fb
#net emcmot.01.pos-cmd => axis.1.motor-pos-fb 


# timing parameters
setp hpg.stepgen.01.dirsetup        [AXIS_1]DIRSETUP
setp hpg.stepgen.01.dirhold         [AXIS_1]DIRHOLD

setp hpg.stepgen.01.steplen         [AXIS_1]STEPLEN
setp hpg.stepgen.01.stepspace       [AXIS_1]STEPSPACE

setp hpg.stepgen.01.position-scale  [AXIS_1]SCALE

setp hpg.stepgen.01.maxvel          [AXIS_1]STEPGEN_MAX_VEL
setp hpg.stepgen.01.maxaccel        [AXIS_1]STEPGEN_MAX_ACC

#setp hpg.stepgen.01.step_type       0
# P8.42 PRU1.out5
setp hpg.stepgen.01.steppin        815
# P8.39 PRU1.out6
setp hpg.stepgen.01.dirpin         814


# ################
# Z [2] Axis
# ################

# axis enable chain
newsig emcmot.02.enable bit
sets emcmot.02.enable FALSE

net emcmot.02.enable <= axis.2.amp-enable-out
net emcmot.02.enable => hpg.stepgen.02.enable


# position command and feedback
net emcmot.02.pos-cmd <= axis.2.motor-pos-cmd
net emcmot.02.pos-cmd => hpg.stepgen.02.position-cmd

net motor.02.pos-fb <= hpg.stepgen.02.position-fb
net motor.02.pos-fb => axis.2.motor-pos-fb
#net emcmot.02.pos-cmd => axis.2.motor-pos-fb 


# timing parameters
setp hpg.stepgen.02.dirsetup        [AXIS_2]DIRSETUP
setp hpg.stepgen.02.dirhold         [AXIS_2]DIRHOLD

setp hpg.stepgen.02.steplen         [AXIS_2]STEPLEN
setp hpg.stepgen.02.stepspace       [AXIS_2]STEPSPACE

setp hpg.stepgen.02.position-scale  [AXIS_2]SCALE

setp hpg.stepgen.02.maxvel          [AXIS_2]STEPGEN_MAX_VEL
setp hpg.stepgen.02.maxaccel        [AXIS_2]STEPGEN_MAX_ACC

#setp hpg.stepgen.02.step_type       0
# P8.27 PRU1.out8
setp hpg.stepgen.02.steppin        819
# P8.29 PRU1.out9
setp hpg.stepgen.02.dirpin         818


# ################
# A [3] Rotator A
# ################

# axis enable chain
newsig emcmot.03.enable bit
sets emcmot.03.enable FALSE

net emcmot.03.enable <= axis.3.amp-enable-out
net emcmot.03.enable => hpg.stepgen.03.enable


# position command and feedback
net emcmot.03.pos-cmd <= axis.3.motor-pos-cmd
net emcmot.03.pos-cmd => hpg.stepgen.03.position-cmd

net motor.03.pos-fb <= hpg.stepgen.03.position-fb
net motor.03.pos-fb => axis.3.motor-pos-fb
#net emcmot.03.pos-cmd => axis.3.motor-pos-fb 


# timing parameters
setp hpg.stepgen.03.dirsetup        [AXIS_3]DIRSETUP
setp hpg.stepgen.03.dirhold         [AXIS_3]DIRHOLD

setp hpg.stepgen.03.steplen         [AXIS_3]STEPLEN
setp hpg.stepgen.03.stepspace       [AXIS_3]STEPSPACE

setp hpg.stepgen.03.position-scale  [AXIS_3]SCALE

setp hpg.stepgen.03.maxvel          [AXIS_3]STEPGEN_MAX_VEL
setp hpg.stepgen.03.maxaccel        [AXIS_3]STEPGEN_MAX_ACC

#setp hpg.stepgen.03.step_type       0
# P8.30 GPIO2.25
setp hpg.stepgen.03.steppin        916
# P8.21 GPIO1.30
setp hpg.stepgen.03.dirpin         912


# ################
# B [4] Rotator B
# ################

# axis enable chain
newsig emcmot.04.enable bit
sets emcmot.04.enable FALSE

net emcmot.04.enable <= axis.4.amp-enable-out
net emcmot.04.enable => hpg.stepgen.04.enable


# position command and feedback
net emcmot.04.pos-cmd <= axis.4.motor-pos-cmd
net emcmot.04.pos-cmd => hpg.stepgen.04.position-cmd

net motor.04.pos-fb <= hpg.stepgen.04.position-fb
net motor.04.pos-fb => axis.4.motor-pos-fb
#net emcmot.04.pos-cmd => axis.4.motor-pos-fb 


# timing parameters
setp hpg.stepgen.04.dirsetup        [AXIS_4]DIRSETUP
setp hpg.stepgen.04.dirhold         [AXIS_4]DIRHOLD

setp hpg.stepgen.04.steplen         [AXIS_4]STEPLEN
setp hpg.stepgen.04.stepspace       [AXIS_4]STEPSPACE

setp hpg.stepgen.04.position-scale  [AXIS_4]SCALE

setp hpg.stepgen.04.maxvel          [AXIS_4]STEPGEN_MAX_VEL
setp hpg.stepgen.04.maxaccel        [AXIS_4]STEPGEN_MAX_ACC

#setp hpg.stepgen.04.step_type       0
# P8.30 GPIO2.25
setp hpg.stepgen.04.steppin        917
# P8.21 GPIO1.30
setp hpg.stepgen.04.dirpin         918


# ##################################################
# Standard I/O - EStop, Enables, Limit Switches, Etc
# ##################################################

# Create estop signal chain
# Drive software estop to hardware
net estop-out iocontrol.0.user-enable-out => bb_gpio.p8.out-26
setp bb_gpio.p8.out-26.invert 1

# Monitor estop input from hardware
net estop-loop bb_gpio.p8.in-17 => iocontrol.0.emc-enable-in
setp bb_gpio.p8.in-17.invert 1

# create signals for tool loading loopback
net tool-prep-loop iocontrol.0.tool-prepare => iocontrol.0.tool-prepared
net tool-change-loop iocontrol.0.tool-change => iocontrol.0.tool-changed

# Axis enable signal (active low)
net emcmot.00.enable => bb_gpio.p9.out-14
setp bb_gpio.p9.out-14.invert 1

# Machine power
# Use halui.machine.is-on instead?
net emcmot.00.enable => bb_gpio.p9.out-23

# Tie machine power signal to the CRAMPS LED
# Feel free to tie any other signal you like to the LED
net emcmot.00.enable => bb_gpio.p9.out-25

# ################
# Limit Switches
# ################
newsig limit-x-min bit
newsig limit-x-max bit
newsig limit-y-min bit
newsig limit-y-max bit
newsig limit-z-min bit
newsig limit-z-max bit

net limit-x-min <= bb_gpio.p8.in-08
net limit-x-max <= bb_gpio.p8.in-07
net limit-y-min <= bb_gpio.p8.in-10
net limit-y-max <= bb_gpio.p8.in-09
net limit-z-min <= bb_gpio.p9.in-13
net limit-z-max <= bb_gpio.p9.in-11

# Adjust as needed for your switch polarity
setp bb_gpio.p8.in-08.invert 1
setp bb_gpio.p8.in-07.invert 1
setp bb_gpio.p8.in-10.invert 1
setp bb_gpio.p8.in-09.invert 1
setp bb_gpio.p9.in-11.invert 1
setp bb_gpio.p9.in-13.invert 1

# Uncomment if you actually have limit switches setup
# You probably want to setup homing in the INI file, as well
#net limit-x-min => axis.0.home-sw-in
#net limit-x-min => axis.0.neg-lim-sw-in
#net limit-x-max => axis.0.pos-lim-sw-in
#net limit-y-min => axis.1.home-sw-in
#net limit-y-min => axis.1.neg-lim-sw-in
#net limit-y-max => axis.1.pos-lim-sw-in
#net limit-z-min => axis.2.home-sw-in
#net limit-z-min => axis.2.neg-lim-sw-in
#net limit-z-max => axis.2.pos-lim-sw-in

# ################
# Servo signals
# ################

# There is currently no driver to generate pulses for actual
# radio-control style servos, but the buffered 5V output
# signals can be used as GPIO

# !!! WARNING !!!
# BBB on-board eMMC *MUST* be disabled in order to use these!
# Drive eMMC-disabled signal high to enable signals that overlap
# with the eMMC pins on P8, otherwise they are tri-stated
#
# You also need to edit the setup.sh file to enable the GPIO pins

# Signal the hardware that eMMC has been disabled and it is safe
# to drive the signals connected to eMMC lines (active low)
newsig eMMC-disabled bit
sets eMMC-disabled 0
net eMMC-disabled bb_gpio.p8.out-16
setp bb_gpio.p8.out-16.invert 1

# Servo signals, output only, driven by an 'ACT125

newsig servo.1 bit
newsig servo.2 bit
newsig servo.3 bit
newsig servo.4 bit

sets servo.1 0
sets servo.2 0
sets servo.3 0
sets servo.4 0

net servo.1 bb_gpio.p8.out-25
net servo.2 bb_gpio.p8.out-24
net servo.3 bb_gpio.p8.out-23
net servo.4 bb_gpio.p8.out-22

#  KLEMEN: COMMENTED HEATER SECTION START
# ##################################################
# PWM and Temperature Signals
# ##################################################

## Define signals to use elsewhere (ie: M1xx codes)
## If you change any names here, lots of things will break!
#newsig e0.temp.set   float
#newsig e0.temp.meas  float
#newsig bed.temp.set  float
#newsig bed.temp.meas float

#setp hpg.pwmgen.00.pwm_period       10000000

## Bed Heater FET 1
#setp hpg.pwmgen.00.out.00.pin       811
#setp hpg.pwmgen.00.out.00.enable    1
#setp hpg.pwmgen.00.out.00.value     0.0

## E0 Heater FET 2
#setp hpg.pwmgen.00.out.01.pin       915
#setp hpg.pwmgen.00.out.01.enable    1
#setp hpg.pwmgen.00.out.01.value     0.0

## E1 Heater FET 3
#setp hpg.pwmgen.00.out.02.pin       927
#setp hpg.pwmgen.00.out.02.enable    1
#setp hpg.pwmgen.00.out.02.value     0.0

## E2 Heater FET 4
#setp hpg.pwmgen.00.out.03.pin       921
#setp hpg.pwmgen.00.out.03.enable    1
#setp hpg.pwmgen.00.out.03.value     0.0

## FET 5 - Fan / LED
#setp hpg.pwmgen.00.out.04.pin       941
#setp hpg.pwmgen.00.out.04.enable    1
#setp hpg.pwmgen.00.out.04.value     0.0

## FET 6 - Fan / LED
#setp hpg.pwmgen.00.out.05.pin       922
#setp hpg.pwmgen.00.out.05.enable    1
#setp hpg.pwmgen.00.out.05.value     0.0

## PID for Extruder 0 temperature control
#net e0.temp.meas    <= Therm.ch-04.value
#net e0.temp.meas    => pid.0.feedback

#sets e0.temp.set  0
#net e0.temp.set     => pid.0.command

#net e0.heater  <= pid.0.output
#net e0.heater  => limit1.0.in
#net e0.heaterl <= limit1.0.out
#net e0.heaterl => hpg.pwmgen.00.out.01.value

## Limit heater PWM to positive values
## PWM mimics hm2 implementation, which generates output for negative values
#setp limit1.0.min 0

# PID for Bed temperature control
#net bed.temp.meas    <= Therm.ch-05.value
#net bed.temp.meas    => pid.1.feedback

#sets bed.temp.set  0
#net bed.temp.set     => pid.1.command

#net bed.heater  <= pid.1.output
#net bed.heater  => limit1.1.in
#net bed.heaterl <= limit1.1.out
#net bed.heaterl => hpg.pwmgen.00.out.00.value

# Limit heater PWM to positive values
# PWM mimics hm2 implementation, which generates output for negative values
#setp limit1.1.min 0

## PID Parameters for adjusting temperature control
## Extruder
##setp pid.0.FF0      0
##setp pid.0.FF1      0
##setp pid.0.FF2      0
#setp pid.0.Pgain  0.30
#setp pid.0.Igain  0.00001
#setp pid.0.Dgain  0.9375
#setp pid.0.maxerrorI 1.0
#setp pid.0.bias    0.5
#setp pid.0.enable   1

## Bed
##setp pid.1.FF0      0
##setp pid.1.FF1      0
##setp pid.1.FF2      0
#setp pid.1.Pgain  1
#setp pid.1.Igain  0.0
#setp pid.1.Dgain  0.0
#setp pid.1.maxerrorI 1.0
#setp pid.1.bias    0.5
#setp pid.1.enable   1
# COMMENTED HEATER SECTION END KLEMEN





newcomp mymotion timer=100
newpin mymotion  mymotion.program-line       s32   in
newpin mymotion  mymotion.spindle-on         bit   in
newpin mymotion  mymotion.vx        		 float in
newpin mymotion  mymotion.vy        		 float in
newpin mymotion  mymotion.vz        		 float in
newpin mymotion  mymotion.dvx        		 float in
newpin mymotion  mymotion.dvz        		 float in
newpin mymotion  mymotion.v        		 	 float in
newpin mymotion  mymotion.current-radius	 float in
ready  mymotion

newcomp myini timer=100
newpin myini  myini.maxvel_0	 	 float out
newpin myini  myini.maxacc_0	 	 float out
newpin myini  myini.maxvel_1	 	 float out
newpin myini  myini.maxacc_1	 	 float out
newpin myini  myini.maxvel_2	 	 float out
newpin myini  myini.maxacc_2	 	 float out
newpin myini  myini.maxvel_3	 	 float out
newpin myini  myini.maxacc_3	 	 float out
newpin myini  myini.maxvel_4	 	 float out
newpin myini  myini.maxacc_4	 	 float out
ready  myini

net maxvelocity_0	myini.maxvel_0	=> hpg.stepgen.00.maxvel
net maxaccel_0	myini.maxacc_0	=> hpg.stepgen.00.maxaccel
net maxvelocity_1	myini.maxvel_1	=> hpg.stepgen.01.maxvel
net maxaccel_1	myini.maxacc_1	=> hpg.stepgen.01.maxaccel
net maxvelocity_2	myini.maxvel_2	=> hpg.stepgen.02.maxvel
net maxaccel_2	myini.maxacc_2	=> hpg.stepgen.02.maxaccel
net maxvelocity_3	myini.maxvel_3	=> hpg.stepgen.03.maxvel
net maxaccel_3	myini.maxacc_3	=> hpg.stepgen.03.maxaccel
net maxvelocity_4	myini.maxvel_4	=> hpg.stepgen.04.maxvel
net maxaccel_4	myini.maxacc_4	=> hpg.stepgen.04.maxaccel


#######################################################################################################################
#net	netname		         	signal_src	                	target					target	              ... yadda
#######################################################################################################################
net     net-spindle-on    	motion.spindle-on		=>   	bb_gpio.p8.out-11		mymotion.spindle-on
net		net-program-line	motion.program-line     =>		mymotion.program-line 	


#############################
# velocity calculation
#############################
loadrt ddt count=4
loadrt mult4 count=2
loadrt mult2 count=1
loadrt hypot count=2
loadrt sincos count=1
loadrt sum2 count=3
loadrt atanxy count=1
loadrt changeSign count=1
loadrt abs count=1

addf ddt.0 servo-thread
addf ddt.1 servo-thread
addf ddt.2 servo-thread
addf ddt.3 servo-thread

addf mult4.0 servo-thread
addf mult4.1 servo-thread

addf mult2.0 servo-thread

addf hypot.0 servo-thread
addf hypot.1 servo-thread

addf sincos.0 servo-thread

addf sum2.0 servo-thread
addf sum2.1 servo-thread
addf sum2.2 servo-thread

addf atanxy.0 servo-thread

addf changeSign.0 servo-thread

addf abs.0 servo-thread

#net	netname		         	signal_src	                	target					target	              ... yadda
#or
#net signal_src	target

net emcmot.00.pos-cmd ddt.0.in
net emcmot.01.pos-cmd ddt.1.in
net emcmot.02.pos-cmd ddt.2.in
net emcmot.03.pos-cmd ddt.3.in

#calculate radius as function of x and z
net emcmot.00.pos-cmd hypot.0.in0
net emcmot.02.pos-cmd hypot.0.in1
setp hypot.0.in2 0 
net radius hypot.0.out mymotion.current-radius

# negate x axis for theta calculation
setp mult2.0.in0 1.0
net emcmot.00.pos-cmd mult2.0.in1

net emcmot.02.pos-cmd atanxy.0.in0
net negx mult2.0.out atanxy.0.in1

#depending on speed we need to add or remove 90 degrees
setp changeSign.0.value 90.0
net ang_speed_deg ddt.3.out changeSign.0.sign
net ang_speed_deg abs.0.in

# add 90 degree to angle
net angle atanxy.0.out sum2.2.in0 
net angleDelta changeSign.0.out sum2.2.in1 

net theta sum2.2.out sincos.0.theta



########################################
# angular speed calculation
# vx
########################################
net radius mult4.0.in0
net ang_speed_deg_abs abs.0.out mult4.0.in1
#net deg_to_rad   0.0174444444444444  mult4.0.in2
setp mult4.0.in2 -0.0174444444444444
net res_cos sincos.0.cos mult4.0.in3

# mult4_0_out is dvx_R
net dvx_R mult4.0.out mymotion.dvx  

# lets add vx and dvx_R
net dvx_R sum2.0.in0
net dvx_1 ddt.0.out sum2.0.in1
net vx sum2.0.out mymotion.vx  
########################################

# vy
########################################
net vy ddt.1.out mymotion.vy
########################################

# vz
########################################
net radius mult4.1.in0
net ang_speed_deg_abs mult4.1.in1
#net deg_to_rad   0.0174444444444444  mult4.1.in2
setp mult4.1.in2 -0.0174444444444444
net res_sin sincos.0.sin mult4.1.in3

# mult4_1_out is dvz
net dvz_R mult4.1.out mymotion.dvz  
# lets add vz and dvz_R
net dvz_R sum2.1.in0
net dvz_1 ddt.2.out sum2.1.in1
net vz sum2.1.out mymotion.vz  
#######################################

#calculate total velocity of tool over workpiece
net vx hypot.1.in0
net vy hypot.1.in1
net vz hypot.1.in2
net v hypot.1.out mymotion.v
