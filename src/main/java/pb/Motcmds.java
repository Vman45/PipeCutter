// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: machinetalk/protobuf/motcmds.proto

package pb;

public final class Motcmds {
  private Motcmds() {}
  public static void registerAllExtensions(
      com.google.protobuf.ExtensionRegistry registry) {
  }
  /**
   * Protobuf enum {@code pb.MotionType}
   *
   * <pre>
   * add _ to avoid collision with macros in emc/nml_intf/motion_typesh
   * </pre>
   */
  public enum MotionType
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>_EMC_MOTION_TYPE_NONE = 0;</code>
     *
     * <pre>
     * sometimes also 0 is reported
     * </pre>
     */
    _EMC_MOTION_TYPE_NONE(0, 0),
    /**
     * <code>_EMC_MOTION_TYPE_TRAVERSE = 1;</code>
     */
    _EMC_MOTION_TYPE_TRAVERSE(1, 1),
    /**
     * <code>_EMC_MOTION_TYPE_FEED = 2;</code>
     */
    _EMC_MOTION_TYPE_FEED(2, 2),
    /**
     * <code>_EMC_MOTION_TYPE_ARC = 3;</code>
     */
    _EMC_MOTION_TYPE_ARC(3, 3),
    /**
     * <code>_EMC_MOTION_TYPE_TOOLCHANGE = 4;</code>
     */
    _EMC_MOTION_TYPE_TOOLCHANGE(4, 4),
    /**
     * <code>_EMC_MOTION_TYPE_PROBING = 5;</code>
     */
    _EMC_MOTION_TYPE_PROBING(5, 5),
    /**
     * <code>_EMC_MOTION_TYPE_INDEXROTARY = 6;</code>
     */
    _EMC_MOTION_TYPE_INDEXROTARY(6, 6),
    ;

    /**
     * <code>_EMC_MOTION_TYPE_NONE = 0;</code>
     *
     * <pre>
     * sometimes also 0 is reported
     * </pre>
     */
    public static final int _EMC_MOTION_TYPE_NONE_VALUE = 0;
    /**
     * <code>_EMC_MOTION_TYPE_TRAVERSE = 1;</code>
     */
    public static final int _EMC_MOTION_TYPE_TRAVERSE_VALUE = 1;
    /**
     * <code>_EMC_MOTION_TYPE_FEED = 2;</code>
     */
    public static final int _EMC_MOTION_TYPE_FEED_VALUE = 2;
    /**
     * <code>_EMC_MOTION_TYPE_ARC = 3;</code>
     */
    public static final int _EMC_MOTION_TYPE_ARC_VALUE = 3;
    /**
     * <code>_EMC_MOTION_TYPE_TOOLCHANGE = 4;</code>
     */
    public static final int _EMC_MOTION_TYPE_TOOLCHANGE_VALUE = 4;
    /**
     * <code>_EMC_MOTION_TYPE_PROBING = 5;</code>
     */
    public static final int _EMC_MOTION_TYPE_PROBING_VALUE = 5;
    /**
     * <code>_EMC_MOTION_TYPE_INDEXROTARY = 6;</code>
     */
    public static final int _EMC_MOTION_TYPE_INDEXROTARY_VALUE = 6;


    public final int getNumber() { return value; }

    public static MotionType valueOf(int value) {
      switch (value) {
        case 0: return _EMC_MOTION_TYPE_NONE;
        case 1: return _EMC_MOTION_TYPE_TRAVERSE;
        case 2: return _EMC_MOTION_TYPE_FEED;
        case 3: return _EMC_MOTION_TYPE_ARC;
        case 4: return _EMC_MOTION_TYPE_TOOLCHANGE;
        case 5: return _EMC_MOTION_TYPE_PROBING;
        case 6: return _EMC_MOTION_TYPE_INDEXROTARY;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<MotionType>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<MotionType>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<MotionType>() {
            public MotionType findValueByNumber(int number) {
              return MotionType.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return pb.Motcmds.getDescriptor().getEnumTypes().get(0);
    }

    private static final MotionType[] VALUES = values();

    public static MotionType valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new java.lang.IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private MotionType(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:pb.MotionType)
  }

  /**
   * Protobuf enum {@code pb.cmd_code_t}
   *
   * <pre>
   * motion commands. enum cmd_code_t from src/emc/motion.h
   * </pre>
   */
  public enum cmd_code_t
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>EMCMOT_ABORT = 4000;</code>
     *
     * <pre>
     * abort all motion 
     * </pre>
     */
    EMCMOT_ABORT(0, 4000),
    /**
     * <code>EMCMOT_AXIS_ABORT = 4001;</code>
     */
    EMCMOT_AXIS_ABORT(1, 4001),
    /**
     * <code>EMCMOT_ENABLE = 4002;</code>
     *
     * <pre>
     * enable servos for active joints 
     * </pre>
     */
    EMCMOT_ENABLE(2, 4002),
    /**
     * <code>EMCMOT_DISABLE = 4003;</code>
     *
     * <pre>
     * disable servos for active joints 
     * </pre>
     */
    EMCMOT_DISABLE(3, 4003),
    /**
     * <code>EMCMOT_ENABLE_AMPLIFIER = 4004;</code>
     *
     * <pre>
     * enable amp outputs 
     * </pre>
     */
    EMCMOT_ENABLE_AMPLIFIER(4, 4004),
    /**
     * <code>EMCMOT_DISABLE_AMPLIFIER = 4005;</code>
     *
     * <pre>
     * disable amp outputs 
     * </pre>
     */
    EMCMOT_DISABLE_AMPLIFIER(5, 4005),
    /**
     * <code>EMCMOT_ENABLE_WATCHDOG = 4006;</code>
     *
     * <pre>
     * enable watchdog sound = 4000; parport 
     * </pre>
     */
    EMCMOT_ENABLE_WATCHDOG(6, 4006),
    /**
     * <code>EMCMOT_DISABLE_WATCHDOG = 4007;</code>
     *
     * <pre>
     * enable watchdog sound = 4000; parport 
     * </pre>
     */
    EMCMOT_DISABLE_WATCHDOG(7, 4007),
    /**
     * <code>EMCMOT_ACTIVATE_JOINT = 4008;</code>
     *
     * <pre>
     * make joint active 
     * </pre>
     */
    EMCMOT_ACTIVATE_JOINT(8, 4008),
    /**
     * <code>EMCMOT_DEACTIVATE_JOINT = 4009;</code>
     *
     * <pre>
     * make joint inactive 
     * </pre>
     */
    EMCMOT_DEACTIVATE_JOINT(9, 4009),
    /**
     * <code>EMCMOT_PAUSE = 4010;</code>
     *
     * <pre>
     * pause motion 
     * </pre>
     */
    EMCMOT_PAUSE(10, 4010),
    /**
     * <code>EMCMOT_RESUME = 4011;</code>
     *
     * <pre>
     * resume motion 
     * </pre>
     */
    EMCMOT_RESUME(11, 4011),
    /**
     * <code>EMCMOT_STEP = 4012;</code>
     *
     * <pre>
     * resume motion until id encountered 
     * </pre>
     */
    EMCMOT_STEP(12, 4012),
    /**
     * <code>EMCMOT_FREE = 4013;</code>
     *
     * <pre>
     * set mode to free (joint) motion 
     * </pre>
     */
    EMCMOT_FREE(13, 4013),
    /**
     * <code>EMCMOT_COORD = 4014;</code>
     *
     * <pre>
     * set mode to coordinated motion 
     * </pre>
     */
    EMCMOT_COORD(14, 4014),
    /**
     * <code>EMCMOT_TELEOP = 4015;</code>
     *
     * <pre>
     * set mode to teleop 
     * </pre>
     */
    EMCMOT_TELEOP(15, 4015),
    /**
     * <code>EMCMOT_SPINDLE_SCALE = 4016;</code>
     *
     * <pre>
     * set scale factor for spindle speed 
     * </pre>
     */
    EMCMOT_SPINDLE_SCALE(16, 4016),
    /**
     * <code>EMCMOT_SS_ENABLE = 4017;</code>
     *
     * <pre>
     * enable/disable scaling the spindle speed 
     * </pre>
     */
    EMCMOT_SS_ENABLE(17, 4017),
    /**
     * <code>EMCMOT_FEED_SCALE = 4018;</code>
     *
     * <pre>
     * set scale factor for feedrate 
     * </pre>
     */
    EMCMOT_FEED_SCALE(18, 4018),
    /**
     * <code>EMCMOT_FS_ENABLE = 4019;</code>
     *
     * <pre>
     * enable/disable scaling feedrate 
     * </pre>
     */
    EMCMOT_FS_ENABLE(19, 4019),
    /**
     * <code>EMCMOT_FH_ENABLE = 4020;</code>
     *
     * <pre>
     * enable/disable feed_hold 
     * </pre>
     */
    EMCMOT_FH_ENABLE(20, 4020),
    /**
     * <code>EMCMOT_AF_ENABLE = 4021;</code>
     *
     * <pre>
     * enable/disable adaptive feedrate 
     * </pre>
     */
    EMCMOT_AF_ENABLE(21, 4021),
    /**
     * <code>EMCMOT_OVERRIDE_LIMITS = 4022;</code>
     *
     * <pre>
     * temporarily ignore limits until jog done 
     * </pre>
     */
    EMCMOT_OVERRIDE_LIMITS(22, 4022),
    /**
     * <code>EMCMOT_HOME = 4023;</code>
     *
     * <pre>
     * home a joint or all joints 
     * </pre>
     */
    EMCMOT_HOME(23, 4023),
    /**
     * <code>EMCMOT_UNHOME = 4024;</code>
     *
     * <pre>
     * unhome a joint or all joints
     * </pre>
     */
    EMCMOT_UNHOME(24, 4024),
    /**
     * <code>EMCMOT_JOG_CONT = 4025;</code>
     *
     * <pre>
     * continuous jog 
     * </pre>
     */
    EMCMOT_JOG_CONT(25, 4025),
    /**
     * <code>EMCMOT_JOG_INCR = 4026;</code>
     *
     * <pre>
     * incremental jog 
     * </pre>
     */
    EMCMOT_JOG_INCR(26, 4026),
    /**
     * <code>EMCMOT_JOG_ABS = 4027;</code>
     *
     * <pre>
     * absolute jog 
     * </pre>
     */
    EMCMOT_JOG_ABS(27, 4027),
    /**
     * <code>EMCMOT_SET_LINE = 4028;</code>
     *
     * <pre>
     * queue up a linear move 
     * </pre>
     */
    EMCMOT_SET_LINE(28, 4028),
    /**
     * <code>EMCMOT_SET_CIRCLE = 4029;</code>
     *
     * <pre>
     * queue up a circular move 
     * </pre>
     */
    EMCMOT_SET_CIRCLE(29, 4029),
    /**
     * <code>EMCMOT_SET_TELEOP_VECTOR = 4030;</code>
     *
     * <pre>
     * Move at a given velocity but in
     *world cartesian coordinates = 4000; not
     *in joint space like EMCMOT_JOG_* 
     * </pre>
     */
    EMCMOT_SET_TELEOP_VECTOR(30, 4030),
    /**
     * <code>EMCMOT_CLEAR_PROBE_FLAGS = 4031;</code>
     *
     * <pre>
     * clears probeTripped flag 
     * </pre>
     */
    EMCMOT_CLEAR_PROBE_FLAGS(31, 4031),
    /**
     * <code>EMCMOT_PROBE = 4032;</code>
     *
     * <pre>
     * go to pos = 4000; stop if probe trips = 4000; record
     *trip pos 
     * </pre>
     */
    EMCMOT_PROBE(32, 4032),
    /**
     * <code>EMCMOT_RIGID_TAP = 4033;</code>
     *
     * <pre>
     * go to pos = 4000; with sync to spindle speed = 4000;
     *then return to initial pos 
     * </pre>
     */
    EMCMOT_RIGID_TAP(33, 4033),
    /**
     * <code>EMCMOT_SET_POSITION_LIMITS = 4034;</code>
     *
     * <pre>
     * set the joint position +/- limits 
     * </pre>
     */
    EMCMOT_SET_POSITION_LIMITS(34, 4034),
    /**
     * <code>EMCMOT_SET_BACKLASH = 4035;</code>
     *
     * <pre>
     * set the joint backlash 
     * </pre>
     */
    EMCMOT_SET_BACKLASH(35, 4035),
    /**
     * <code>EMCMOT_SET_MIN_FERROR = 4036;</code>
     *
     * <pre>
     * minimum following error = 4000; input units 
     * </pre>
     */
    EMCMOT_SET_MIN_FERROR(36, 4036),
    /**
     * <code>EMCMOT_SET_MAX_FERROR = 4037;</code>
     *
     * <pre>
     * maximum following error = 4000; input units 
     * </pre>
     */
    EMCMOT_SET_MAX_FERROR(37, 4037),
    /**
     * <code>EMCMOT_SET_VEL = 4038;</code>
     *
     * <pre>
     * set the velocity for subsequent moves 
     * </pre>
     */
    EMCMOT_SET_VEL(38, 4038),
    /**
     * <code>EMCMOT_SET_VEL_LIMIT = 4039;</code>
     *
     * <pre>
     * set the max vel for all moves (tooltip) 
     * </pre>
     */
    EMCMOT_SET_VEL_LIMIT(39, 4039),
    /**
     * <code>EMCMOT_SET_JOINT_VEL_LIMIT = 4040;</code>
     *
     * <pre>
     * set the max joint vel 
     * </pre>
     */
    EMCMOT_SET_JOINT_VEL_LIMIT(40, 4040),
    /**
     * <code>EMCMOT_SET_JOINT_ACC_LIMIT = 4041;</code>
     *
     * <pre>
     * set the max joint accel 
     * </pre>
     */
    EMCMOT_SET_JOINT_ACC_LIMIT(41, 4041),
    /**
     * <code>EMCMOT_SET_ACC = 4042;</code>
     *
     * <pre>
     * set the max accel for moves (tooltip) 
     * </pre>
     */
    EMCMOT_SET_ACC(42, 4042),
    /**
     * <code>EMCMOT_SET_TERM_COND = 4043;</code>
     *
     * <pre>
     * set termination condition (stop = 4000; blend) 
     * </pre>
     */
    EMCMOT_SET_TERM_COND(43, 4043),
    /**
     * <code>EMCMOT_SET_NUM_AXES = 4044;</code>
     */
    EMCMOT_SET_NUM_AXES(44, 4044),
    /**
     * <code>EMCMOT_SET_WORLD_HOME = 4045;</code>
     *
     * <pre>
     * set pose for world home 
     * </pre>
     */
    EMCMOT_SET_WORLD_HOME(45, 4045),
    /**
     * <code>EMCMOT_SET_HOMING_PARAMS = 4046;</code>
     *
     * <pre>
     * sets joint homing parameters 
     * </pre>
     */
    EMCMOT_SET_HOMING_PARAMS(46, 4046),
    /**
     * <code>EMCMOT_SET_DEBUG = 4047;</code>
     *
     * <pre>
     * sets the debug level 
     * </pre>
     */
    EMCMOT_SET_DEBUG(47, 4047),
    /**
     * <code>EMCMOT_SET_DOUT = 4048;</code>
     *
     * <pre>
     * sets or unsets a DIO = 4000; this can be imediate or synched with motion 
     * </pre>
     */
    EMCMOT_SET_DOUT(48, 4048),
    /**
     * <code>EMCMOT_SET_AOUT = 4049;</code>
     *
     * <pre>
     * sets or unsets a AIO = 4000; this can be imediate or synched with motion 
     * </pre>
     */
    EMCMOT_SET_AOUT(49, 4049),
    /**
     * <code>EMCMOT_SET_SPINDLESYNC = 4050;</code>
     *
     * <pre>
     * syncronize motion to spindle encoder 
     * </pre>
     */
    EMCMOT_SET_SPINDLESYNC(50, 4050),
    /**
     * <code>EMCMOT_SPINDLE_ON = 4051;</code>
     *
     * <pre>
     * start the spindle 
     * </pre>
     */
    EMCMOT_SPINDLE_ON(51, 4051),
    /**
     * <code>EMCMOT_SPINDLE_OFF = 4052;</code>
     *
     * <pre>
     * stop the spindle 
     * </pre>
     */
    EMCMOT_SPINDLE_OFF(52, 4052),
    /**
     * <code>EMCMOT_SPINDLE_INCREASE = 4053;</code>
     *
     * <pre>
     * spindle faster 
     * </pre>
     */
    EMCMOT_SPINDLE_INCREASE(53, 4053),
    /**
     * <code>EMCMOT_SPINDLE_DECREASE = 4054;</code>
     *
     * <pre>
     * spindle slower 
     * </pre>
     */
    EMCMOT_SPINDLE_DECREASE(54, 4054),
    /**
     * <code>EMCMOT_SPINDLE_BRAKE_ENGAGE = 4055;</code>
     *
     * <pre>
     * engage the spindle brake 
     * </pre>
     */
    EMCMOT_SPINDLE_BRAKE_ENGAGE(55, 4055),
    /**
     * <code>EMCMOT_SPINDLE_BRAKE_RELEASE = 4056;</code>
     *
     * <pre>
     * release the spindle brake 
     * </pre>
     */
    EMCMOT_SPINDLE_BRAKE_RELEASE(56, 4056),
    /**
     * <code>EMCMOT_SET_MOTOR_OFFSET = 4057;</code>
     *
     * <pre>
     * set the offset between joint and motor 
     * </pre>
     */
    EMCMOT_SET_MOTOR_OFFSET(57, 4057),
    /**
     * <code>EMCMOT_SET_JOINT_COMP = 4058;</code>
     *
     * <pre>
     * set a compensation triplet for a joint (nominal, forw., rev.) 
     * </pre>
     */
    EMCMOT_SET_JOINT_COMP(58, 4058),
    /**
     * <code>EMCMOT_SET_OFFSET = 4059;</code>
     *
     * <pre>
     * set tool offsets 
     * </pre>
     */
    EMCMOT_SET_OFFSET(59, 4059),
    ;

    /**
     * <code>EMCMOT_ABORT = 4000;</code>
     *
     * <pre>
     * abort all motion 
     * </pre>
     */
    public static final int EMCMOT_ABORT_VALUE = 4000;
    /**
     * <code>EMCMOT_AXIS_ABORT = 4001;</code>
     */
    public static final int EMCMOT_AXIS_ABORT_VALUE = 4001;
    /**
     * <code>EMCMOT_ENABLE = 4002;</code>
     *
     * <pre>
     * enable servos for active joints 
     * </pre>
     */
    public static final int EMCMOT_ENABLE_VALUE = 4002;
    /**
     * <code>EMCMOT_DISABLE = 4003;</code>
     *
     * <pre>
     * disable servos for active joints 
     * </pre>
     */
    public static final int EMCMOT_DISABLE_VALUE = 4003;
    /**
     * <code>EMCMOT_ENABLE_AMPLIFIER = 4004;</code>
     *
     * <pre>
     * enable amp outputs 
     * </pre>
     */
    public static final int EMCMOT_ENABLE_AMPLIFIER_VALUE = 4004;
    /**
     * <code>EMCMOT_DISABLE_AMPLIFIER = 4005;</code>
     *
     * <pre>
     * disable amp outputs 
     * </pre>
     */
    public static final int EMCMOT_DISABLE_AMPLIFIER_VALUE = 4005;
    /**
     * <code>EMCMOT_ENABLE_WATCHDOG = 4006;</code>
     *
     * <pre>
     * enable watchdog sound = 4000; parport 
     * </pre>
     */
    public static final int EMCMOT_ENABLE_WATCHDOG_VALUE = 4006;
    /**
     * <code>EMCMOT_DISABLE_WATCHDOG = 4007;</code>
     *
     * <pre>
     * enable watchdog sound = 4000; parport 
     * </pre>
     */
    public static final int EMCMOT_DISABLE_WATCHDOG_VALUE = 4007;
    /**
     * <code>EMCMOT_ACTIVATE_JOINT = 4008;</code>
     *
     * <pre>
     * make joint active 
     * </pre>
     */
    public static final int EMCMOT_ACTIVATE_JOINT_VALUE = 4008;
    /**
     * <code>EMCMOT_DEACTIVATE_JOINT = 4009;</code>
     *
     * <pre>
     * make joint inactive 
     * </pre>
     */
    public static final int EMCMOT_DEACTIVATE_JOINT_VALUE = 4009;
    /**
     * <code>EMCMOT_PAUSE = 4010;</code>
     *
     * <pre>
     * pause motion 
     * </pre>
     */
    public static final int EMCMOT_PAUSE_VALUE = 4010;
    /**
     * <code>EMCMOT_RESUME = 4011;</code>
     *
     * <pre>
     * resume motion 
     * </pre>
     */
    public static final int EMCMOT_RESUME_VALUE = 4011;
    /**
     * <code>EMCMOT_STEP = 4012;</code>
     *
     * <pre>
     * resume motion until id encountered 
     * </pre>
     */
    public static final int EMCMOT_STEP_VALUE = 4012;
    /**
     * <code>EMCMOT_FREE = 4013;</code>
     *
     * <pre>
     * set mode to free (joint) motion 
     * </pre>
     */
    public static final int EMCMOT_FREE_VALUE = 4013;
    /**
     * <code>EMCMOT_COORD = 4014;</code>
     *
     * <pre>
     * set mode to coordinated motion 
     * </pre>
     */
    public static final int EMCMOT_COORD_VALUE = 4014;
    /**
     * <code>EMCMOT_TELEOP = 4015;</code>
     *
     * <pre>
     * set mode to teleop 
     * </pre>
     */
    public static final int EMCMOT_TELEOP_VALUE = 4015;
    /**
     * <code>EMCMOT_SPINDLE_SCALE = 4016;</code>
     *
     * <pre>
     * set scale factor for spindle speed 
     * </pre>
     */
    public static final int EMCMOT_SPINDLE_SCALE_VALUE = 4016;
    /**
     * <code>EMCMOT_SS_ENABLE = 4017;</code>
     *
     * <pre>
     * enable/disable scaling the spindle speed 
     * </pre>
     */
    public static final int EMCMOT_SS_ENABLE_VALUE = 4017;
    /**
     * <code>EMCMOT_FEED_SCALE = 4018;</code>
     *
     * <pre>
     * set scale factor for feedrate 
     * </pre>
     */
    public static final int EMCMOT_FEED_SCALE_VALUE = 4018;
    /**
     * <code>EMCMOT_FS_ENABLE = 4019;</code>
     *
     * <pre>
     * enable/disable scaling feedrate 
     * </pre>
     */
    public static final int EMCMOT_FS_ENABLE_VALUE = 4019;
    /**
     * <code>EMCMOT_FH_ENABLE = 4020;</code>
     *
     * <pre>
     * enable/disable feed_hold 
     * </pre>
     */
    public static final int EMCMOT_FH_ENABLE_VALUE = 4020;
    /**
     * <code>EMCMOT_AF_ENABLE = 4021;</code>
     *
     * <pre>
     * enable/disable adaptive feedrate 
     * </pre>
     */
    public static final int EMCMOT_AF_ENABLE_VALUE = 4021;
    /**
     * <code>EMCMOT_OVERRIDE_LIMITS = 4022;</code>
     *
     * <pre>
     * temporarily ignore limits until jog done 
     * </pre>
     */
    public static final int EMCMOT_OVERRIDE_LIMITS_VALUE = 4022;
    /**
     * <code>EMCMOT_HOME = 4023;</code>
     *
     * <pre>
     * home a joint or all joints 
     * </pre>
     */
    public static final int EMCMOT_HOME_VALUE = 4023;
    /**
     * <code>EMCMOT_UNHOME = 4024;</code>
     *
     * <pre>
     * unhome a joint or all joints
     * </pre>
     */
    public static final int EMCMOT_UNHOME_VALUE = 4024;
    /**
     * <code>EMCMOT_JOG_CONT = 4025;</code>
     *
     * <pre>
     * continuous jog 
     * </pre>
     */
    public static final int EMCMOT_JOG_CONT_VALUE = 4025;
    /**
     * <code>EMCMOT_JOG_INCR = 4026;</code>
     *
     * <pre>
     * incremental jog 
     * </pre>
     */
    public static final int EMCMOT_JOG_INCR_VALUE = 4026;
    /**
     * <code>EMCMOT_JOG_ABS = 4027;</code>
     *
     * <pre>
     * absolute jog 
     * </pre>
     */
    public static final int EMCMOT_JOG_ABS_VALUE = 4027;
    /**
     * <code>EMCMOT_SET_LINE = 4028;</code>
     *
     * <pre>
     * queue up a linear move 
     * </pre>
     */
    public static final int EMCMOT_SET_LINE_VALUE = 4028;
    /**
     * <code>EMCMOT_SET_CIRCLE = 4029;</code>
     *
     * <pre>
     * queue up a circular move 
     * </pre>
     */
    public static final int EMCMOT_SET_CIRCLE_VALUE = 4029;
    /**
     * <code>EMCMOT_SET_TELEOP_VECTOR = 4030;</code>
     *
     * <pre>
     * Move at a given velocity but in
     *world cartesian coordinates = 4000; not
     *in joint space like EMCMOT_JOG_* 
     * </pre>
     */
    public static final int EMCMOT_SET_TELEOP_VECTOR_VALUE = 4030;
    /**
     * <code>EMCMOT_CLEAR_PROBE_FLAGS = 4031;</code>
     *
     * <pre>
     * clears probeTripped flag 
     * </pre>
     */
    public static final int EMCMOT_CLEAR_PROBE_FLAGS_VALUE = 4031;
    /**
     * <code>EMCMOT_PROBE = 4032;</code>
     *
     * <pre>
     * go to pos = 4000; stop if probe trips = 4000; record
     *trip pos 
     * </pre>
     */
    public static final int EMCMOT_PROBE_VALUE = 4032;
    /**
     * <code>EMCMOT_RIGID_TAP = 4033;</code>
     *
     * <pre>
     * go to pos = 4000; with sync to spindle speed = 4000;
     *then return to initial pos 
     * </pre>
     */
    public static final int EMCMOT_RIGID_TAP_VALUE = 4033;
    /**
     * <code>EMCMOT_SET_POSITION_LIMITS = 4034;</code>
     *
     * <pre>
     * set the joint position +/- limits 
     * </pre>
     */
    public static final int EMCMOT_SET_POSITION_LIMITS_VALUE = 4034;
    /**
     * <code>EMCMOT_SET_BACKLASH = 4035;</code>
     *
     * <pre>
     * set the joint backlash 
     * </pre>
     */
    public static final int EMCMOT_SET_BACKLASH_VALUE = 4035;
    /**
     * <code>EMCMOT_SET_MIN_FERROR = 4036;</code>
     *
     * <pre>
     * minimum following error = 4000; input units 
     * </pre>
     */
    public static final int EMCMOT_SET_MIN_FERROR_VALUE = 4036;
    /**
     * <code>EMCMOT_SET_MAX_FERROR = 4037;</code>
     *
     * <pre>
     * maximum following error = 4000; input units 
     * </pre>
     */
    public static final int EMCMOT_SET_MAX_FERROR_VALUE = 4037;
    /**
     * <code>EMCMOT_SET_VEL = 4038;</code>
     *
     * <pre>
     * set the velocity for subsequent moves 
     * </pre>
     */
    public static final int EMCMOT_SET_VEL_VALUE = 4038;
    /**
     * <code>EMCMOT_SET_VEL_LIMIT = 4039;</code>
     *
     * <pre>
     * set the max vel for all moves (tooltip) 
     * </pre>
     */
    public static final int EMCMOT_SET_VEL_LIMIT_VALUE = 4039;
    /**
     * <code>EMCMOT_SET_JOINT_VEL_LIMIT = 4040;</code>
     *
     * <pre>
     * set the max joint vel 
     * </pre>
     */
    public static final int EMCMOT_SET_JOINT_VEL_LIMIT_VALUE = 4040;
    /**
     * <code>EMCMOT_SET_JOINT_ACC_LIMIT = 4041;</code>
     *
     * <pre>
     * set the max joint accel 
     * </pre>
     */
    public static final int EMCMOT_SET_JOINT_ACC_LIMIT_VALUE = 4041;
    /**
     * <code>EMCMOT_SET_ACC = 4042;</code>
     *
     * <pre>
     * set the max accel for moves (tooltip) 
     * </pre>
     */
    public static final int EMCMOT_SET_ACC_VALUE = 4042;
    /**
     * <code>EMCMOT_SET_TERM_COND = 4043;</code>
     *
     * <pre>
     * set termination condition (stop = 4000; blend) 
     * </pre>
     */
    public static final int EMCMOT_SET_TERM_COND_VALUE = 4043;
    /**
     * <code>EMCMOT_SET_NUM_AXES = 4044;</code>
     */
    public static final int EMCMOT_SET_NUM_AXES_VALUE = 4044;
    /**
     * <code>EMCMOT_SET_WORLD_HOME = 4045;</code>
     *
     * <pre>
     * set pose for world home 
     * </pre>
     */
    public static final int EMCMOT_SET_WORLD_HOME_VALUE = 4045;
    /**
     * <code>EMCMOT_SET_HOMING_PARAMS = 4046;</code>
     *
     * <pre>
     * sets joint homing parameters 
     * </pre>
     */
    public static final int EMCMOT_SET_HOMING_PARAMS_VALUE = 4046;
    /**
     * <code>EMCMOT_SET_DEBUG = 4047;</code>
     *
     * <pre>
     * sets the debug level 
     * </pre>
     */
    public static final int EMCMOT_SET_DEBUG_VALUE = 4047;
    /**
     * <code>EMCMOT_SET_DOUT = 4048;</code>
     *
     * <pre>
     * sets or unsets a DIO = 4000; this can be imediate or synched with motion 
     * </pre>
     */
    public static final int EMCMOT_SET_DOUT_VALUE = 4048;
    /**
     * <code>EMCMOT_SET_AOUT = 4049;</code>
     *
     * <pre>
     * sets or unsets a AIO = 4000; this can be imediate or synched with motion 
     * </pre>
     */
    public static final int EMCMOT_SET_AOUT_VALUE = 4049;
    /**
     * <code>EMCMOT_SET_SPINDLESYNC = 4050;</code>
     *
     * <pre>
     * syncronize motion to spindle encoder 
     * </pre>
     */
    public static final int EMCMOT_SET_SPINDLESYNC_VALUE = 4050;
    /**
     * <code>EMCMOT_SPINDLE_ON = 4051;</code>
     *
     * <pre>
     * start the spindle 
     * </pre>
     */
    public static final int EMCMOT_SPINDLE_ON_VALUE = 4051;
    /**
     * <code>EMCMOT_SPINDLE_OFF = 4052;</code>
     *
     * <pre>
     * stop the spindle 
     * </pre>
     */
    public static final int EMCMOT_SPINDLE_OFF_VALUE = 4052;
    /**
     * <code>EMCMOT_SPINDLE_INCREASE = 4053;</code>
     *
     * <pre>
     * spindle faster 
     * </pre>
     */
    public static final int EMCMOT_SPINDLE_INCREASE_VALUE = 4053;
    /**
     * <code>EMCMOT_SPINDLE_DECREASE = 4054;</code>
     *
     * <pre>
     * spindle slower 
     * </pre>
     */
    public static final int EMCMOT_SPINDLE_DECREASE_VALUE = 4054;
    /**
     * <code>EMCMOT_SPINDLE_BRAKE_ENGAGE = 4055;</code>
     *
     * <pre>
     * engage the spindle brake 
     * </pre>
     */
    public static final int EMCMOT_SPINDLE_BRAKE_ENGAGE_VALUE = 4055;
    /**
     * <code>EMCMOT_SPINDLE_BRAKE_RELEASE = 4056;</code>
     *
     * <pre>
     * release the spindle brake 
     * </pre>
     */
    public static final int EMCMOT_SPINDLE_BRAKE_RELEASE_VALUE = 4056;
    /**
     * <code>EMCMOT_SET_MOTOR_OFFSET = 4057;</code>
     *
     * <pre>
     * set the offset between joint and motor 
     * </pre>
     */
    public static final int EMCMOT_SET_MOTOR_OFFSET_VALUE = 4057;
    /**
     * <code>EMCMOT_SET_JOINT_COMP = 4058;</code>
     *
     * <pre>
     * set a compensation triplet for a joint (nominal, forw., rev.) 
     * </pre>
     */
    public static final int EMCMOT_SET_JOINT_COMP_VALUE = 4058;
    /**
     * <code>EMCMOT_SET_OFFSET = 4059;</code>
     *
     * <pre>
     * set tool offsets 
     * </pre>
     */
    public static final int EMCMOT_SET_OFFSET_VALUE = 4059;


    public final int getNumber() { return value; }

    public static cmd_code_t valueOf(int value) {
      switch (value) {
        case 4000: return EMCMOT_ABORT;
        case 4001: return EMCMOT_AXIS_ABORT;
        case 4002: return EMCMOT_ENABLE;
        case 4003: return EMCMOT_DISABLE;
        case 4004: return EMCMOT_ENABLE_AMPLIFIER;
        case 4005: return EMCMOT_DISABLE_AMPLIFIER;
        case 4006: return EMCMOT_ENABLE_WATCHDOG;
        case 4007: return EMCMOT_DISABLE_WATCHDOG;
        case 4008: return EMCMOT_ACTIVATE_JOINT;
        case 4009: return EMCMOT_DEACTIVATE_JOINT;
        case 4010: return EMCMOT_PAUSE;
        case 4011: return EMCMOT_RESUME;
        case 4012: return EMCMOT_STEP;
        case 4013: return EMCMOT_FREE;
        case 4014: return EMCMOT_COORD;
        case 4015: return EMCMOT_TELEOP;
        case 4016: return EMCMOT_SPINDLE_SCALE;
        case 4017: return EMCMOT_SS_ENABLE;
        case 4018: return EMCMOT_FEED_SCALE;
        case 4019: return EMCMOT_FS_ENABLE;
        case 4020: return EMCMOT_FH_ENABLE;
        case 4021: return EMCMOT_AF_ENABLE;
        case 4022: return EMCMOT_OVERRIDE_LIMITS;
        case 4023: return EMCMOT_HOME;
        case 4024: return EMCMOT_UNHOME;
        case 4025: return EMCMOT_JOG_CONT;
        case 4026: return EMCMOT_JOG_INCR;
        case 4027: return EMCMOT_JOG_ABS;
        case 4028: return EMCMOT_SET_LINE;
        case 4029: return EMCMOT_SET_CIRCLE;
        case 4030: return EMCMOT_SET_TELEOP_VECTOR;
        case 4031: return EMCMOT_CLEAR_PROBE_FLAGS;
        case 4032: return EMCMOT_PROBE;
        case 4033: return EMCMOT_RIGID_TAP;
        case 4034: return EMCMOT_SET_POSITION_LIMITS;
        case 4035: return EMCMOT_SET_BACKLASH;
        case 4036: return EMCMOT_SET_MIN_FERROR;
        case 4037: return EMCMOT_SET_MAX_FERROR;
        case 4038: return EMCMOT_SET_VEL;
        case 4039: return EMCMOT_SET_VEL_LIMIT;
        case 4040: return EMCMOT_SET_JOINT_VEL_LIMIT;
        case 4041: return EMCMOT_SET_JOINT_ACC_LIMIT;
        case 4042: return EMCMOT_SET_ACC;
        case 4043: return EMCMOT_SET_TERM_COND;
        case 4044: return EMCMOT_SET_NUM_AXES;
        case 4045: return EMCMOT_SET_WORLD_HOME;
        case 4046: return EMCMOT_SET_HOMING_PARAMS;
        case 4047: return EMCMOT_SET_DEBUG;
        case 4048: return EMCMOT_SET_DOUT;
        case 4049: return EMCMOT_SET_AOUT;
        case 4050: return EMCMOT_SET_SPINDLESYNC;
        case 4051: return EMCMOT_SPINDLE_ON;
        case 4052: return EMCMOT_SPINDLE_OFF;
        case 4053: return EMCMOT_SPINDLE_INCREASE;
        case 4054: return EMCMOT_SPINDLE_DECREASE;
        case 4055: return EMCMOT_SPINDLE_BRAKE_ENGAGE;
        case 4056: return EMCMOT_SPINDLE_BRAKE_RELEASE;
        case 4057: return EMCMOT_SET_MOTOR_OFFSET;
        case 4058: return EMCMOT_SET_JOINT_COMP;
        case 4059: return EMCMOT_SET_OFFSET;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<cmd_code_t>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<cmd_code_t>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<cmd_code_t>() {
            public cmd_code_t findValueByNumber(int number) {
              return cmd_code_t.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return pb.Motcmds.getDescriptor().getEnumTypes().get(1);
    }

    private static final cmd_code_t[] VALUES = values();

    public static cmd_code_t valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new java.lang.IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private cmd_code_t(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:pb.cmd_code_t)
  }

  /**
   * Protobuf enum {@code pb.cmd_status_t}
   */
  public enum cmd_status_t
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>EMCMOT_COMMAND_OK = 0;</code>
     *
     * <pre>
     * cmd honored 
     * </pre>
     */
    EMCMOT_COMMAND_OK(0, 0),
    /**
     * <code>EMCMOT_COMMAND_UNKNOWN_COMMAND = 1;</code>
     *
     * <pre>
     * cmd not understood 
     * </pre>
     */
    EMCMOT_COMMAND_UNKNOWN_COMMAND(1, 1),
    /**
     * <code>EMCMOT_COMMAND_INVALID_COMMAND = 2;</code>
     *
     * <pre>
     * cmd can't be handled now 
     * </pre>
     */
    EMCMOT_COMMAND_INVALID_COMMAND(2, 2),
    /**
     * <code>EMCMOT_COMMAND_INVALID_PARAMS = 3;</code>
     *
     * <pre>
     * bad cmd params 
     * </pre>
     */
    EMCMOT_COMMAND_INVALID_PARAMS(3, 3),
    /**
     * <code>EMCMOT_COMMAND_BAD_EXEC = 4;</code>
     *
     * <pre>
     * error trying to initiate 
     * </pre>
     */
    EMCMOT_COMMAND_BAD_EXEC(4, 4),
    ;

    /**
     * <code>EMCMOT_COMMAND_OK = 0;</code>
     *
     * <pre>
     * cmd honored 
     * </pre>
     */
    public static final int EMCMOT_COMMAND_OK_VALUE = 0;
    /**
     * <code>EMCMOT_COMMAND_UNKNOWN_COMMAND = 1;</code>
     *
     * <pre>
     * cmd not understood 
     * </pre>
     */
    public static final int EMCMOT_COMMAND_UNKNOWN_COMMAND_VALUE = 1;
    /**
     * <code>EMCMOT_COMMAND_INVALID_COMMAND = 2;</code>
     *
     * <pre>
     * cmd can't be handled now 
     * </pre>
     */
    public static final int EMCMOT_COMMAND_INVALID_COMMAND_VALUE = 2;
    /**
     * <code>EMCMOT_COMMAND_INVALID_PARAMS = 3;</code>
     *
     * <pre>
     * bad cmd params 
     * </pre>
     */
    public static final int EMCMOT_COMMAND_INVALID_PARAMS_VALUE = 3;
    /**
     * <code>EMCMOT_COMMAND_BAD_EXEC = 4;</code>
     *
     * <pre>
     * error trying to initiate 
     * </pre>
     */
    public static final int EMCMOT_COMMAND_BAD_EXEC_VALUE = 4;


    public final int getNumber() { return value; }

    public static cmd_status_t valueOf(int value) {
      switch (value) {
        case 0: return EMCMOT_COMMAND_OK;
        case 1: return EMCMOT_COMMAND_UNKNOWN_COMMAND;
        case 2: return EMCMOT_COMMAND_INVALID_COMMAND;
        case 3: return EMCMOT_COMMAND_INVALID_PARAMS;
        case 4: return EMCMOT_COMMAND_BAD_EXEC;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<cmd_status_t>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<cmd_status_t>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<cmd_status_t>() {
            public cmd_status_t findValueByNumber(int number) {
              return cmd_status_t.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return pb.Motcmds.getDescriptor().getEnumTypes().get(2);
    }

    private static final cmd_status_t[] VALUES = values();

    public static cmd_status_t valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new java.lang.IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private cmd_status_t(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:pb.cmd_status_t)
  }

  public interface MotionCommandOrBuilder extends
      // @@protoc_insertion_point(interface_extends:pb.MotionCommand)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <code>required .pb.cmd_code_t command = 10;</code>
     */
    boolean hasCommand();
    /**
     * <code>required .pb.cmd_code_t command = 10;</code>
     */
    pb.Motcmds.cmd_code_t getCommand();

    /**
     * <code>required fixed32 commandNum = 20;</code>
     *
     * <pre>
     * increment this for new command 
     * </pre>
     */
    boolean hasCommandNum();
    /**
     * <code>required fixed32 commandNum = 20;</code>
     *
     * <pre>
     * increment this for new command 
     * </pre>
     */
    int getCommandNum();

    /**
     * <code>optional double motor_offset = 30;</code>
     *
     * <pre>
     * offset from joint to motor position 
     * </pre>
     */
    boolean hasMotorOffset();
    /**
     * <code>optional double motor_offset = 30;</code>
     *
     * <pre>
     * offset from joint to motor position 
     * </pre>
     */
    double getMotorOffset();

    /**
     * <code>optional double maxLimit = 40;</code>
     *
     * <pre>
     * pos value for position limit, output 
     * </pre>
     */
    boolean hasMaxLimit();
    /**
     * <code>optional double maxLimit = 40;</code>
     *
     * <pre>
     * pos value for position limit, output 
     * </pre>
     */
    double getMaxLimit();

    /**
     * <code>optional double minLimit = 50;</code>
     *
     * <pre>
     * neg value for position limit, output 
     * </pre>
     */
    boolean hasMinLimit();
    /**
     * <code>optional double minLimit = 50;</code>
     *
     * <pre>
     * neg value for position limit, output 
     * </pre>
     */
    double getMinLimit();

    /**
     * <code>optional .pb.EmcPose pos = 60;</code>
     *
     * <pre>
     * line/circle endpt, or teleop vector 
     * </pre>
     */
    boolean hasPos();
    /**
     * <code>optional .pb.EmcPose pos = 60;</code>
     *
     * <pre>
     * line/circle endpt, or teleop vector 
     * </pre>
     */
    pb.Emcclass.EmcPose getPos();
    /**
     * <code>optional .pb.EmcPose pos = 60;</code>
     *
     * <pre>
     * line/circle endpt, or teleop vector 
     * </pre>
     */
    pb.Emcclass.EmcPoseOrBuilder getPosOrBuilder();

    /**
     * <code>optional .pb.PmCartesian center = 70;</code>
     *
     * <pre>
     * center for circle 
     * </pre>
     */
    boolean hasCenter();
    /**
     * <code>optional .pb.PmCartesian center = 70;</code>
     *
     * <pre>
     * center for circle 
     * </pre>
     */
    pb.Emcclass.PmCartesian getCenter();
    /**
     * <code>optional .pb.PmCartesian center = 70;</code>
     *
     * <pre>
     * center for circle 
     * </pre>
     */
    pb.Emcclass.PmCartesianOrBuilder getCenterOrBuilder();

    /**
     * <code>optional .pb.PmCartesian normal = 80;</code>
     *
     * <pre>
     * normal vec for circle 
     * </pre>
     */
    boolean hasNormal();
    /**
     * <code>optional .pb.PmCartesian normal = 80;</code>
     *
     * <pre>
     * normal vec for circle 
     * </pre>
     */
    pb.Emcclass.PmCartesian getNormal();
    /**
     * <code>optional .pb.PmCartesian normal = 80;</code>
     *
     * <pre>
     * normal vec for circle 
     * </pre>
     */
    pb.Emcclass.PmCartesianOrBuilder getNormalOrBuilder();

    /**
     * <code>optional fixed32 turn = 90;</code>
     *
     * <pre>
     * turns for circle or which rotary to unlock for a line 
     * </pre>
     */
    boolean hasTurn();
    /**
     * <code>optional fixed32 turn = 90;</code>
     *
     * <pre>
     * turns for circle or which rotary to unlock for a line 
     * </pre>
     */
    int getTurn();

    /**
     * <code>optional double vel = 100;</code>
     *
     * <pre>
     * max velocity 
     * </pre>
     */
    boolean hasVel();
    /**
     * <code>optional double vel = 100;</code>
     *
     * <pre>
     * max velocity 
     * </pre>
     */
    double getVel();

    /**
     * <code>optional double ini_maxvel = 110;</code>
     *
     * <pre>
     * max velocity allowed by machine
     * </pre>
     */
    boolean hasIniMaxvel();
    /**
     * <code>optional double ini_maxvel = 110;</code>
     *
     * <pre>
     * max velocity allowed by machine
     * </pre>
     */
    double getIniMaxvel();

    /**
     * <code>optional .pb.MotionType motion_type = 120;</code>
     *
     * <pre>
     * optional constraints (the ini file)
     * </pre>
     */
    boolean hasMotionType();
    /**
     * <code>optional .pb.MotionType motion_type = 120;</code>
     *
     * <pre>
     * optional constraints (the ini file)
     * </pre>
     */
    pb.Motcmds.MotionType getMotionType();

    /**
     * <code>optional double spindlesync = 130;</code>
     *
     * <pre>
     * user units per spindle revolution, 0 = no sync 
     * </pre>
     */
    boolean hasSpindlesync();
    /**
     * <code>optional double spindlesync = 130;</code>
     *
     * <pre>
     * user units per spindle revolution, 0 = no sync 
     * </pre>
     */
    double getSpindlesync();

    /**
     * <code>optional double acc = 140;</code>
     *
     * <pre>
     * max acceleration 
     * </pre>
     */
    boolean hasAcc();
    /**
     * <code>optional double acc = 140;</code>
     *
     * <pre>
     * max acceleration 
     * </pre>
     */
    double getAcc();

    /**
     * <code>optional double backlash = 150;</code>
     *
     * <pre>
     * amount of backlash 
     * </pre>
     */
    boolean hasBacklash();
    /**
     * <code>optional double backlash = 150;</code>
     *
     * <pre>
     * amount of backlash 
     * </pre>
     */
    double getBacklash();

    /**
     * <code>optional fixed32 id = 160;</code>
     *
     * <pre>
     * id for motion 
     * </pre>
     */
    boolean hasId();
    /**
     * <code>optional fixed32 id = 160;</code>
     *
     * <pre>
     * id for motion 
     * </pre>
     */
    int getId();

    /**
     * <code>optional fixed32 termCond = 170;</code>
     *
     * <pre>
     * termination condition 
     * </pre>
     */
    boolean hasTermCond();
    /**
     * <code>optional fixed32 termCond = 170;</code>
     *
     * <pre>
     * termination condition 
     * </pre>
     */
    int getTermCond();

    /**
     * <code>optional double tolerance = 180;</code>
     *
     * <pre>
     * tolerance for path deviation in CONTINUOUS mode 
     * </pre>
     */
    boolean hasTolerance();
    /**
     * <code>optional double tolerance = 180;</code>
     *
     * <pre>
     * tolerance for path deviation in CONTINUOUS mode 
     * </pre>
     */
    double getTolerance();

    /**
     * <code>optional fixed32 axis = 190;</code>
     */
    boolean hasAxis();
    /**
     * <code>optional fixed32 axis = 190;</code>
     */
    int getAxis();

    /**
     * <code>optional double scale = 200;</code>
     *
     * <pre>
     * velocity scale or spindle_speed scale arg 
     * </pre>
     */
    boolean hasScale();
    /**
     * <code>optional double scale = 200;</code>
     *
     * <pre>
     * velocity scale or spindle_speed scale arg 
     * </pre>
     */
    double getScale();

    /**
     * <code>optional double offset = 210;</code>
     *
     * <pre>
     * input, output, or home offset arg 
     * </pre>
     */
    boolean hasOffset();
    /**
     * <code>optional double offset = 210;</code>
     *
     * <pre>
     * input, output, or home offset arg 
     * </pre>
     */
    double getOffset();

    /**
     * <code>optional double home = 220;</code>
     *
     * <pre>
     * joint home position 
     * </pre>
     */
    boolean hasHome();
    /**
     * <code>optional double home = 220;</code>
     *
     * <pre>
     * joint home position 
     * </pre>
     */
    double getHome();

    /**
     * <code>optional double home_final_vel = 230;</code>
     *
     * <pre>
     * joint velocity for moving from OFFSET to HOME 
     * </pre>
     */
    boolean hasHomeFinalVel();
    /**
     * <code>optional double home_final_vel = 230;</code>
     *
     * <pre>
     * joint velocity for moving from OFFSET to HOME 
     * </pre>
     */
    double getHomeFinalVel();

    /**
     * <code>optional double search_vel = 240;</code>
     *
     * <pre>
     * home search velocity 
     * </pre>
     */
    boolean hasSearchVel();
    /**
     * <code>optional double search_vel = 240;</code>
     *
     * <pre>
     * home search velocity 
     * </pre>
     */
    double getSearchVel();

    /**
     * <code>optional double latch_vel = 250;</code>
     *
     * <pre>
     * home latch velocity 
     * </pre>
     */
    boolean hasLatchVel();
    /**
     * <code>optional double latch_vel = 250;</code>
     *
     * <pre>
     * home latch velocity 
     * </pre>
     */
    double getLatchVel();

    /**
     * <code>optional fixed32 flags = 260;</code>
     *
     * <pre>
     * homing config flags, other boolean args 
     * </pre>
     */
    boolean hasFlags();
    /**
     * <code>optional fixed32 flags = 260;</code>
     *
     * <pre>
     * homing config flags, other boolean args 
     * </pre>
     */
    int getFlags();

    /**
     * <code>optional fixed32 home_sequence = 270;</code>
     *
     * <pre>
     * order in homing sequence 
     * </pre>
     */
    boolean hasHomeSequence();
    /**
     * <code>optional fixed32 home_sequence = 270;</code>
     *
     * <pre>
     * order in homing sequence 
     * </pre>
     */
    int getHomeSequence();

    /**
     * <code>optional fixed32 volatile_home = 280;</code>
     *
     * <pre>
     * joint should get unhomed when we get unhome -2
     * </pre>
     */
    boolean hasVolatileHome();
    /**
     * <code>optional fixed32 volatile_home = 280;</code>
     *
     * <pre>
     * joint should get unhomed when we get unhome -2
     * </pre>
     */
    int getVolatileHome();

    /**
     * <code>optional double minFerror = 290;</code>
     *
     * <pre>
     * optional  (generated by task upon estop, etc)
     * </pre>
     */
    boolean hasMinFerror();
    /**
     * <code>optional double minFerror = 290;</code>
     *
     * <pre>
     * optional  (generated by task upon estop, etc)
     * </pre>
     */
    double getMinFerror();

    /**
     * <code>optional double maxFerror = 300;</code>
     *
     * <pre>
     * max following error 
     * </pre>
     */
    boolean hasMaxFerror();
    /**
     * <code>optional double maxFerror = 300;</code>
     *
     * <pre>
     * max following error 
     * </pre>
     */
    double getMaxFerror();

    /**
     * <code>optional fixed32 wdWait = 310;</code>
     *
     * <pre>
     * cycle to wait before toggling wd 
     * </pre>
     */
    boolean hasWdWait();
    /**
     * <code>optional fixed32 wdWait = 310;</code>
     *
     * <pre>
     * cycle to wait before toggling wd 
     * </pre>
     */
    int getWdWait();

    /**
     * <code>optional fixed32 debug = 320;</code>
     *
     * <pre>
     * debug level, from DEBUG in .ini file 
     * </pre>
     */
    boolean hasDebug();
    /**
     * <code>optional fixed32 debug = 320;</code>
     *
     * <pre>
     * debug level, from DEBUG in .ini file 
     * </pre>
     */
    int getDebug();

    /**
     * <code>optional int32 now = 330;</code>
     */
    boolean hasNow();
    /**
     * <code>optional int32 now = 330;</code>
     */
    int getNow();

    /**
     * <code>optional int32 out = 340;</code>
     */
    boolean hasOut();
    /**
     * <code>optional int32 out = 340;</code>
     */
    int getOut();

    /**
     * <code>optional int32 start = 350;</code>
     */
    boolean hasStart();
    /**
     * <code>optional int32 start = 350;</code>
     */
    int getStart();

    /**
     * <code>optional int32 end = 360;</code>
     *
     * <pre>
     * these are related to synched AOUT/DOUT
     * </pre>
     */
    boolean hasEnd();
    /**
     * <code>optional int32 end = 360;</code>
     *
     * <pre>
     * these are related to synched AOUT/DOUT
     * </pre>
     */
    int getEnd();

    /**
     * <code>optional int32 mode = 370;</code>
     *
     * <pre>
     * now=wether now or synched, out = which gets set,
     * start=start value, end=end value
     * </pre>
     */
    boolean hasMode();
    /**
     * <code>optional int32 mode = 370;</code>
     *
     * <pre>
     * now=wether now or synched, out = which gets set,
     * start=start value, end=end value
     * </pre>
     */
    int getMode();

    /**
     * <code>optional double comp_nominal = 380;</code>
     *
     * <pre>
     * compensation triplet, nominal, forward, reverse 
     * </pre>
     */
    boolean hasCompNominal();
    /**
     * <code>optional double comp_nominal = 380;</code>
     *
     * <pre>
     * compensation triplet, nominal, forward, reverse 
     * </pre>
     */
    double getCompNominal();

    /**
     * <code>optional double comp_forward = 390;</code>
     *
     * <pre>
     * compensation triplet, nominal, forward, reverse 
     * </pre>
     */
    boolean hasCompForward();
    /**
     * <code>optional double comp_forward = 390;</code>
     *
     * <pre>
     * compensation triplet, nominal, forward, reverse 
     * </pre>
     */
    double getCompForward();

    /**
     * <code>optional double comp_reverse = 400;</code>
     *
     * <pre>
     * compensation triplet, nominal, forward, reverse 
     * </pre>
     */
    boolean hasCompReverse();
    /**
     * <code>optional double comp_reverse = 400;</code>
     *
     * <pre>
     * compensation triplet, nominal, forward, reverse 
     * </pre>
     */
    double getCompReverse();

    /**
     * <code>optional int32 probe_type = 410;</code>
     *
     * <pre>
     * ~1 = error if probe operation is unsuccessful (ngc default)
     *|1 = suppress error, report in # instead
     *~2 = move until probe trips (ngc default)
     *|2 = move until probe clears 
     * </pre>
     */
    boolean hasProbeType();
    /**
     * <code>optional int32 probe_type = 410;</code>
     *
     * <pre>
     * ~1 = error if probe operation is unsuccessful (ngc default)
     *|1 = suppress error, report in # instead
     *~2 = move until probe trips (ngc default)
     *|2 = move until probe clears 
     * </pre>
     */
    int getProbeType();

    /**
     * <code>optional .pb.EmcPose tool_offset = 420;</code>
     *
     * <pre>
     * TLO 
     * </pre>
     */
    boolean hasToolOffset();
    /**
     * <code>optional .pb.EmcPose tool_offset = 420;</code>
     *
     * <pre>
     * TLO 
     * </pre>
     */
    pb.Emcclass.EmcPose getToolOffset();
    /**
     * <code>optional .pb.EmcPose tool_offset = 420;</code>
     *
     * <pre>
     * TLO 
     * </pre>
     */
    pb.Emcclass.EmcPoseOrBuilder getToolOffsetOrBuilder();
  }
  /**
   * Protobuf type {@code pb.MotionCommand}
   */
  public static final class MotionCommand extends
      com.google.protobuf.GeneratedMessage implements
      // @@protoc_insertion_point(message_implements:pb.MotionCommand)
      MotionCommandOrBuilder {
    // Use MotionCommand.newBuilder() to construct.
    private MotionCommand(com.google.protobuf.GeneratedMessage.Builder<?> builder) {
      super(builder);
      this.unknownFields = builder.getUnknownFields();
    }
    private MotionCommand(boolean noInit) { this.unknownFields = com.google.protobuf.UnknownFieldSet.getDefaultInstance(); }

    private static final MotionCommand defaultInstance;
    public static MotionCommand getDefaultInstance() {
      return defaultInstance;
    }

    public MotionCommand getDefaultInstanceForType() {
      return defaultInstance;
    }

    private final com.google.protobuf.UnknownFieldSet unknownFields;
    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
        getUnknownFields() {
      return this.unknownFields;
    }
    private MotionCommand(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      initFields();
      int mutable_bitField0_ = 0;
      int mutable_bitField1_ = 0;
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            default: {
              if (!parseUnknownField(input, unknownFields,
                                     extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
            case 80: {
              int rawValue = input.readEnum();
              pb.Motcmds.cmd_code_t value = pb.Motcmds.cmd_code_t.valueOf(rawValue);
              if (value == null) {
                unknownFields.mergeVarintField(10, rawValue);
              } else {
                bitField0_ |= 0x00000001;
                command_ = value;
              }
              break;
            }
            case 165: {
              bitField0_ |= 0x00000002;
              commandNum_ = input.readFixed32();
              break;
            }
            case 241: {
              bitField0_ |= 0x00000004;
              motorOffset_ = input.readDouble();
              break;
            }
            case 321: {
              bitField0_ |= 0x00000008;
              maxLimit_ = input.readDouble();
              break;
            }
            case 401: {
              bitField0_ |= 0x00000010;
              minLimit_ = input.readDouble();
              break;
            }
            case 482: {
              pb.Emcclass.EmcPose.Builder subBuilder = null;
              if (((bitField0_ & 0x00000020) == 0x00000020)) {
                subBuilder = pos_.toBuilder();
              }
              pos_ = input.readMessage(pb.Emcclass.EmcPose.PARSER, extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(pos_);
                pos_ = subBuilder.buildPartial();
              }
              bitField0_ |= 0x00000020;
              break;
            }
            case 562: {
              pb.Emcclass.PmCartesian.Builder subBuilder = null;
              if (((bitField0_ & 0x00000040) == 0x00000040)) {
                subBuilder = center_.toBuilder();
              }
              center_ = input.readMessage(pb.Emcclass.PmCartesian.PARSER, extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(center_);
                center_ = subBuilder.buildPartial();
              }
              bitField0_ |= 0x00000040;
              break;
            }
            case 642: {
              pb.Emcclass.PmCartesian.Builder subBuilder = null;
              if (((bitField0_ & 0x00000080) == 0x00000080)) {
                subBuilder = normal_.toBuilder();
              }
              normal_ = input.readMessage(pb.Emcclass.PmCartesian.PARSER, extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(normal_);
                normal_ = subBuilder.buildPartial();
              }
              bitField0_ |= 0x00000080;
              break;
            }
            case 725: {
              bitField0_ |= 0x00000100;
              turn_ = input.readFixed32();
              break;
            }
            case 801: {
              bitField0_ |= 0x00000200;
              vel_ = input.readDouble();
              break;
            }
            case 881: {
              bitField0_ |= 0x00000400;
              iniMaxvel_ = input.readDouble();
              break;
            }
            case 960: {
              int rawValue = input.readEnum();
              pb.Motcmds.MotionType value = pb.Motcmds.MotionType.valueOf(rawValue);
              if (value == null) {
                unknownFields.mergeVarintField(120, rawValue);
              } else {
                bitField0_ |= 0x00000800;
                motionType_ = value;
              }
              break;
            }
            case 1041: {
              bitField0_ |= 0x00001000;
              spindlesync_ = input.readDouble();
              break;
            }
            case 1121: {
              bitField0_ |= 0x00002000;
              acc_ = input.readDouble();
              break;
            }
            case 1201: {
              bitField0_ |= 0x00004000;
              backlash_ = input.readDouble();
              break;
            }
            case 1285: {
              bitField0_ |= 0x00008000;
              id_ = input.readFixed32();
              break;
            }
            case 1365: {
              bitField0_ |= 0x00010000;
              termCond_ = input.readFixed32();
              break;
            }
            case 1441: {
              bitField0_ |= 0x00020000;
              tolerance_ = input.readDouble();
              break;
            }
            case 1525: {
              bitField0_ |= 0x00040000;
              axis_ = input.readFixed32();
              break;
            }
            case 1601: {
              bitField0_ |= 0x00080000;
              scale_ = input.readDouble();
              break;
            }
            case 1681: {
              bitField0_ |= 0x00100000;
              offset_ = input.readDouble();
              break;
            }
            case 1761: {
              bitField0_ |= 0x00200000;
              home_ = input.readDouble();
              break;
            }
            case 1841: {
              bitField0_ |= 0x00400000;
              homeFinalVel_ = input.readDouble();
              break;
            }
            case 1921: {
              bitField0_ |= 0x00800000;
              searchVel_ = input.readDouble();
              break;
            }
            case 2001: {
              bitField0_ |= 0x01000000;
              latchVel_ = input.readDouble();
              break;
            }
            case 2085: {
              bitField0_ |= 0x02000000;
              flags_ = input.readFixed32();
              break;
            }
            case 2165: {
              bitField0_ |= 0x04000000;
              homeSequence_ = input.readFixed32();
              break;
            }
            case 2245: {
              bitField0_ |= 0x08000000;
              volatileHome_ = input.readFixed32();
              break;
            }
            case 2321: {
              bitField0_ |= 0x10000000;
              minFerror_ = input.readDouble();
              break;
            }
            case 2401: {
              bitField0_ |= 0x20000000;
              maxFerror_ = input.readDouble();
              break;
            }
            case 2485: {
              bitField0_ |= 0x40000000;
              wdWait_ = input.readFixed32();
              break;
            }
            case 2565: {
              bitField0_ |= 0x80000000;
              debug_ = input.readFixed32();
              break;
            }
            case 2640: {
              bitField1_ |= 0x00000001;
              now_ = input.readInt32();
              break;
            }
            case 2720: {
              bitField1_ |= 0x00000002;
              out_ = input.readInt32();
              break;
            }
            case 2800: {
              bitField1_ |= 0x00000004;
              start_ = input.readInt32();
              break;
            }
            case 2880: {
              bitField1_ |= 0x00000008;
              end_ = input.readInt32();
              break;
            }
            case 2960: {
              bitField1_ |= 0x00000010;
              mode_ = input.readInt32();
              break;
            }
            case 3041: {
              bitField1_ |= 0x00000020;
              compNominal_ = input.readDouble();
              break;
            }
            case 3121: {
              bitField1_ |= 0x00000040;
              compForward_ = input.readDouble();
              break;
            }
            case 3201: {
              bitField1_ |= 0x00000080;
              compReverse_ = input.readDouble();
              break;
            }
            case 3280: {
              bitField1_ |= 0x00000100;
              probeType_ = input.readInt32();
              break;
            }
            case 3362: {
              pb.Emcclass.EmcPose.Builder subBuilder = null;
              if (((bitField1_ & 0x00000200) == 0x00000200)) {
                subBuilder = toolOffset_.toBuilder();
              }
              toolOffset_ = input.readMessage(pb.Emcclass.EmcPose.PARSER, extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(toolOffset_);
                toolOffset_ = subBuilder.buildPartial();
              }
              bitField1_ |= 0x00000200;
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e.getMessage()).setUnfinishedMessage(this);
      } finally {
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return pb.Motcmds.internal_static_pb_MotionCommand_descriptor;
    }

    protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return pb.Motcmds.internal_static_pb_MotionCommand_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              pb.Motcmds.MotionCommand.class, pb.Motcmds.MotionCommand.Builder.class);
    }

    public static com.google.protobuf.Parser<MotionCommand> PARSER =
        new com.google.protobuf.AbstractParser<MotionCommand>() {
      public MotionCommand parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return new MotionCommand(input, extensionRegistry);
      }
    };

    @java.lang.Override
    public com.google.protobuf.Parser<MotionCommand> getParserForType() {
      return PARSER;
    }

    private int bitField0_;
    private int bitField1_;
    public static final int COMMAND_FIELD_NUMBER = 10;
    private pb.Motcmds.cmd_code_t command_;
    /**
     * <code>required .pb.cmd_code_t command = 10;</code>
     */
    public boolean hasCommand() {
      return ((bitField0_ & 0x00000001) == 0x00000001);
    }
    /**
     * <code>required .pb.cmd_code_t command = 10;</code>
     */
    public pb.Motcmds.cmd_code_t getCommand() {
      return command_;
    }

    public static final int COMMANDNUM_FIELD_NUMBER = 20;
    private int commandNum_;
    /**
     * <code>required fixed32 commandNum = 20;</code>
     *
     * <pre>
     * increment this for new command 
     * </pre>
     */
    public boolean hasCommandNum() {
      return ((bitField0_ & 0x00000002) == 0x00000002);
    }
    /**
     * <code>required fixed32 commandNum = 20;</code>
     *
     * <pre>
     * increment this for new command 
     * </pre>
     */
    public int getCommandNum() {
      return commandNum_;
    }

    public static final int MOTOR_OFFSET_FIELD_NUMBER = 30;
    private double motorOffset_;
    /**
     * <code>optional double motor_offset = 30;</code>
     *
     * <pre>
     * offset from joint to motor position 
     * </pre>
     */
    public boolean hasMotorOffset() {
      return ((bitField0_ & 0x00000004) == 0x00000004);
    }
    /**
     * <code>optional double motor_offset = 30;</code>
     *
     * <pre>
     * offset from joint to motor position 
     * </pre>
     */
    public double getMotorOffset() {
      return motorOffset_;
    }

    public static final int MAXLIMIT_FIELD_NUMBER = 40;
    private double maxLimit_;
    /**
     * <code>optional double maxLimit = 40;</code>
     *
     * <pre>
     * pos value for position limit, output 
     * </pre>
     */
    public boolean hasMaxLimit() {
      return ((bitField0_ & 0x00000008) == 0x00000008);
    }
    /**
     * <code>optional double maxLimit = 40;</code>
     *
     * <pre>
     * pos value for position limit, output 
     * </pre>
     */
    public double getMaxLimit() {
      return maxLimit_;
    }

    public static final int MINLIMIT_FIELD_NUMBER = 50;
    private double minLimit_;
    /**
     * <code>optional double minLimit = 50;</code>
     *
     * <pre>
     * neg value for position limit, output 
     * </pre>
     */
    public boolean hasMinLimit() {
      return ((bitField0_ & 0x00000010) == 0x00000010);
    }
    /**
     * <code>optional double minLimit = 50;</code>
     *
     * <pre>
     * neg value for position limit, output 
     * </pre>
     */
    public double getMinLimit() {
      return minLimit_;
    }

    public static final int POS_FIELD_NUMBER = 60;
    private pb.Emcclass.EmcPose pos_;
    /**
     * <code>optional .pb.EmcPose pos = 60;</code>
     *
     * <pre>
     * line/circle endpt, or teleop vector 
     * </pre>
     */
    public boolean hasPos() {
      return ((bitField0_ & 0x00000020) == 0x00000020);
    }
    /**
     * <code>optional .pb.EmcPose pos = 60;</code>
     *
     * <pre>
     * line/circle endpt, or teleop vector 
     * </pre>
     */
    public pb.Emcclass.EmcPose getPos() {
      return pos_;
    }
    /**
     * <code>optional .pb.EmcPose pos = 60;</code>
     *
     * <pre>
     * line/circle endpt, or teleop vector 
     * </pre>
     */
    public pb.Emcclass.EmcPoseOrBuilder getPosOrBuilder() {
      return pos_;
    }

    public static final int CENTER_FIELD_NUMBER = 70;
    private pb.Emcclass.PmCartesian center_;
    /**
     * <code>optional .pb.PmCartesian center = 70;</code>
     *
     * <pre>
     * center for circle 
     * </pre>
     */
    public boolean hasCenter() {
      return ((bitField0_ & 0x00000040) == 0x00000040);
    }
    /**
     * <code>optional .pb.PmCartesian center = 70;</code>
     *
     * <pre>
     * center for circle 
     * </pre>
     */
    public pb.Emcclass.PmCartesian getCenter() {
      return center_;
    }
    /**
     * <code>optional .pb.PmCartesian center = 70;</code>
     *
     * <pre>
     * center for circle 
     * </pre>
     */
    public pb.Emcclass.PmCartesianOrBuilder getCenterOrBuilder() {
      return center_;
    }

    public static final int NORMAL_FIELD_NUMBER = 80;
    private pb.Emcclass.PmCartesian normal_;
    /**
     * <code>optional .pb.PmCartesian normal = 80;</code>
     *
     * <pre>
     * normal vec for circle 
     * </pre>
     */
    public boolean hasNormal() {
      return ((bitField0_ & 0x00000080) == 0x00000080);
    }
    /**
     * <code>optional .pb.PmCartesian normal = 80;</code>
     *
     * <pre>
     * normal vec for circle 
     * </pre>
     */
    public pb.Emcclass.PmCartesian getNormal() {
      return normal_;
    }
    /**
     * <code>optional .pb.PmCartesian normal = 80;</code>
     *
     * <pre>
     * normal vec for circle 
     * </pre>
     */
    public pb.Emcclass.PmCartesianOrBuilder getNormalOrBuilder() {
      return normal_;
    }

    public static final int TURN_FIELD_NUMBER = 90;
    private int turn_;
    /**
     * <code>optional fixed32 turn = 90;</code>
     *
     * <pre>
     * turns for circle or which rotary to unlock for a line 
     * </pre>
     */
    public boolean hasTurn() {
      return ((bitField0_ & 0x00000100) == 0x00000100);
    }
    /**
     * <code>optional fixed32 turn = 90;</code>
     *
     * <pre>
     * turns for circle or which rotary to unlock for a line 
     * </pre>
     */
    public int getTurn() {
      return turn_;
    }

    public static final int VEL_FIELD_NUMBER = 100;
    private double vel_;
    /**
     * <code>optional double vel = 100;</code>
     *
     * <pre>
     * max velocity 
     * </pre>
     */
    public boolean hasVel() {
      return ((bitField0_ & 0x00000200) == 0x00000200);
    }
    /**
     * <code>optional double vel = 100;</code>
     *
     * <pre>
     * max velocity 
     * </pre>
     */
    public double getVel() {
      return vel_;
    }

    public static final int INI_MAXVEL_FIELD_NUMBER = 110;
    private double iniMaxvel_;
    /**
     * <code>optional double ini_maxvel = 110;</code>
     *
     * <pre>
     * max velocity allowed by machine
     * </pre>
     */
    public boolean hasIniMaxvel() {
      return ((bitField0_ & 0x00000400) == 0x00000400);
    }
    /**
     * <code>optional double ini_maxvel = 110;</code>
     *
     * <pre>
     * max velocity allowed by machine
     * </pre>
     */
    public double getIniMaxvel() {
      return iniMaxvel_;
    }

    public static final int MOTION_TYPE_FIELD_NUMBER = 120;
    private pb.Motcmds.MotionType motionType_;
    /**
     * <code>optional .pb.MotionType motion_type = 120;</code>
     *
     * <pre>
     * optional constraints (the ini file)
     * </pre>
     */
    public boolean hasMotionType() {
      return ((bitField0_ & 0x00000800) == 0x00000800);
    }
    /**
     * <code>optional .pb.MotionType motion_type = 120;</code>
     *
     * <pre>
     * optional constraints (the ini file)
     * </pre>
     */
    public pb.Motcmds.MotionType getMotionType() {
      return motionType_;
    }

    public static final int SPINDLESYNC_FIELD_NUMBER = 130;
    private double spindlesync_;
    /**
     * <code>optional double spindlesync = 130;</code>
     *
     * <pre>
     * user units per spindle revolution, 0 = no sync 
     * </pre>
     */
    public boolean hasSpindlesync() {
      return ((bitField0_ & 0x00001000) == 0x00001000);
    }
    /**
     * <code>optional double spindlesync = 130;</code>
     *
     * <pre>
     * user units per spindle revolution, 0 = no sync 
     * </pre>
     */
    public double getSpindlesync() {
      return spindlesync_;
    }

    public static final int ACC_FIELD_NUMBER = 140;
    private double acc_;
    /**
     * <code>optional double acc = 140;</code>
     *
     * <pre>
     * max acceleration 
     * </pre>
     */
    public boolean hasAcc() {
      return ((bitField0_ & 0x00002000) == 0x00002000);
    }
    /**
     * <code>optional double acc = 140;</code>
     *
     * <pre>
     * max acceleration 
     * </pre>
     */
    public double getAcc() {
      return acc_;
    }

    public static final int BACKLASH_FIELD_NUMBER = 150;
    private double backlash_;
    /**
     * <code>optional double backlash = 150;</code>
     *
     * <pre>
     * amount of backlash 
     * </pre>
     */
    public boolean hasBacklash() {
      return ((bitField0_ & 0x00004000) == 0x00004000);
    }
    /**
     * <code>optional double backlash = 150;</code>
     *
     * <pre>
     * amount of backlash 
     * </pre>
     */
    public double getBacklash() {
      return backlash_;
    }

    public static final int ID_FIELD_NUMBER = 160;
    private int id_;
    /**
     * <code>optional fixed32 id = 160;</code>
     *
     * <pre>
     * id for motion 
     * </pre>
     */
    public boolean hasId() {
      return ((bitField0_ & 0x00008000) == 0x00008000);
    }
    /**
     * <code>optional fixed32 id = 160;</code>
     *
     * <pre>
     * id for motion 
     * </pre>
     */
    public int getId() {
      return id_;
    }

    public static final int TERMCOND_FIELD_NUMBER = 170;
    private int termCond_;
    /**
     * <code>optional fixed32 termCond = 170;</code>
     *
     * <pre>
     * termination condition 
     * </pre>
     */
    public boolean hasTermCond() {
      return ((bitField0_ & 0x00010000) == 0x00010000);
    }
    /**
     * <code>optional fixed32 termCond = 170;</code>
     *
     * <pre>
     * termination condition 
     * </pre>
     */
    public int getTermCond() {
      return termCond_;
    }

    public static final int TOLERANCE_FIELD_NUMBER = 180;
    private double tolerance_;
    /**
     * <code>optional double tolerance = 180;</code>
     *
     * <pre>
     * tolerance for path deviation in CONTINUOUS mode 
     * </pre>
     */
    public boolean hasTolerance() {
      return ((bitField0_ & 0x00020000) == 0x00020000);
    }
    /**
     * <code>optional double tolerance = 180;</code>
     *
     * <pre>
     * tolerance for path deviation in CONTINUOUS mode 
     * </pre>
     */
    public double getTolerance() {
      return tolerance_;
    }

    public static final int AXIS_FIELD_NUMBER = 190;
    private int axis_;
    /**
     * <code>optional fixed32 axis = 190;</code>
     */
    public boolean hasAxis() {
      return ((bitField0_ & 0x00040000) == 0x00040000);
    }
    /**
     * <code>optional fixed32 axis = 190;</code>
     */
    public int getAxis() {
      return axis_;
    }

    public static final int SCALE_FIELD_NUMBER = 200;
    private double scale_;
    /**
     * <code>optional double scale = 200;</code>
     *
     * <pre>
     * velocity scale or spindle_speed scale arg 
     * </pre>
     */
    public boolean hasScale() {
      return ((bitField0_ & 0x00080000) == 0x00080000);
    }
    /**
     * <code>optional double scale = 200;</code>
     *
     * <pre>
     * velocity scale or spindle_speed scale arg 
     * </pre>
     */
    public double getScale() {
      return scale_;
    }

    public static final int OFFSET_FIELD_NUMBER = 210;
    private double offset_;
    /**
     * <code>optional double offset = 210;</code>
     *
     * <pre>
     * input, output, or home offset arg 
     * </pre>
     */
    public boolean hasOffset() {
      return ((bitField0_ & 0x00100000) == 0x00100000);
    }
    /**
     * <code>optional double offset = 210;</code>
     *
     * <pre>
     * input, output, or home offset arg 
     * </pre>
     */
    public double getOffset() {
      return offset_;
    }

    public static final int HOME_FIELD_NUMBER = 220;
    private double home_;
    /**
     * <code>optional double home = 220;</code>
     *
     * <pre>
     * joint home position 
     * </pre>
     */
    public boolean hasHome() {
      return ((bitField0_ & 0x00200000) == 0x00200000);
    }
    /**
     * <code>optional double home = 220;</code>
     *
     * <pre>
     * joint home position 
     * </pre>
     */
    public double getHome() {
      return home_;
    }

    public static final int HOME_FINAL_VEL_FIELD_NUMBER = 230;
    private double homeFinalVel_;
    /**
     * <code>optional double home_final_vel = 230;</code>
     *
     * <pre>
     * joint velocity for moving from OFFSET to HOME 
     * </pre>
     */
    public boolean hasHomeFinalVel() {
      return ((bitField0_ & 0x00400000) == 0x00400000);
    }
    /**
     * <code>optional double home_final_vel = 230;</code>
     *
     * <pre>
     * joint velocity for moving from OFFSET to HOME 
     * </pre>
     */
    public double getHomeFinalVel() {
      return homeFinalVel_;
    }

    public static final int SEARCH_VEL_FIELD_NUMBER = 240;
    private double searchVel_;
    /**
     * <code>optional double search_vel = 240;</code>
     *
     * <pre>
     * home search velocity 
     * </pre>
     */
    public boolean hasSearchVel() {
      return ((bitField0_ & 0x00800000) == 0x00800000);
    }
    /**
     * <code>optional double search_vel = 240;</code>
     *
     * <pre>
     * home search velocity 
     * </pre>
     */
    public double getSearchVel() {
      return searchVel_;
    }

    public static final int LATCH_VEL_FIELD_NUMBER = 250;
    private double latchVel_;
    /**
     * <code>optional double latch_vel = 250;</code>
     *
     * <pre>
     * home latch velocity 
     * </pre>
     */
    public boolean hasLatchVel() {
      return ((bitField0_ & 0x01000000) == 0x01000000);
    }
    /**
     * <code>optional double latch_vel = 250;</code>
     *
     * <pre>
     * home latch velocity 
     * </pre>
     */
    public double getLatchVel() {
      return latchVel_;
    }

    public static final int FLAGS_FIELD_NUMBER = 260;
    private int flags_;
    /**
     * <code>optional fixed32 flags = 260;</code>
     *
     * <pre>
     * homing config flags, other boolean args 
     * </pre>
     */
    public boolean hasFlags() {
      return ((bitField0_ & 0x02000000) == 0x02000000);
    }
    /**
     * <code>optional fixed32 flags = 260;</code>
     *
     * <pre>
     * homing config flags, other boolean args 
     * </pre>
     */
    public int getFlags() {
      return flags_;
    }

    public static final int HOME_SEQUENCE_FIELD_NUMBER = 270;
    private int homeSequence_;
    /**
     * <code>optional fixed32 home_sequence = 270;</code>
     *
     * <pre>
     * order in homing sequence 
     * </pre>
     */
    public boolean hasHomeSequence() {
      return ((bitField0_ & 0x04000000) == 0x04000000);
    }
    /**
     * <code>optional fixed32 home_sequence = 270;</code>
     *
     * <pre>
     * order in homing sequence 
     * </pre>
     */
    public int getHomeSequence() {
      return homeSequence_;
    }

    public static final int VOLATILE_HOME_FIELD_NUMBER = 280;
    private int volatileHome_;
    /**
     * <code>optional fixed32 volatile_home = 280;</code>
     *
     * <pre>
     * joint should get unhomed when we get unhome -2
     * </pre>
     */
    public boolean hasVolatileHome() {
      return ((bitField0_ & 0x08000000) == 0x08000000);
    }
    /**
     * <code>optional fixed32 volatile_home = 280;</code>
     *
     * <pre>
     * joint should get unhomed when we get unhome -2
     * </pre>
     */
    public int getVolatileHome() {
      return volatileHome_;
    }

    public static final int MINFERROR_FIELD_NUMBER = 290;
    private double minFerror_;
    /**
     * <code>optional double minFerror = 290;</code>
     *
     * <pre>
     * optional  (generated by task upon estop, etc)
     * </pre>
     */
    public boolean hasMinFerror() {
      return ((bitField0_ & 0x10000000) == 0x10000000);
    }
    /**
     * <code>optional double minFerror = 290;</code>
     *
     * <pre>
     * optional  (generated by task upon estop, etc)
     * </pre>
     */
    public double getMinFerror() {
      return minFerror_;
    }

    public static final int MAXFERROR_FIELD_NUMBER = 300;
    private double maxFerror_;
    /**
     * <code>optional double maxFerror = 300;</code>
     *
     * <pre>
     * max following error 
     * </pre>
     */
    public boolean hasMaxFerror() {
      return ((bitField0_ & 0x20000000) == 0x20000000);
    }
    /**
     * <code>optional double maxFerror = 300;</code>
     *
     * <pre>
     * max following error 
     * </pre>
     */
    public double getMaxFerror() {
      return maxFerror_;
    }

    public static final int WDWAIT_FIELD_NUMBER = 310;
    private int wdWait_;
    /**
     * <code>optional fixed32 wdWait = 310;</code>
     *
     * <pre>
     * cycle to wait before toggling wd 
     * </pre>
     */
    public boolean hasWdWait() {
      return ((bitField0_ & 0x40000000) == 0x40000000);
    }
    /**
     * <code>optional fixed32 wdWait = 310;</code>
     *
     * <pre>
     * cycle to wait before toggling wd 
     * </pre>
     */
    public int getWdWait() {
      return wdWait_;
    }

    public static final int DEBUG_FIELD_NUMBER = 320;
    private int debug_;
    /**
     * <code>optional fixed32 debug = 320;</code>
     *
     * <pre>
     * debug level, from DEBUG in .ini file 
     * </pre>
     */
    public boolean hasDebug() {
      return ((bitField0_ & 0x80000000) == 0x80000000);
    }
    /**
     * <code>optional fixed32 debug = 320;</code>
     *
     * <pre>
     * debug level, from DEBUG in .ini file 
     * </pre>
     */
    public int getDebug() {
      return debug_;
    }

    public static final int NOW_FIELD_NUMBER = 330;
    private int now_;
    /**
     * <code>optional int32 now = 330;</code>
     */
    public boolean hasNow() {
      return ((bitField1_ & 0x00000001) == 0x00000001);
    }
    /**
     * <code>optional int32 now = 330;</code>
     */
    public int getNow() {
      return now_;
    }

    public static final int OUT_FIELD_NUMBER = 340;
    private int out_;
    /**
     * <code>optional int32 out = 340;</code>
     */
    public boolean hasOut() {
      return ((bitField1_ & 0x00000002) == 0x00000002);
    }
    /**
     * <code>optional int32 out = 340;</code>
     */
    public int getOut() {
      return out_;
    }

    public static final int START_FIELD_NUMBER = 350;
    private int start_;
    /**
     * <code>optional int32 start = 350;</code>
     */
    public boolean hasStart() {
      return ((bitField1_ & 0x00000004) == 0x00000004);
    }
    /**
     * <code>optional int32 start = 350;</code>
     */
    public int getStart() {
      return start_;
    }

    public static final int END_FIELD_NUMBER = 360;
    private int end_;
    /**
     * <code>optional int32 end = 360;</code>
     *
     * <pre>
     * these are related to synched AOUT/DOUT
     * </pre>
     */
    public boolean hasEnd() {
      return ((bitField1_ & 0x00000008) == 0x00000008);
    }
    /**
     * <code>optional int32 end = 360;</code>
     *
     * <pre>
     * these are related to synched AOUT/DOUT
     * </pre>
     */
    public int getEnd() {
      return end_;
    }

    public static final int MODE_FIELD_NUMBER = 370;
    private int mode_;
    /**
     * <code>optional int32 mode = 370;</code>
     *
     * <pre>
     * now=wether now or synched, out = which gets set,
     * start=start value, end=end value
     * </pre>
     */
    public boolean hasMode() {
      return ((bitField1_ & 0x00000010) == 0x00000010);
    }
    /**
     * <code>optional int32 mode = 370;</code>
     *
     * <pre>
     * now=wether now or synched, out = which gets set,
     * start=start value, end=end value
     * </pre>
     */
    public int getMode() {
      return mode_;
    }

    public static final int COMP_NOMINAL_FIELD_NUMBER = 380;
    private double compNominal_;
    /**
     * <code>optional double comp_nominal = 380;</code>
     *
     * <pre>
     * compensation triplet, nominal, forward, reverse 
     * </pre>
     */
    public boolean hasCompNominal() {
      return ((bitField1_ & 0x00000020) == 0x00000020);
    }
    /**
     * <code>optional double comp_nominal = 380;</code>
     *
     * <pre>
     * compensation triplet, nominal, forward, reverse 
     * </pre>
     */
    public double getCompNominal() {
      return compNominal_;
    }

    public static final int COMP_FORWARD_FIELD_NUMBER = 390;
    private double compForward_;
    /**
     * <code>optional double comp_forward = 390;</code>
     *
     * <pre>
     * compensation triplet, nominal, forward, reverse 
     * </pre>
     */
    public boolean hasCompForward() {
      return ((bitField1_ & 0x00000040) == 0x00000040);
    }
    /**
     * <code>optional double comp_forward = 390;</code>
     *
     * <pre>
     * compensation triplet, nominal, forward, reverse 
     * </pre>
     */
    public double getCompForward() {
      return compForward_;
    }

    public static final int COMP_REVERSE_FIELD_NUMBER = 400;
    private double compReverse_;
    /**
     * <code>optional double comp_reverse = 400;</code>
     *
     * <pre>
     * compensation triplet, nominal, forward, reverse 
     * </pre>
     */
    public boolean hasCompReverse() {
      return ((bitField1_ & 0x00000080) == 0x00000080);
    }
    /**
     * <code>optional double comp_reverse = 400;</code>
     *
     * <pre>
     * compensation triplet, nominal, forward, reverse 
     * </pre>
     */
    public double getCompReverse() {
      return compReverse_;
    }

    public static final int PROBE_TYPE_FIELD_NUMBER = 410;
    private int probeType_;
    /**
     * <code>optional int32 probe_type = 410;</code>
     *
     * <pre>
     * ~1 = error if probe operation is unsuccessful (ngc default)
     *|1 = suppress error, report in # instead
     *~2 = move until probe trips (ngc default)
     *|2 = move until probe clears 
     * </pre>
     */
    public boolean hasProbeType() {
      return ((bitField1_ & 0x00000100) == 0x00000100);
    }
    /**
     * <code>optional int32 probe_type = 410;</code>
     *
     * <pre>
     * ~1 = error if probe operation is unsuccessful (ngc default)
     *|1 = suppress error, report in # instead
     *~2 = move until probe trips (ngc default)
     *|2 = move until probe clears 
     * </pre>
     */
    public int getProbeType() {
      return probeType_;
    }

    public static final int TOOL_OFFSET_FIELD_NUMBER = 420;
    private pb.Emcclass.EmcPose toolOffset_;
    /**
     * <code>optional .pb.EmcPose tool_offset = 420;</code>
     *
     * <pre>
     * TLO 
     * </pre>
     */
    public boolean hasToolOffset() {
      return ((bitField1_ & 0x00000200) == 0x00000200);
    }
    /**
     * <code>optional .pb.EmcPose tool_offset = 420;</code>
     *
     * <pre>
     * TLO 
     * </pre>
     */
    public pb.Emcclass.EmcPose getToolOffset() {
      return toolOffset_;
    }
    /**
     * <code>optional .pb.EmcPose tool_offset = 420;</code>
     *
     * <pre>
     * TLO 
     * </pre>
     */
    public pb.Emcclass.EmcPoseOrBuilder getToolOffsetOrBuilder() {
      return toolOffset_;
    }

    private void initFields() {
      command_ = pb.Motcmds.cmd_code_t.EMCMOT_ABORT;
      commandNum_ = 0;
      motorOffset_ = 0D;
      maxLimit_ = 0D;
      minLimit_ = 0D;
      pos_ = pb.Emcclass.EmcPose.getDefaultInstance();
      center_ = pb.Emcclass.PmCartesian.getDefaultInstance();
      normal_ = pb.Emcclass.PmCartesian.getDefaultInstance();
      turn_ = 0;
      vel_ = 0D;
      iniMaxvel_ = 0D;
      motionType_ = pb.Motcmds.MotionType._EMC_MOTION_TYPE_NONE;
      spindlesync_ = 0D;
      acc_ = 0D;
      backlash_ = 0D;
      id_ = 0;
      termCond_ = 0;
      tolerance_ = 0D;
      axis_ = 0;
      scale_ = 0D;
      offset_ = 0D;
      home_ = 0D;
      homeFinalVel_ = 0D;
      searchVel_ = 0D;
      latchVel_ = 0D;
      flags_ = 0;
      homeSequence_ = 0;
      volatileHome_ = 0;
      minFerror_ = 0D;
      maxFerror_ = 0D;
      wdWait_ = 0;
      debug_ = 0;
      now_ = 0;
      out_ = 0;
      start_ = 0;
      end_ = 0;
      mode_ = 0;
      compNominal_ = 0D;
      compForward_ = 0D;
      compReverse_ = 0D;
      probeType_ = 0;
      toolOffset_ = pb.Emcclass.EmcPose.getDefaultInstance();
    }
    private byte memoizedIsInitialized = -1;
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      if (!hasCommand()) {
        memoizedIsInitialized = 0;
        return false;
      }
      if (!hasCommandNum()) {
        memoizedIsInitialized = 0;
        return false;
      }
      if (hasPos()) {
        if (!getPos().isInitialized()) {
          memoizedIsInitialized = 0;
          return false;
        }
      }
      if (hasToolOffset()) {
        if (!getToolOffset().isInitialized()) {
          memoizedIsInitialized = 0;
          return false;
        }
      }
      memoizedIsInitialized = 1;
      return true;
    }

    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      getSerializedSize();
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        output.writeEnum(10, command_.getNumber());
      }
      if (((bitField0_ & 0x00000002) == 0x00000002)) {
        output.writeFixed32(20, commandNum_);
      }
      if (((bitField0_ & 0x00000004) == 0x00000004)) {
        output.writeDouble(30, motorOffset_);
      }
      if (((bitField0_ & 0x00000008) == 0x00000008)) {
        output.writeDouble(40, maxLimit_);
      }
      if (((bitField0_ & 0x00000010) == 0x00000010)) {
        output.writeDouble(50, minLimit_);
      }
      if (((bitField0_ & 0x00000020) == 0x00000020)) {
        output.writeMessage(60, pos_);
      }
      if (((bitField0_ & 0x00000040) == 0x00000040)) {
        output.writeMessage(70, center_);
      }
      if (((bitField0_ & 0x00000080) == 0x00000080)) {
        output.writeMessage(80, normal_);
      }
      if (((bitField0_ & 0x00000100) == 0x00000100)) {
        output.writeFixed32(90, turn_);
      }
      if (((bitField0_ & 0x00000200) == 0x00000200)) {
        output.writeDouble(100, vel_);
      }
      if (((bitField0_ & 0x00000400) == 0x00000400)) {
        output.writeDouble(110, iniMaxvel_);
      }
      if (((bitField0_ & 0x00000800) == 0x00000800)) {
        output.writeEnum(120, motionType_.getNumber());
      }
      if (((bitField0_ & 0x00001000) == 0x00001000)) {
        output.writeDouble(130, spindlesync_);
      }
      if (((bitField0_ & 0x00002000) == 0x00002000)) {
        output.writeDouble(140, acc_);
      }
      if (((bitField0_ & 0x00004000) == 0x00004000)) {
        output.writeDouble(150, backlash_);
      }
      if (((bitField0_ & 0x00008000) == 0x00008000)) {
        output.writeFixed32(160, id_);
      }
      if (((bitField0_ & 0x00010000) == 0x00010000)) {
        output.writeFixed32(170, termCond_);
      }
      if (((bitField0_ & 0x00020000) == 0x00020000)) {
        output.writeDouble(180, tolerance_);
      }
      if (((bitField0_ & 0x00040000) == 0x00040000)) {
        output.writeFixed32(190, axis_);
      }
      if (((bitField0_ & 0x00080000) == 0x00080000)) {
        output.writeDouble(200, scale_);
      }
      if (((bitField0_ & 0x00100000) == 0x00100000)) {
        output.writeDouble(210, offset_);
      }
      if (((bitField0_ & 0x00200000) == 0x00200000)) {
        output.writeDouble(220, home_);
      }
      if (((bitField0_ & 0x00400000) == 0x00400000)) {
        output.writeDouble(230, homeFinalVel_);
      }
      if (((bitField0_ & 0x00800000) == 0x00800000)) {
        output.writeDouble(240, searchVel_);
      }
      if (((bitField0_ & 0x01000000) == 0x01000000)) {
        output.writeDouble(250, latchVel_);
      }
      if (((bitField0_ & 0x02000000) == 0x02000000)) {
        output.writeFixed32(260, flags_);
      }
      if (((bitField0_ & 0x04000000) == 0x04000000)) {
        output.writeFixed32(270, homeSequence_);
      }
      if (((bitField0_ & 0x08000000) == 0x08000000)) {
        output.writeFixed32(280, volatileHome_);
      }
      if (((bitField0_ & 0x10000000) == 0x10000000)) {
        output.writeDouble(290, minFerror_);
      }
      if (((bitField0_ & 0x20000000) == 0x20000000)) {
        output.writeDouble(300, maxFerror_);
      }
      if (((bitField0_ & 0x40000000) == 0x40000000)) {
        output.writeFixed32(310, wdWait_);
      }
      if (((bitField0_ & 0x80000000) == 0x80000000)) {
        output.writeFixed32(320, debug_);
      }
      if (((bitField1_ & 0x00000001) == 0x00000001)) {
        output.writeInt32(330, now_);
      }
      if (((bitField1_ & 0x00000002) == 0x00000002)) {
        output.writeInt32(340, out_);
      }
      if (((bitField1_ & 0x00000004) == 0x00000004)) {
        output.writeInt32(350, start_);
      }
      if (((bitField1_ & 0x00000008) == 0x00000008)) {
        output.writeInt32(360, end_);
      }
      if (((bitField1_ & 0x00000010) == 0x00000010)) {
        output.writeInt32(370, mode_);
      }
      if (((bitField1_ & 0x00000020) == 0x00000020)) {
        output.writeDouble(380, compNominal_);
      }
      if (((bitField1_ & 0x00000040) == 0x00000040)) {
        output.writeDouble(390, compForward_);
      }
      if (((bitField1_ & 0x00000080) == 0x00000080)) {
        output.writeDouble(400, compReverse_);
      }
      if (((bitField1_ & 0x00000100) == 0x00000100)) {
        output.writeInt32(410, probeType_);
      }
      if (((bitField1_ & 0x00000200) == 0x00000200)) {
        output.writeMessage(420, toolOffset_);
      }
      getUnknownFields().writeTo(output);
    }

    private int memoizedSerializedSize = -1;
    public int getSerializedSize() {
      int size = memoizedSerializedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        size += com.google.protobuf.CodedOutputStream
          .computeEnumSize(10, command_.getNumber());
      }
      if (((bitField0_ & 0x00000002) == 0x00000002)) {
        size += com.google.protobuf.CodedOutputStream
          .computeFixed32Size(20, commandNum_);
      }
      if (((bitField0_ & 0x00000004) == 0x00000004)) {
        size += com.google.protobuf.CodedOutputStream
          .computeDoubleSize(30, motorOffset_);
      }
      if (((bitField0_ & 0x00000008) == 0x00000008)) {
        size += com.google.protobuf.CodedOutputStream
          .computeDoubleSize(40, maxLimit_);
      }
      if (((bitField0_ & 0x00000010) == 0x00000010)) {
        size += com.google.protobuf.CodedOutputStream
          .computeDoubleSize(50, minLimit_);
      }
      if (((bitField0_ & 0x00000020) == 0x00000020)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(60, pos_);
      }
      if (((bitField0_ & 0x00000040) == 0x00000040)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(70, center_);
      }
      if (((bitField0_ & 0x00000080) == 0x00000080)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(80, normal_);
      }
      if (((bitField0_ & 0x00000100) == 0x00000100)) {
        size += com.google.protobuf.CodedOutputStream
          .computeFixed32Size(90, turn_);
      }
      if (((bitField0_ & 0x00000200) == 0x00000200)) {
        size += com.google.protobuf.CodedOutputStream
          .computeDoubleSize(100, vel_);
      }
      if (((bitField0_ & 0x00000400) == 0x00000400)) {
        size += com.google.protobuf.CodedOutputStream
          .computeDoubleSize(110, iniMaxvel_);
      }
      if (((bitField0_ & 0x00000800) == 0x00000800)) {
        size += com.google.protobuf.CodedOutputStream
          .computeEnumSize(120, motionType_.getNumber());
      }
      if (((bitField0_ & 0x00001000) == 0x00001000)) {
        size += com.google.protobuf.CodedOutputStream
          .computeDoubleSize(130, spindlesync_);
      }
      if (((bitField0_ & 0x00002000) == 0x00002000)) {
        size += com.google.protobuf.CodedOutputStream
          .computeDoubleSize(140, acc_);
      }
      if (((bitField0_ & 0x00004000) == 0x00004000)) {
        size += com.google.protobuf.CodedOutputStream
          .computeDoubleSize(150, backlash_);
      }
      if (((bitField0_ & 0x00008000) == 0x00008000)) {
        size += com.google.protobuf.CodedOutputStream
          .computeFixed32Size(160, id_);
      }
      if (((bitField0_ & 0x00010000) == 0x00010000)) {
        size += com.google.protobuf.CodedOutputStream
          .computeFixed32Size(170, termCond_);
      }
      if (((bitField0_ & 0x00020000) == 0x00020000)) {
        size += com.google.protobuf.CodedOutputStream
          .computeDoubleSize(180, tolerance_);
      }
      if (((bitField0_ & 0x00040000) == 0x00040000)) {
        size += com.google.protobuf.CodedOutputStream
          .computeFixed32Size(190, axis_);
      }
      if (((bitField0_ & 0x00080000) == 0x00080000)) {
        size += com.google.protobuf.CodedOutputStream
          .computeDoubleSize(200, scale_);
      }
      if (((bitField0_ & 0x00100000) == 0x00100000)) {
        size += com.google.protobuf.CodedOutputStream
          .computeDoubleSize(210, offset_);
      }
      if (((bitField0_ & 0x00200000) == 0x00200000)) {
        size += com.google.protobuf.CodedOutputStream
          .computeDoubleSize(220, home_);
      }
      if (((bitField0_ & 0x00400000) == 0x00400000)) {
        size += com.google.protobuf.CodedOutputStream
          .computeDoubleSize(230, homeFinalVel_);
      }
      if (((bitField0_ & 0x00800000) == 0x00800000)) {
        size += com.google.protobuf.CodedOutputStream
          .computeDoubleSize(240, searchVel_);
      }
      if (((bitField0_ & 0x01000000) == 0x01000000)) {
        size += com.google.protobuf.CodedOutputStream
          .computeDoubleSize(250, latchVel_);
      }
      if (((bitField0_ & 0x02000000) == 0x02000000)) {
        size += com.google.protobuf.CodedOutputStream
          .computeFixed32Size(260, flags_);
      }
      if (((bitField0_ & 0x04000000) == 0x04000000)) {
        size += com.google.protobuf.CodedOutputStream
          .computeFixed32Size(270, homeSequence_);
      }
      if (((bitField0_ & 0x08000000) == 0x08000000)) {
        size += com.google.protobuf.CodedOutputStream
          .computeFixed32Size(280, volatileHome_);
      }
      if (((bitField0_ & 0x10000000) == 0x10000000)) {
        size += com.google.protobuf.CodedOutputStream
          .computeDoubleSize(290, minFerror_);
      }
      if (((bitField0_ & 0x20000000) == 0x20000000)) {
        size += com.google.protobuf.CodedOutputStream
          .computeDoubleSize(300, maxFerror_);
      }
      if (((bitField0_ & 0x40000000) == 0x40000000)) {
        size += com.google.protobuf.CodedOutputStream
          .computeFixed32Size(310, wdWait_);
      }
      if (((bitField0_ & 0x80000000) == 0x80000000)) {
        size += com.google.protobuf.CodedOutputStream
          .computeFixed32Size(320, debug_);
      }
      if (((bitField1_ & 0x00000001) == 0x00000001)) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt32Size(330, now_);
      }
      if (((bitField1_ & 0x00000002) == 0x00000002)) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt32Size(340, out_);
      }
      if (((bitField1_ & 0x00000004) == 0x00000004)) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt32Size(350, start_);
      }
      if (((bitField1_ & 0x00000008) == 0x00000008)) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt32Size(360, end_);
      }
      if (((bitField1_ & 0x00000010) == 0x00000010)) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt32Size(370, mode_);
      }
      if (((bitField1_ & 0x00000020) == 0x00000020)) {
        size += com.google.protobuf.CodedOutputStream
          .computeDoubleSize(380, compNominal_);
      }
      if (((bitField1_ & 0x00000040) == 0x00000040)) {
        size += com.google.protobuf.CodedOutputStream
          .computeDoubleSize(390, compForward_);
      }
      if (((bitField1_ & 0x00000080) == 0x00000080)) {
        size += com.google.protobuf.CodedOutputStream
          .computeDoubleSize(400, compReverse_);
      }
      if (((bitField1_ & 0x00000100) == 0x00000100)) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt32Size(410, probeType_);
      }
      if (((bitField1_ & 0x00000200) == 0x00000200)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(420, toolOffset_);
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSerializedSize = size;
      return size;
    }

    private static final long serialVersionUID = 0L;
    @java.lang.Override
    protected java.lang.Object writeReplace()
        throws java.io.ObjectStreamException {
      return super.writeReplace();
    }

    public static pb.Motcmds.MotionCommand parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static pb.Motcmds.MotionCommand parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static pb.Motcmds.MotionCommand parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static pb.Motcmds.MotionCommand parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static pb.Motcmds.MotionCommand parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return PARSER.parseFrom(input);
    }
    public static pb.Motcmds.MotionCommand parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return PARSER.parseFrom(input, extensionRegistry);
    }
    public static pb.Motcmds.MotionCommand parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return PARSER.parseDelimitedFrom(input);
    }
    public static pb.Motcmds.MotionCommand parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return PARSER.parseDelimitedFrom(input, extensionRegistry);
    }
    public static pb.Motcmds.MotionCommand parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return PARSER.parseFrom(input);
    }
    public static pb.Motcmds.MotionCommand parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return PARSER.parseFrom(input, extensionRegistry);
    }

    public static Builder newBuilder() { return Builder.create(); }
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder(pb.Motcmds.MotionCommand prototype) {
      return newBuilder().mergeFrom(prototype);
    }
    public Builder toBuilder() { return newBuilder(this); }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessage.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * Protobuf type {@code pb.MotionCommand}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessage.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:pb.MotionCommand)
        pb.Motcmds.MotionCommandOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return pb.Motcmds.internal_static_pb_MotionCommand_descriptor;
      }

      protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return pb.Motcmds.internal_static_pb_MotionCommand_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                pb.Motcmds.MotionCommand.class, pb.Motcmds.MotionCommand.Builder.class);
      }

      // Construct using pb.Motcmds.MotionCommand.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessage.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessage.alwaysUseFieldBuilders) {
          getPosFieldBuilder();
          getCenterFieldBuilder();
          getNormalFieldBuilder();
          getToolOffsetFieldBuilder();
        }
      }
      private static Builder create() {
        return new Builder();
      }

      public Builder clear() {
        super.clear();
        command_ = pb.Motcmds.cmd_code_t.EMCMOT_ABORT;
        bitField0_ = (bitField0_ & ~0x00000001);
        commandNum_ = 0;
        bitField0_ = (bitField0_ & ~0x00000002);
        motorOffset_ = 0D;
        bitField0_ = (bitField0_ & ~0x00000004);
        maxLimit_ = 0D;
        bitField0_ = (bitField0_ & ~0x00000008);
        minLimit_ = 0D;
        bitField0_ = (bitField0_ & ~0x00000010);
        if (posBuilder_ == null) {
          pos_ = pb.Emcclass.EmcPose.getDefaultInstance();
        } else {
          posBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000020);
        if (centerBuilder_ == null) {
          center_ = pb.Emcclass.PmCartesian.getDefaultInstance();
        } else {
          centerBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000040);
        if (normalBuilder_ == null) {
          normal_ = pb.Emcclass.PmCartesian.getDefaultInstance();
        } else {
          normalBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000080);
        turn_ = 0;
        bitField0_ = (bitField0_ & ~0x00000100);
        vel_ = 0D;
        bitField0_ = (bitField0_ & ~0x00000200);
        iniMaxvel_ = 0D;
        bitField0_ = (bitField0_ & ~0x00000400);
        motionType_ = pb.Motcmds.MotionType._EMC_MOTION_TYPE_NONE;
        bitField0_ = (bitField0_ & ~0x00000800);
        spindlesync_ = 0D;
        bitField0_ = (bitField0_ & ~0x00001000);
        acc_ = 0D;
        bitField0_ = (bitField0_ & ~0x00002000);
        backlash_ = 0D;
        bitField0_ = (bitField0_ & ~0x00004000);
        id_ = 0;
        bitField0_ = (bitField0_ & ~0x00008000);
        termCond_ = 0;
        bitField0_ = (bitField0_ & ~0x00010000);
        tolerance_ = 0D;
        bitField0_ = (bitField0_ & ~0x00020000);
        axis_ = 0;
        bitField0_ = (bitField0_ & ~0x00040000);
        scale_ = 0D;
        bitField0_ = (bitField0_ & ~0x00080000);
        offset_ = 0D;
        bitField0_ = (bitField0_ & ~0x00100000);
        home_ = 0D;
        bitField0_ = (bitField0_ & ~0x00200000);
        homeFinalVel_ = 0D;
        bitField0_ = (bitField0_ & ~0x00400000);
        searchVel_ = 0D;
        bitField0_ = (bitField0_ & ~0x00800000);
        latchVel_ = 0D;
        bitField0_ = (bitField0_ & ~0x01000000);
        flags_ = 0;
        bitField0_ = (bitField0_ & ~0x02000000);
        homeSequence_ = 0;
        bitField0_ = (bitField0_ & ~0x04000000);
        volatileHome_ = 0;
        bitField0_ = (bitField0_ & ~0x08000000);
        minFerror_ = 0D;
        bitField0_ = (bitField0_ & ~0x10000000);
        maxFerror_ = 0D;
        bitField0_ = (bitField0_ & ~0x20000000);
        wdWait_ = 0;
        bitField0_ = (bitField0_ & ~0x40000000);
        debug_ = 0;
        bitField0_ = (bitField0_ & ~0x80000000);
        now_ = 0;
        bitField1_ = (bitField1_ & ~0x00000001);
        out_ = 0;
        bitField1_ = (bitField1_ & ~0x00000002);
        start_ = 0;
        bitField1_ = (bitField1_ & ~0x00000004);
        end_ = 0;
        bitField1_ = (bitField1_ & ~0x00000008);
        mode_ = 0;
        bitField1_ = (bitField1_ & ~0x00000010);
        compNominal_ = 0D;
        bitField1_ = (bitField1_ & ~0x00000020);
        compForward_ = 0D;
        bitField1_ = (bitField1_ & ~0x00000040);
        compReverse_ = 0D;
        bitField1_ = (bitField1_ & ~0x00000080);
        probeType_ = 0;
        bitField1_ = (bitField1_ & ~0x00000100);
        if (toolOffsetBuilder_ == null) {
          toolOffset_ = pb.Emcclass.EmcPose.getDefaultInstance();
        } else {
          toolOffsetBuilder_.clear();
        }
        bitField1_ = (bitField1_ & ~0x00000200);
        return this;
      }

      public Builder clone() {
        return create().mergeFrom(buildPartial());
      }

      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return pb.Motcmds.internal_static_pb_MotionCommand_descriptor;
      }

      public pb.Motcmds.MotionCommand getDefaultInstanceForType() {
        return pb.Motcmds.MotionCommand.getDefaultInstance();
      }

      public pb.Motcmds.MotionCommand build() {
        pb.Motcmds.MotionCommand result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      public pb.Motcmds.MotionCommand buildPartial() {
        pb.Motcmds.MotionCommand result = new pb.Motcmds.MotionCommand(this);
        int from_bitField0_ = bitField0_;
        int from_bitField1_ = bitField1_;
        int to_bitField0_ = 0;
        int to_bitField1_ = 0;
        if (((from_bitField0_ & 0x00000001) == 0x00000001)) {
          to_bitField0_ |= 0x00000001;
        }
        result.command_ = command_;
        if (((from_bitField0_ & 0x00000002) == 0x00000002)) {
          to_bitField0_ |= 0x00000002;
        }
        result.commandNum_ = commandNum_;
        if (((from_bitField0_ & 0x00000004) == 0x00000004)) {
          to_bitField0_ |= 0x00000004;
        }
        result.motorOffset_ = motorOffset_;
        if (((from_bitField0_ & 0x00000008) == 0x00000008)) {
          to_bitField0_ |= 0x00000008;
        }
        result.maxLimit_ = maxLimit_;
        if (((from_bitField0_ & 0x00000010) == 0x00000010)) {
          to_bitField0_ |= 0x00000010;
        }
        result.minLimit_ = minLimit_;
        if (((from_bitField0_ & 0x00000020) == 0x00000020)) {
          to_bitField0_ |= 0x00000020;
        }
        if (posBuilder_ == null) {
          result.pos_ = pos_;
        } else {
          result.pos_ = posBuilder_.build();
        }
        if (((from_bitField0_ & 0x00000040) == 0x00000040)) {
          to_bitField0_ |= 0x00000040;
        }
        if (centerBuilder_ == null) {
          result.center_ = center_;
        } else {
          result.center_ = centerBuilder_.build();
        }
        if (((from_bitField0_ & 0x00000080) == 0x00000080)) {
          to_bitField0_ |= 0x00000080;
        }
        if (normalBuilder_ == null) {
          result.normal_ = normal_;
        } else {
          result.normal_ = normalBuilder_.build();
        }
        if (((from_bitField0_ & 0x00000100) == 0x00000100)) {
          to_bitField0_ |= 0x00000100;
        }
        result.turn_ = turn_;
        if (((from_bitField0_ & 0x00000200) == 0x00000200)) {
          to_bitField0_ |= 0x00000200;
        }
        result.vel_ = vel_;
        if (((from_bitField0_ & 0x00000400) == 0x00000400)) {
          to_bitField0_ |= 0x00000400;
        }
        result.iniMaxvel_ = iniMaxvel_;
        if (((from_bitField0_ & 0x00000800) == 0x00000800)) {
          to_bitField0_ |= 0x00000800;
        }
        result.motionType_ = motionType_;
        if (((from_bitField0_ & 0x00001000) == 0x00001000)) {
          to_bitField0_ |= 0x00001000;
        }
        result.spindlesync_ = spindlesync_;
        if (((from_bitField0_ & 0x00002000) == 0x00002000)) {
          to_bitField0_ |= 0x00002000;
        }
        result.acc_ = acc_;
        if (((from_bitField0_ & 0x00004000) == 0x00004000)) {
          to_bitField0_ |= 0x00004000;
        }
        result.backlash_ = backlash_;
        if (((from_bitField0_ & 0x00008000) == 0x00008000)) {
          to_bitField0_ |= 0x00008000;
        }
        result.id_ = id_;
        if (((from_bitField0_ & 0x00010000) == 0x00010000)) {
          to_bitField0_ |= 0x00010000;
        }
        result.termCond_ = termCond_;
        if (((from_bitField0_ & 0x00020000) == 0x00020000)) {
          to_bitField0_ |= 0x00020000;
        }
        result.tolerance_ = tolerance_;
        if (((from_bitField0_ & 0x00040000) == 0x00040000)) {
          to_bitField0_ |= 0x00040000;
        }
        result.axis_ = axis_;
        if (((from_bitField0_ & 0x00080000) == 0x00080000)) {
          to_bitField0_ |= 0x00080000;
        }
        result.scale_ = scale_;
        if (((from_bitField0_ & 0x00100000) == 0x00100000)) {
          to_bitField0_ |= 0x00100000;
        }
        result.offset_ = offset_;
        if (((from_bitField0_ & 0x00200000) == 0x00200000)) {
          to_bitField0_ |= 0x00200000;
        }
        result.home_ = home_;
        if (((from_bitField0_ & 0x00400000) == 0x00400000)) {
          to_bitField0_ |= 0x00400000;
        }
        result.homeFinalVel_ = homeFinalVel_;
        if (((from_bitField0_ & 0x00800000) == 0x00800000)) {
          to_bitField0_ |= 0x00800000;
        }
        result.searchVel_ = searchVel_;
        if (((from_bitField0_ & 0x01000000) == 0x01000000)) {
          to_bitField0_ |= 0x01000000;
        }
        result.latchVel_ = latchVel_;
        if (((from_bitField0_ & 0x02000000) == 0x02000000)) {
          to_bitField0_ |= 0x02000000;
        }
        result.flags_ = flags_;
        if (((from_bitField0_ & 0x04000000) == 0x04000000)) {
          to_bitField0_ |= 0x04000000;
        }
        result.homeSequence_ = homeSequence_;
        if (((from_bitField0_ & 0x08000000) == 0x08000000)) {
          to_bitField0_ |= 0x08000000;
        }
        result.volatileHome_ = volatileHome_;
        if (((from_bitField0_ & 0x10000000) == 0x10000000)) {
          to_bitField0_ |= 0x10000000;
        }
        result.minFerror_ = minFerror_;
        if (((from_bitField0_ & 0x20000000) == 0x20000000)) {
          to_bitField0_ |= 0x20000000;
        }
        result.maxFerror_ = maxFerror_;
        if (((from_bitField0_ & 0x40000000) == 0x40000000)) {
          to_bitField0_ |= 0x40000000;
        }
        result.wdWait_ = wdWait_;
        if (((from_bitField0_ & 0x80000000) == 0x80000000)) {
          to_bitField0_ |= 0x80000000;
        }
        result.debug_ = debug_;
        if (((from_bitField1_ & 0x00000001) == 0x00000001)) {
          to_bitField1_ |= 0x00000001;
        }
        result.now_ = now_;
        if (((from_bitField1_ & 0x00000002) == 0x00000002)) {
          to_bitField1_ |= 0x00000002;
        }
        result.out_ = out_;
        if (((from_bitField1_ & 0x00000004) == 0x00000004)) {
          to_bitField1_ |= 0x00000004;
        }
        result.start_ = start_;
        if (((from_bitField1_ & 0x00000008) == 0x00000008)) {
          to_bitField1_ |= 0x00000008;
        }
        result.end_ = end_;
        if (((from_bitField1_ & 0x00000010) == 0x00000010)) {
          to_bitField1_ |= 0x00000010;
        }
        result.mode_ = mode_;
        if (((from_bitField1_ & 0x00000020) == 0x00000020)) {
          to_bitField1_ |= 0x00000020;
        }
        result.compNominal_ = compNominal_;
        if (((from_bitField1_ & 0x00000040) == 0x00000040)) {
          to_bitField1_ |= 0x00000040;
        }
        result.compForward_ = compForward_;
        if (((from_bitField1_ & 0x00000080) == 0x00000080)) {
          to_bitField1_ |= 0x00000080;
        }
        result.compReverse_ = compReverse_;
        if (((from_bitField1_ & 0x00000100) == 0x00000100)) {
          to_bitField1_ |= 0x00000100;
        }
        result.probeType_ = probeType_;
        if (((from_bitField1_ & 0x00000200) == 0x00000200)) {
          to_bitField1_ |= 0x00000200;
        }
        if (toolOffsetBuilder_ == null) {
          result.toolOffset_ = toolOffset_;
        } else {
          result.toolOffset_ = toolOffsetBuilder_.build();
        }
        result.bitField0_ = to_bitField0_;
        result.bitField1_ = to_bitField1_;
        onBuilt();
        return result;
      }

      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof pb.Motcmds.MotionCommand) {
          return mergeFrom((pb.Motcmds.MotionCommand)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(pb.Motcmds.MotionCommand other) {
        if (other == pb.Motcmds.MotionCommand.getDefaultInstance()) return this;
        if (other.hasCommand()) {
          setCommand(other.getCommand());
        }
        if (other.hasCommandNum()) {
          setCommandNum(other.getCommandNum());
        }
        if (other.hasMotorOffset()) {
          setMotorOffset(other.getMotorOffset());
        }
        if (other.hasMaxLimit()) {
          setMaxLimit(other.getMaxLimit());
        }
        if (other.hasMinLimit()) {
          setMinLimit(other.getMinLimit());
        }
        if (other.hasPos()) {
          mergePos(other.getPos());
        }
        if (other.hasCenter()) {
          mergeCenter(other.getCenter());
        }
        if (other.hasNormal()) {
          mergeNormal(other.getNormal());
        }
        if (other.hasTurn()) {
          setTurn(other.getTurn());
        }
        if (other.hasVel()) {
          setVel(other.getVel());
        }
        if (other.hasIniMaxvel()) {
          setIniMaxvel(other.getIniMaxvel());
        }
        if (other.hasMotionType()) {
          setMotionType(other.getMotionType());
        }
        if (other.hasSpindlesync()) {
          setSpindlesync(other.getSpindlesync());
        }
        if (other.hasAcc()) {
          setAcc(other.getAcc());
        }
        if (other.hasBacklash()) {
          setBacklash(other.getBacklash());
        }
        if (other.hasId()) {
          setId(other.getId());
        }
        if (other.hasTermCond()) {
          setTermCond(other.getTermCond());
        }
        if (other.hasTolerance()) {
          setTolerance(other.getTolerance());
        }
        if (other.hasAxis()) {
          setAxis(other.getAxis());
        }
        if (other.hasScale()) {
          setScale(other.getScale());
        }
        if (other.hasOffset()) {
          setOffset(other.getOffset());
        }
        if (other.hasHome()) {
          setHome(other.getHome());
        }
        if (other.hasHomeFinalVel()) {
          setHomeFinalVel(other.getHomeFinalVel());
        }
        if (other.hasSearchVel()) {
          setSearchVel(other.getSearchVel());
        }
        if (other.hasLatchVel()) {
          setLatchVel(other.getLatchVel());
        }
        if (other.hasFlags()) {
          setFlags(other.getFlags());
        }
        if (other.hasHomeSequence()) {
          setHomeSequence(other.getHomeSequence());
        }
        if (other.hasVolatileHome()) {
          setVolatileHome(other.getVolatileHome());
        }
        if (other.hasMinFerror()) {
          setMinFerror(other.getMinFerror());
        }
        if (other.hasMaxFerror()) {
          setMaxFerror(other.getMaxFerror());
        }
        if (other.hasWdWait()) {
          setWdWait(other.getWdWait());
        }
        if (other.hasDebug()) {
          setDebug(other.getDebug());
        }
        if (other.hasNow()) {
          setNow(other.getNow());
        }
        if (other.hasOut()) {
          setOut(other.getOut());
        }
        if (other.hasStart()) {
          setStart(other.getStart());
        }
        if (other.hasEnd()) {
          setEnd(other.getEnd());
        }
        if (other.hasMode()) {
          setMode(other.getMode());
        }
        if (other.hasCompNominal()) {
          setCompNominal(other.getCompNominal());
        }
        if (other.hasCompForward()) {
          setCompForward(other.getCompForward());
        }
        if (other.hasCompReverse()) {
          setCompReverse(other.getCompReverse());
        }
        if (other.hasProbeType()) {
          setProbeType(other.getProbeType());
        }
        if (other.hasToolOffset()) {
          mergeToolOffset(other.getToolOffset());
        }
        this.mergeUnknownFields(other.getUnknownFields());
        return this;
      }

      public final boolean isInitialized() {
        if (!hasCommand()) {
          
          return false;
        }
        if (!hasCommandNum()) {
          
          return false;
        }
        if (hasPos()) {
          if (!getPos().isInitialized()) {
            
            return false;
          }
        }
        if (hasToolOffset()) {
          if (!getToolOffset().isInitialized()) {
            
            return false;
          }
        }
        return true;
      }

      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        pb.Motcmds.MotionCommand parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (pb.Motcmds.MotionCommand) e.getUnfinishedMessage();
          throw e;
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }
      private int bitField0_;
      private int bitField1_;

      private pb.Motcmds.cmd_code_t command_ = pb.Motcmds.cmd_code_t.EMCMOT_ABORT;
      /**
       * <code>required .pb.cmd_code_t command = 10;</code>
       */
      public boolean hasCommand() {
        return ((bitField0_ & 0x00000001) == 0x00000001);
      }
      /**
       * <code>required .pb.cmd_code_t command = 10;</code>
       */
      public pb.Motcmds.cmd_code_t getCommand() {
        return command_;
      }
      /**
       * <code>required .pb.cmd_code_t command = 10;</code>
       */
      public Builder setCommand(pb.Motcmds.cmd_code_t value) {
        if (value == null) {
          throw new NullPointerException();
        }
        bitField0_ |= 0x00000001;
        command_ = value;
        onChanged();
        return this;
      }
      /**
       * <code>required .pb.cmd_code_t command = 10;</code>
       */
      public Builder clearCommand() {
        bitField0_ = (bitField0_ & ~0x00000001);
        command_ = pb.Motcmds.cmd_code_t.EMCMOT_ABORT;
        onChanged();
        return this;
      }

      private int commandNum_ ;
      /**
       * <code>required fixed32 commandNum = 20;</code>
       *
       * <pre>
       * increment this for new command 
       * </pre>
       */
      public boolean hasCommandNum() {
        return ((bitField0_ & 0x00000002) == 0x00000002);
      }
      /**
       * <code>required fixed32 commandNum = 20;</code>
       *
       * <pre>
       * increment this for new command 
       * </pre>
       */
      public int getCommandNum() {
        return commandNum_;
      }
      /**
       * <code>required fixed32 commandNum = 20;</code>
       *
       * <pre>
       * increment this for new command 
       * </pre>
       */
      public Builder setCommandNum(int value) {
        bitField0_ |= 0x00000002;
        commandNum_ = value;
        onChanged();
        return this;
      }
      /**
       * <code>required fixed32 commandNum = 20;</code>
       *
       * <pre>
       * increment this for new command 
       * </pre>
       */
      public Builder clearCommandNum() {
        bitField0_ = (bitField0_ & ~0x00000002);
        commandNum_ = 0;
        onChanged();
        return this;
      }

      private double motorOffset_ ;
      /**
       * <code>optional double motor_offset = 30;</code>
       *
       * <pre>
       * offset from joint to motor position 
       * </pre>
       */
      public boolean hasMotorOffset() {
        return ((bitField0_ & 0x00000004) == 0x00000004);
      }
      /**
       * <code>optional double motor_offset = 30;</code>
       *
       * <pre>
       * offset from joint to motor position 
       * </pre>
       */
      public double getMotorOffset() {
        return motorOffset_;
      }
      /**
       * <code>optional double motor_offset = 30;</code>
       *
       * <pre>
       * offset from joint to motor position 
       * </pre>
       */
      public Builder setMotorOffset(double value) {
        bitField0_ |= 0x00000004;
        motorOffset_ = value;
        onChanged();
        return this;
      }
      /**
       * <code>optional double motor_offset = 30;</code>
       *
       * <pre>
       * offset from joint to motor position 
       * </pre>
       */
      public Builder clearMotorOffset() {
        bitField0_ = (bitField0_ & ~0x00000004);
        motorOffset_ = 0D;
        onChanged();
        return this;
      }

      private double maxLimit_ ;
      /**
       * <code>optional double maxLimit = 40;</code>
       *
       * <pre>
       * pos value for position limit, output 
       * </pre>
       */
      public boolean hasMaxLimit() {
        return ((bitField0_ & 0x00000008) == 0x00000008);
      }
      /**
       * <code>optional double maxLimit = 40;</code>
       *
       * <pre>
       * pos value for position limit, output 
       * </pre>
       */
      public double getMaxLimit() {
        return maxLimit_;
      }
      /**
       * <code>optional double maxLimit = 40;</code>
       *
       * <pre>
       * pos value for position limit, output 
       * </pre>
       */
      public Builder setMaxLimit(double value) {
        bitField0_ |= 0x00000008;
        maxLimit_ = value;
        onChanged();
        return this;
      }
      /**
       * <code>optional double maxLimit = 40;</code>
       *
       * <pre>
       * pos value for position limit, output 
       * </pre>
       */
      public Builder clearMaxLimit() {
        bitField0_ = (bitField0_ & ~0x00000008);
        maxLimit_ = 0D;
        onChanged();
        return this;
      }

      private double minLimit_ ;
      /**
       * <code>optional double minLimit = 50;</code>
       *
       * <pre>
       * neg value for position limit, output 
       * </pre>
       */
      public boolean hasMinLimit() {
        return ((bitField0_ & 0x00000010) == 0x00000010);
      }
      /**
       * <code>optional double minLimit = 50;</code>
       *
       * <pre>
       * neg value for position limit, output 
       * </pre>
       */
      public double getMinLimit() {
        return minLimit_;
      }
      /**
       * <code>optional double minLimit = 50;</code>
       *
       * <pre>
       * neg value for position limit, output 
       * </pre>
       */
      public Builder setMinLimit(double value) {
        bitField0_ |= 0x00000010;
        minLimit_ = value;
        onChanged();
        return this;
      }
      /**
       * <code>optional double minLimit = 50;</code>
       *
       * <pre>
       * neg value for position limit, output 
       * </pre>
       */
      public Builder clearMinLimit() {
        bitField0_ = (bitField0_ & ~0x00000010);
        minLimit_ = 0D;
        onChanged();
        return this;
      }

      private pb.Emcclass.EmcPose pos_ = pb.Emcclass.EmcPose.getDefaultInstance();
      private com.google.protobuf.SingleFieldBuilder<
          pb.Emcclass.EmcPose, pb.Emcclass.EmcPose.Builder, pb.Emcclass.EmcPoseOrBuilder> posBuilder_;
      /**
       * <code>optional .pb.EmcPose pos = 60;</code>
       *
       * <pre>
       * line/circle endpt, or teleop vector 
       * </pre>
       */
      public boolean hasPos() {
        return ((bitField0_ & 0x00000020) == 0x00000020);
      }
      /**
       * <code>optional .pb.EmcPose pos = 60;</code>
       *
       * <pre>
       * line/circle endpt, or teleop vector 
       * </pre>
       */
      public pb.Emcclass.EmcPose getPos() {
        if (posBuilder_ == null) {
          return pos_;
        } else {
          return posBuilder_.getMessage();
        }
      }
      /**
       * <code>optional .pb.EmcPose pos = 60;</code>
       *
       * <pre>
       * line/circle endpt, or teleop vector 
       * </pre>
       */
      public Builder setPos(pb.Emcclass.EmcPose value) {
        if (posBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          pos_ = value;
          onChanged();
        } else {
          posBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000020;
        return this;
      }
      /**
       * <code>optional .pb.EmcPose pos = 60;</code>
       *
       * <pre>
       * line/circle endpt, or teleop vector 
       * </pre>
       */
      public Builder setPos(
          pb.Emcclass.EmcPose.Builder builderForValue) {
        if (posBuilder_ == null) {
          pos_ = builderForValue.build();
          onChanged();
        } else {
          posBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000020;
        return this;
      }
      /**
       * <code>optional .pb.EmcPose pos = 60;</code>
       *
       * <pre>
       * line/circle endpt, or teleop vector 
       * </pre>
       */
      public Builder mergePos(pb.Emcclass.EmcPose value) {
        if (posBuilder_ == null) {
          if (((bitField0_ & 0x00000020) == 0x00000020) &&
              pos_ != pb.Emcclass.EmcPose.getDefaultInstance()) {
            pos_ =
              pb.Emcclass.EmcPose.newBuilder(pos_).mergeFrom(value).buildPartial();
          } else {
            pos_ = value;
          }
          onChanged();
        } else {
          posBuilder_.mergeFrom(value);
        }
        bitField0_ |= 0x00000020;
        return this;
      }
      /**
       * <code>optional .pb.EmcPose pos = 60;</code>
       *
       * <pre>
       * line/circle endpt, or teleop vector 
       * </pre>
       */
      public Builder clearPos() {
        if (posBuilder_ == null) {
          pos_ = pb.Emcclass.EmcPose.getDefaultInstance();
          onChanged();
        } else {
          posBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000020);
        return this;
      }
      /**
       * <code>optional .pb.EmcPose pos = 60;</code>
       *
       * <pre>
       * line/circle endpt, or teleop vector 
       * </pre>
       */
      public pb.Emcclass.EmcPose.Builder getPosBuilder() {
        bitField0_ |= 0x00000020;
        onChanged();
        return getPosFieldBuilder().getBuilder();
      }
      /**
       * <code>optional .pb.EmcPose pos = 60;</code>
       *
       * <pre>
       * line/circle endpt, or teleop vector 
       * </pre>
       */
      public pb.Emcclass.EmcPoseOrBuilder getPosOrBuilder() {
        if (posBuilder_ != null) {
          return posBuilder_.getMessageOrBuilder();
        } else {
          return pos_;
        }
      }
      /**
       * <code>optional .pb.EmcPose pos = 60;</code>
       *
       * <pre>
       * line/circle endpt, or teleop vector 
       * </pre>
       */
      private com.google.protobuf.SingleFieldBuilder<
          pb.Emcclass.EmcPose, pb.Emcclass.EmcPose.Builder, pb.Emcclass.EmcPoseOrBuilder> 
          getPosFieldBuilder() {
        if (posBuilder_ == null) {
          posBuilder_ = new com.google.protobuf.SingleFieldBuilder<
              pb.Emcclass.EmcPose, pb.Emcclass.EmcPose.Builder, pb.Emcclass.EmcPoseOrBuilder>(
                  getPos(),
                  getParentForChildren(),
                  isClean());
          pos_ = null;
        }
        return posBuilder_;
      }

      private pb.Emcclass.PmCartesian center_ = pb.Emcclass.PmCartesian.getDefaultInstance();
      private com.google.protobuf.SingleFieldBuilder<
          pb.Emcclass.PmCartesian, pb.Emcclass.PmCartesian.Builder, pb.Emcclass.PmCartesianOrBuilder> centerBuilder_;
      /**
       * <code>optional .pb.PmCartesian center = 70;</code>
       *
       * <pre>
       * center for circle 
       * </pre>
       */
      public boolean hasCenter() {
        return ((bitField0_ & 0x00000040) == 0x00000040);
      }
      /**
       * <code>optional .pb.PmCartesian center = 70;</code>
       *
       * <pre>
       * center for circle 
       * </pre>
       */
      public pb.Emcclass.PmCartesian getCenter() {
        if (centerBuilder_ == null) {
          return center_;
        } else {
          return centerBuilder_.getMessage();
        }
      }
      /**
       * <code>optional .pb.PmCartesian center = 70;</code>
       *
       * <pre>
       * center for circle 
       * </pre>
       */
      public Builder setCenter(pb.Emcclass.PmCartesian value) {
        if (centerBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          center_ = value;
          onChanged();
        } else {
          centerBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000040;
        return this;
      }
      /**
       * <code>optional .pb.PmCartesian center = 70;</code>
       *
       * <pre>
       * center for circle 
       * </pre>
       */
      public Builder setCenter(
          pb.Emcclass.PmCartesian.Builder builderForValue) {
        if (centerBuilder_ == null) {
          center_ = builderForValue.build();
          onChanged();
        } else {
          centerBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000040;
        return this;
      }
      /**
       * <code>optional .pb.PmCartesian center = 70;</code>
       *
       * <pre>
       * center for circle 
       * </pre>
       */
      public Builder mergeCenter(pb.Emcclass.PmCartesian value) {
        if (centerBuilder_ == null) {
          if (((bitField0_ & 0x00000040) == 0x00000040) &&
              center_ != pb.Emcclass.PmCartesian.getDefaultInstance()) {
            center_ =
              pb.Emcclass.PmCartesian.newBuilder(center_).mergeFrom(value).buildPartial();
          } else {
            center_ = value;
          }
          onChanged();
        } else {
          centerBuilder_.mergeFrom(value);
        }
        bitField0_ |= 0x00000040;
        return this;
      }
      /**
       * <code>optional .pb.PmCartesian center = 70;</code>
       *
       * <pre>
       * center for circle 
       * </pre>
       */
      public Builder clearCenter() {
        if (centerBuilder_ == null) {
          center_ = pb.Emcclass.PmCartesian.getDefaultInstance();
          onChanged();
        } else {
          centerBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000040);
        return this;
      }
      /**
       * <code>optional .pb.PmCartesian center = 70;</code>
       *
       * <pre>
       * center for circle 
       * </pre>
       */
      public pb.Emcclass.PmCartesian.Builder getCenterBuilder() {
        bitField0_ |= 0x00000040;
        onChanged();
        return getCenterFieldBuilder().getBuilder();
      }
      /**
       * <code>optional .pb.PmCartesian center = 70;</code>
       *
       * <pre>
       * center for circle 
       * </pre>
       */
      public pb.Emcclass.PmCartesianOrBuilder getCenterOrBuilder() {
        if (centerBuilder_ != null) {
          return centerBuilder_.getMessageOrBuilder();
        } else {
          return center_;
        }
      }
      /**
       * <code>optional .pb.PmCartesian center = 70;</code>
       *
       * <pre>
       * center for circle 
       * </pre>
       */
      private com.google.protobuf.SingleFieldBuilder<
          pb.Emcclass.PmCartesian, pb.Emcclass.PmCartesian.Builder, pb.Emcclass.PmCartesianOrBuilder> 
          getCenterFieldBuilder() {
        if (centerBuilder_ == null) {
          centerBuilder_ = new com.google.protobuf.SingleFieldBuilder<
              pb.Emcclass.PmCartesian, pb.Emcclass.PmCartesian.Builder, pb.Emcclass.PmCartesianOrBuilder>(
                  getCenter(),
                  getParentForChildren(),
                  isClean());
          center_ = null;
        }
        return centerBuilder_;
      }

      private pb.Emcclass.PmCartesian normal_ = pb.Emcclass.PmCartesian.getDefaultInstance();
      private com.google.protobuf.SingleFieldBuilder<
          pb.Emcclass.PmCartesian, pb.Emcclass.PmCartesian.Builder, pb.Emcclass.PmCartesianOrBuilder> normalBuilder_;
      /**
       * <code>optional .pb.PmCartesian normal = 80;</code>
       *
       * <pre>
       * normal vec for circle 
       * </pre>
       */
      public boolean hasNormal() {
        return ((bitField0_ & 0x00000080) == 0x00000080);
      }
      /**
       * <code>optional .pb.PmCartesian normal = 80;</code>
       *
       * <pre>
       * normal vec for circle 
       * </pre>
       */
      public pb.Emcclass.PmCartesian getNormal() {
        if (normalBuilder_ == null) {
          return normal_;
        } else {
          return normalBuilder_.getMessage();
        }
      }
      /**
       * <code>optional .pb.PmCartesian normal = 80;</code>
       *
       * <pre>
       * normal vec for circle 
       * </pre>
       */
      public Builder setNormal(pb.Emcclass.PmCartesian value) {
        if (normalBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          normal_ = value;
          onChanged();
        } else {
          normalBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000080;
        return this;
      }
      /**
       * <code>optional .pb.PmCartesian normal = 80;</code>
       *
       * <pre>
       * normal vec for circle 
       * </pre>
       */
      public Builder setNormal(
          pb.Emcclass.PmCartesian.Builder builderForValue) {
        if (normalBuilder_ == null) {
          normal_ = builderForValue.build();
          onChanged();
        } else {
          normalBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000080;
        return this;
      }
      /**
       * <code>optional .pb.PmCartesian normal = 80;</code>
       *
       * <pre>
       * normal vec for circle 
       * </pre>
       */
      public Builder mergeNormal(pb.Emcclass.PmCartesian value) {
        if (normalBuilder_ == null) {
          if (((bitField0_ & 0x00000080) == 0x00000080) &&
              normal_ != pb.Emcclass.PmCartesian.getDefaultInstance()) {
            normal_ =
              pb.Emcclass.PmCartesian.newBuilder(normal_).mergeFrom(value).buildPartial();
          } else {
            normal_ = value;
          }
          onChanged();
        } else {
          normalBuilder_.mergeFrom(value);
        }
        bitField0_ |= 0x00000080;
        return this;
      }
      /**
       * <code>optional .pb.PmCartesian normal = 80;</code>
       *
       * <pre>
       * normal vec for circle 
       * </pre>
       */
      public Builder clearNormal() {
        if (normalBuilder_ == null) {
          normal_ = pb.Emcclass.PmCartesian.getDefaultInstance();
          onChanged();
        } else {
          normalBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000080);
        return this;
      }
      /**
       * <code>optional .pb.PmCartesian normal = 80;</code>
       *
       * <pre>
       * normal vec for circle 
       * </pre>
       */
      public pb.Emcclass.PmCartesian.Builder getNormalBuilder() {
        bitField0_ |= 0x00000080;
        onChanged();
        return getNormalFieldBuilder().getBuilder();
      }
      /**
       * <code>optional .pb.PmCartesian normal = 80;</code>
       *
       * <pre>
       * normal vec for circle 
       * </pre>
       */
      public pb.Emcclass.PmCartesianOrBuilder getNormalOrBuilder() {
        if (normalBuilder_ != null) {
          return normalBuilder_.getMessageOrBuilder();
        } else {
          return normal_;
        }
      }
      /**
       * <code>optional .pb.PmCartesian normal = 80;</code>
       *
       * <pre>
       * normal vec for circle 
       * </pre>
       */
      private com.google.protobuf.SingleFieldBuilder<
          pb.Emcclass.PmCartesian, pb.Emcclass.PmCartesian.Builder, pb.Emcclass.PmCartesianOrBuilder> 
          getNormalFieldBuilder() {
        if (normalBuilder_ == null) {
          normalBuilder_ = new com.google.protobuf.SingleFieldBuilder<
              pb.Emcclass.PmCartesian, pb.Emcclass.PmCartesian.Builder, pb.Emcclass.PmCartesianOrBuilder>(
                  getNormal(),
                  getParentForChildren(),
                  isClean());
          normal_ = null;
        }
        return normalBuilder_;
      }

      private int turn_ ;
      /**
       * <code>optional fixed32 turn = 90;</code>
       *
       * <pre>
       * turns for circle or which rotary to unlock for a line 
       * </pre>
       */
      public boolean hasTurn() {
        return ((bitField0_ & 0x00000100) == 0x00000100);
      }
      /**
       * <code>optional fixed32 turn = 90;</code>
       *
       * <pre>
       * turns for circle or which rotary to unlock for a line 
       * </pre>
       */
      public int getTurn() {
        return turn_;
      }
      /**
       * <code>optional fixed32 turn = 90;</code>
       *
       * <pre>
       * turns for circle or which rotary to unlock for a line 
       * </pre>
       */
      public Builder setTurn(int value) {
        bitField0_ |= 0x00000100;
        turn_ = value;
        onChanged();
        return this;
      }
      /**
       * <code>optional fixed32 turn = 90;</code>
       *
       * <pre>
       * turns for circle or which rotary to unlock for a line 
       * </pre>
       */
      public Builder clearTurn() {
        bitField0_ = (bitField0_ & ~0x00000100);
        turn_ = 0;
        onChanged();
        return this;
      }

      private double vel_ ;
      /**
       * <code>optional double vel = 100;</code>
       *
       * <pre>
       * max velocity 
       * </pre>
       */
      public boolean hasVel() {
        return ((bitField0_ & 0x00000200) == 0x00000200);
      }
      /**
       * <code>optional double vel = 100;</code>
       *
       * <pre>
       * max velocity 
       * </pre>
       */
      public double getVel() {
        return vel_;
      }
      /**
       * <code>optional double vel = 100;</code>
       *
       * <pre>
       * max velocity 
       * </pre>
       */
      public Builder setVel(double value) {
        bitField0_ |= 0x00000200;
        vel_ = value;
        onChanged();
        return this;
      }
      /**
       * <code>optional double vel = 100;</code>
       *
       * <pre>
       * max velocity 
       * </pre>
       */
      public Builder clearVel() {
        bitField0_ = (bitField0_ & ~0x00000200);
        vel_ = 0D;
        onChanged();
        return this;
      }

      private double iniMaxvel_ ;
      /**
       * <code>optional double ini_maxvel = 110;</code>
       *
       * <pre>
       * max velocity allowed by machine
       * </pre>
       */
      public boolean hasIniMaxvel() {
        return ((bitField0_ & 0x00000400) == 0x00000400);
      }
      /**
       * <code>optional double ini_maxvel = 110;</code>
       *
       * <pre>
       * max velocity allowed by machine
       * </pre>
       */
      public double getIniMaxvel() {
        return iniMaxvel_;
      }
      /**
       * <code>optional double ini_maxvel = 110;</code>
       *
       * <pre>
       * max velocity allowed by machine
       * </pre>
       */
      public Builder setIniMaxvel(double value) {
        bitField0_ |= 0x00000400;
        iniMaxvel_ = value;
        onChanged();
        return this;
      }
      /**
       * <code>optional double ini_maxvel = 110;</code>
       *
       * <pre>
       * max velocity allowed by machine
       * </pre>
       */
      public Builder clearIniMaxvel() {
        bitField0_ = (bitField0_ & ~0x00000400);
        iniMaxvel_ = 0D;
        onChanged();
        return this;
      }

      private pb.Motcmds.MotionType motionType_ = pb.Motcmds.MotionType._EMC_MOTION_TYPE_NONE;
      /**
       * <code>optional .pb.MotionType motion_type = 120;</code>
       *
       * <pre>
       * optional constraints (the ini file)
       * </pre>
       */
      public boolean hasMotionType() {
        return ((bitField0_ & 0x00000800) == 0x00000800);
      }
      /**
       * <code>optional .pb.MotionType motion_type = 120;</code>
       *
       * <pre>
       * optional constraints (the ini file)
       * </pre>
       */
      public pb.Motcmds.MotionType getMotionType() {
        return motionType_;
      }
      /**
       * <code>optional .pb.MotionType motion_type = 120;</code>
       *
       * <pre>
       * optional constraints (the ini file)
       * </pre>
       */
      public Builder setMotionType(pb.Motcmds.MotionType value) {
        if (value == null) {
          throw new NullPointerException();
        }
        bitField0_ |= 0x00000800;
        motionType_ = value;
        onChanged();
        return this;
      }
      /**
       * <code>optional .pb.MotionType motion_type = 120;</code>
       *
       * <pre>
       * optional constraints (the ini file)
       * </pre>
       */
      public Builder clearMotionType() {
        bitField0_ = (bitField0_ & ~0x00000800);
        motionType_ = pb.Motcmds.MotionType._EMC_MOTION_TYPE_NONE;
        onChanged();
        return this;
      }

      private double spindlesync_ ;
      /**
       * <code>optional double spindlesync = 130;</code>
       *
       * <pre>
       * user units per spindle revolution, 0 = no sync 
       * </pre>
       */
      public boolean hasSpindlesync() {
        return ((bitField0_ & 0x00001000) == 0x00001000);
      }
      /**
       * <code>optional double spindlesync = 130;</code>
       *
       * <pre>
       * user units per spindle revolution, 0 = no sync 
       * </pre>
       */
      public double getSpindlesync() {
        return spindlesync_;
      }
      /**
       * <code>optional double spindlesync = 130;</code>
       *
       * <pre>
       * user units per spindle revolution, 0 = no sync 
       * </pre>
       */
      public Builder setSpindlesync(double value) {
        bitField0_ |= 0x00001000;
        spindlesync_ = value;
        onChanged();
        return this;
      }
      /**
       * <code>optional double spindlesync = 130;</code>
       *
       * <pre>
       * user units per spindle revolution, 0 = no sync 
       * </pre>
       */
      public Builder clearSpindlesync() {
        bitField0_ = (bitField0_ & ~0x00001000);
        spindlesync_ = 0D;
        onChanged();
        return this;
      }

      private double acc_ ;
      /**
       * <code>optional double acc = 140;</code>
       *
       * <pre>
       * max acceleration 
       * </pre>
       */
      public boolean hasAcc() {
        return ((bitField0_ & 0x00002000) == 0x00002000);
      }
      /**
       * <code>optional double acc = 140;</code>
       *
       * <pre>
       * max acceleration 
       * </pre>
       */
      public double getAcc() {
        return acc_;
      }
      /**
       * <code>optional double acc = 140;</code>
       *
       * <pre>
       * max acceleration 
       * </pre>
       */
      public Builder setAcc(double value) {
        bitField0_ |= 0x00002000;
        acc_ = value;
        onChanged();
        return this;
      }
      /**
       * <code>optional double acc = 140;</code>
       *
       * <pre>
       * max acceleration 
       * </pre>
       */
      public Builder clearAcc() {
        bitField0_ = (bitField0_ & ~0x00002000);
        acc_ = 0D;
        onChanged();
        return this;
      }

      private double backlash_ ;
      /**
       * <code>optional double backlash = 150;</code>
       *
       * <pre>
       * amount of backlash 
       * </pre>
       */
      public boolean hasBacklash() {
        return ((bitField0_ & 0x00004000) == 0x00004000);
      }
      /**
       * <code>optional double backlash = 150;</code>
       *
       * <pre>
       * amount of backlash 
       * </pre>
       */
      public double getBacklash() {
        return backlash_;
      }
      /**
       * <code>optional double backlash = 150;</code>
       *
       * <pre>
       * amount of backlash 
       * </pre>
       */
      public Builder setBacklash(double value) {
        bitField0_ |= 0x00004000;
        backlash_ = value;
        onChanged();
        return this;
      }
      /**
       * <code>optional double backlash = 150;</code>
       *
       * <pre>
       * amount of backlash 
       * </pre>
       */
      public Builder clearBacklash() {
        bitField0_ = (bitField0_ & ~0x00004000);
        backlash_ = 0D;
        onChanged();
        return this;
      }

      private int id_ ;
      /**
       * <code>optional fixed32 id = 160;</code>
       *
       * <pre>
       * id for motion 
       * </pre>
       */
      public boolean hasId() {
        return ((bitField0_ & 0x00008000) == 0x00008000);
      }
      /**
       * <code>optional fixed32 id = 160;</code>
       *
       * <pre>
       * id for motion 
       * </pre>
       */
      public int getId() {
        return id_;
      }
      /**
       * <code>optional fixed32 id = 160;</code>
       *
       * <pre>
       * id for motion 
       * </pre>
       */
      public Builder setId(int value) {
        bitField0_ |= 0x00008000;
        id_ = value;
        onChanged();
        return this;
      }
      /**
       * <code>optional fixed32 id = 160;</code>
       *
       * <pre>
       * id for motion 
       * </pre>
       */
      public Builder clearId() {
        bitField0_ = (bitField0_ & ~0x00008000);
        id_ = 0;
        onChanged();
        return this;
      }

      private int termCond_ ;
      /**
       * <code>optional fixed32 termCond = 170;</code>
       *
       * <pre>
       * termination condition 
       * </pre>
       */
      public boolean hasTermCond() {
        return ((bitField0_ & 0x00010000) == 0x00010000);
      }
      /**
       * <code>optional fixed32 termCond = 170;</code>
       *
       * <pre>
       * termination condition 
       * </pre>
       */
      public int getTermCond() {
        return termCond_;
      }
      /**
       * <code>optional fixed32 termCond = 170;</code>
       *
       * <pre>
       * termination condition 
       * </pre>
       */
      public Builder setTermCond(int value) {
        bitField0_ |= 0x00010000;
        termCond_ = value;
        onChanged();
        return this;
      }
      /**
       * <code>optional fixed32 termCond = 170;</code>
       *
       * <pre>
       * termination condition 
       * </pre>
       */
      public Builder clearTermCond() {
        bitField0_ = (bitField0_ & ~0x00010000);
        termCond_ = 0;
        onChanged();
        return this;
      }

      private double tolerance_ ;
      /**
       * <code>optional double tolerance = 180;</code>
       *
       * <pre>
       * tolerance for path deviation in CONTINUOUS mode 
       * </pre>
       */
      public boolean hasTolerance() {
        return ((bitField0_ & 0x00020000) == 0x00020000);
      }
      /**
       * <code>optional double tolerance = 180;</code>
       *
       * <pre>
       * tolerance for path deviation in CONTINUOUS mode 
       * </pre>
       */
      public double getTolerance() {
        return tolerance_;
      }
      /**
       * <code>optional double tolerance = 180;</code>
       *
       * <pre>
       * tolerance for path deviation in CONTINUOUS mode 
       * </pre>
       */
      public Builder setTolerance(double value) {
        bitField0_ |= 0x00020000;
        tolerance_ = value;
        onChanged();
        return this;
      }
      /**
       * <code>optional double tolerance = 180;</code>
       *
       * <pre>
       * tolerance for path deviation in CONTINUOUS mode 
       * </pre>
       */
      public Builder clearTolerance() {
        bitField0_ = (bitField0_ & ~0x00020000);
        tolerance_ = 0D;
        onChanged();
        return this;
      }

      private int axis_ ;
      /**
       * <code>optional fixed32 axis = 190;</code>
       */
      public boolean hasAxis() {
        return ((bitField0_ & 0x00040000) == 0x00040000);
      }
      /**
       * <code>optional fixed32 axis = 190;</code>
       */
      public int getAxis() {
        return axis_;
      }
      /**
       * <code>optional fixed32 axis = 190;</code>
       */
      public Builder setAxis(int value) {
        bitField0_ |= 0x00040000;
        axis_ = value;
        onChanged();
        return this;
      }
      /**
       * <code>optional fixed32 axis = 190;</code>
       */
      public Builder clearAxis() {
        bitField0_ = (bitField0_ & ~0x00040000);
        axis_ = 0;
        onChanged();
        return this;
      }

      private double scale_ ;
      /**
       * <code>optional double scale = 200;</code>
       *
       * <pre>
       * velocity scale or spindle_speed scale arg 
       * </pre>
       */
      public boolean hasScale() {
        return ((bitField0_ & 0x00080000) == 0x00080000);
      }
      /**
       * <code>optional double scale = 200;</code>
       *
       * <pre>
       * velocity scale or spindle_speed scale arg 
       * </pre>
       */
      public double getScale() {
        return scale_;
      }
      /**
       * <code>optional double scale = 200;</code>
       *
       * <pre>
       * velocity scale or spindle_speed scale arg 
       * </pre>
       */
      public Builder setScale(double value) {
        bitField0_ |= 0x00080000;
        scale_ = value;
        onChanged();
        return this;
      }
      /**
       * <code>optional double scale = 200;</code>
       *
       * <pre>
       * velocity scale or spindle_speed scale arg 
       * </pre>
       */
      public Builder clearScale() {
        bitField0_ = (bitField0_ & ~0x00080000);
        scale_ = 0D;
        onChanged();
        return this;
      }

      private double offset_ ;
      /**
       * <code>optional double offset = 210;</code>
       *
       * <pre>
       * input, output, or home offset arg 
       * </pre>
       */
      public boolean hasOffset() {
        return ((bitField0_ & 0x00100000) == 0x00100000);
      }
      /**
       * <code>optional double offset = 210;</code>
       *
       * <pre>
       * input, output, or home offset arg 
       * </pre>
       */
      public double getOffset() {
        return offset_;
      }
      /**
       * <code>optional double offset = 210;</code>
       *
       * <pre>
       * input, output, or home offset arg 
       * </pre>
       */
      public Builder setOffset(double value) {
        bitField0_ |= 0x00100000;
        offset_ = value;
        onChanged();
        return this;
      }
      /**
       * <code>optional double offset = 210;</code>
       *
       * <pre>
       * input, output, or home offset arg 
       * </pre>
       */
      public Builder clearOffset() {
        bitField0_ = (bitField0_ & ~0x00100000);
        offset_ = 0D;
        onChanged();
        return this;
      }

      private double home_ ;
      /**
       * <code>optional double home = 220;</code>
       *
       * <pre>
       * joint home position 
       * </pre>
       */
      public boolean hasHome() {
        return ((bitField0_ & 0x00200000) == 0x00200000);
      }
      /**
       * <code>optional double home = 220;</code>
       *
       * <pre>
       * joint home position 
       * </pre>
       */
      public double getHome() {
        return home_;
      }
      /**
       * <code>optional double home = 220;</code>
       *
       * <pre>
       * joint home position 
       * </pre>
       */
      public Builder setHome(double value) {
        bitField0_ |= 0x00200000;
        home_ = value;
        onChanged();
        return this;
      }
      /**
       * <code>optional double home = 220;</code>
       *
       * <pre>
       * joint home position 
       * </pre>
       */
      public Builder clearHome() {
        bitField0_ = (bitField0_ & ~0x00200000);
        home_ = 0D;
        onChanged();
        return this;
      }

      private double homeFinalVel_ ;
      /**
       * <code>optional double home_final_vel = 230;</code>
       *
       * <pre>
       * joint velocity for moving from OFFSET to HOME 
       * </pre>
       */
      public boolean hasHomeFinalVel() {
        return ((bitField0_ & 0x00400000) == 0x00400000);
      }
      /**
       * <code>optional double home_final_vel = 230;</code>
       *
       * <pre>
       * joint velocity for moving from OFFSET to HOME 
       * </pre>
       */
      public double getHomeFinalVel() {
        return homeFinalVel_;
      }
      /**
       * <code>optional double home_final_vel = 230;</code>
       *
       * <pre>
       * joint velocity for moving from OFFSET to HOME 
       * </pre>
       */
      public Builder setHomeFinalVel(double value) {
        bitField0_ |= 0x00400000;
        homeFinalVel_ = value;
        onChanged();
        return this;
      }
      /**
       * <code>optional double home_final_vel = 230;</code>
       *
       * <pre>
       * joint velocity for moving from OFFSET to HOME 
       * </pre>
       */
      public Builder clearHomeFinalVel() {
        bitField0_ = (bitField0_ & ~0x00400000);
        homeFinalVel_ = 0D;
        onChanged();
        return this;
      }

      private double searchVel_ ;
      /**
       * <code>optional double search_vel = 240;</code>
       *
       * <pre>
       * home search velocity 
       * </pre>
       */
      public boolean hasSearchVel() {
        return ((bitField0_ & 0x00800000) == 0x00800000);
      }
      /**
       * <code>optional double search_vel = 240;</code>
       *
       * <pre>
       * home search velocity 
       * </pre>
       */
      public double getSearchVel() {
        return searchVel_;
      }
      /**
       * <code>optional double search_vel = 240;</code>
       *
       * <pre>
       * home search velocity 
       * </pre>
       */
      public Builder setSearchVel(double value) {
        bitField0_ |= 0x00800000;
        searchVel_ = value;
        onChanged();
        return this;
      }
      /**
       * <code>optional double search_vel = 240;</code>
       *
       * <pre>
       * home search velocity 
       * </pre>
       */
      public Builder clearSearchVel() {
        bitField0_ = (bitField0_ & ~0x00800000);
        searchVel_ = 0D;
        onChanged();
        return this;
      }

      private double latchVel_ ;
      /**
       * <code>optional double latch_vel = 250;</code>
       *
       * <pre>
       * home latch velocity 
       * </pre>
       */
      public boolean hasLatchVel() {
        return ((bitField0_ & 0x01000000) == 0x01000000);
      }
      /**
       * <code>optional double latch_vel = 250;</code>
       *
       * <pre>
       * home latch velocity 
       * </pre>
       */
      public double getLatchVel() {
        return latchVel_;
      }
      /**
       * <code>optional double latch_vel = 250;</code>
       *
       * <pre>
       * home latch velocity 
       * </pre>
       */
      public Builder setLatchVel(double value) {
        bitField0_ |= 0x01000000;
        latchVel_ = value;
        onChanged();
        return this;
      }
      /**
       * <code>optional double latch_vel = 250;</code>
       *
       * <pre>
       * home latch velocity 
       * </pre>
       */
      public Builder clearLatchVel() {
        bitField0_ = (bitField0_ & ~0x01000000);
        latchVel_ = 0D;
        onChanged();
        return this;
      }

      private int flags_ ;
      /**
       * <code>optional fixed32 flags = 260;</code>
       *
       * <pre>
       * homing config flags, other boolean args 
       * </pre>
       */
      public boolean hasFlags() {
        return ((bitField0_ & 0x02000000) == 0x02000000);
      }
      /**
       * <code>optional fixed32 flags = 260;</code>
       *
       * <pre>
       * homing config flags, other boolean args 
       * </pre>
       */
      public int getFlags() {
        return flags_;
      }
      /**
       * <code>optional fixed32 flags = 260;</code>
       *
       * <pre>
       * homing config flags, other boolean args 
       * </pre>
       */
      public Builder setFlags(int value) {
        bitField0_ |= 0x02000000;
        flags_ = value;
        onChanged();
        return this;
      }
      /**
       * <code>optional fixed32 flags = 260;</code>
       *
       * <pre>
       * homing config flags, other boolean args 
       * </pre>
       */
      public Builder clearFlags() {
        bitField0_ = (bitField0_ & ~0x02000000);
        flags_ = 0;
        onChanged();
        return this;
      }

      private int homeSequence_ ;
      /**
       * <code>optional fixed32 home_sequence = 270;</code>
       *
       * <pre>
       * order in homing sequence 
       * </pre>
       */
      public boolean hasHomeSequence() {
        return ((bitField0_ & 0x04000000) == 0x04000000);
      }
      /**
       * <code>optional fixed32 home_sequence = 270;</code>
       *
       * <pre>
       * order in homing sequence 
       * </pre>
       */
      public int getHomeSequence() {
        return homeSequence_;
      }
      /**
       * <code>optional fixed32 home_sequence = 270;</code>
       *
       * <pre>
       * order in homing sequence 
       * </pre>
       */
      public Builder setHomeSequence(int value) {
        bitField0_ |= 0x04000000;
        homeSequence_ = value;
        onChanged();
        return this;
      }
      /**
       * <code>optional fixed32 home_sequence = 270;</code>
       *
       * <pre>
       * order in homing sequence 
       * </pre>
       */
      public Builder clearHomeSequence() {
        bitField0_ = (bitField0_ & ~0x04000000);
        homeSequence_ = 0;
        onChanged();
        return this;
      }

      private int volatileHome_ ;
      /**
       * <code>optional fixed32 volatile_home = 280;</code>
       *
       * <pre>
       * joint should get unhomed when we get unhome -2
       * </pre>
       */
      public boolean hasVolatileHome() {
        return ((bitField0_ & 0x08000000) == 0x08000000);
      }
      /**
       * <code>optional fixed32 volatile_home = 280;</code>
       *
       * <pre>
       * joint should get unhomed when we get unhome -2
       * </pre>
       */
      public int getVolatileHome() {
        return volatileHome_;
      }
      /**
       * <code>optional fixed32 volatile_home = 280;</code>
       *
       * <pre>
       * joint should get unhomed when we get unhome -2
       * </pre>
       */
      public Builder setVolatileHome(int value) {
        bitField0_ |= 0x08000000;
        volatileHome_ = value;
        onChanged();
        return this;
      }
      /**
       * <code>optional fixed32 volatile_home = 280;</code>
       *
       * <pre>
       * joint should get unhomed when we get unhome -2
       * </pre>
       */
      public Builder clearVolatileHome() {
        bitField0_ = (bitField0_ & ~0x08000000);
        volatileHome_ = 0;
        onChanged();
        return this;
      }

      private double minFerror_ ;
      /**
       * <code>optional double minFerror = 290;</code>
       *
       * <pre>
       * optional  (generated by task upon estop, etc)
       * </pre>
       */
      public boolean hasMinFerror() {
        return ((bitField0_ & 0x10000000) == 0x10000000);
      }
      /**
       * <code>optional double minFerror = 290;</code>
       *
       * <pre>
       * optional  (generated by task upon estop, etc)
       * </pre>
       */
      public double getMinFerror() {
        return minFerror_;
      }
      /**
       * <code>optional double minFerror = 290;</code>
       *
       * <pre>
       * optional  (generated by task upon estop, etc)
       * </pre>
       */
      public Builder setMinFerror(double value) {
        bitField0_ |= 0x10000000;
        minFerror_ = value;
        onChanged();
        return this;
      }
      /**
       * <code>optional double minFerror = 290;</code>
       *
       * <pre>
       * optional  (generated by task upon estop, etc)
       * </pre>
       */
      public Builder clearMinFerror() {
        bitField0_ = (bitField0_ & ~0x10000000);
        minFerror_ = 0D;
        onChanged();
        return this;
      }

      private double maxFerror_ ;
      /**
       * <code>optional double maxFerror = 300;</code>
       *
       * <pre>
       * max following error 
       * </pre>
       */
      public boolean hasMaxFerror() {
        return ((bitField0_ & 0x20000000) == 0x20000000);
      }
      /**
       * <code>optional double maxFerror = 300;</code>
       *
       * <pre>
       * max following error 
       * </pre>
       */
      public double getMaxFerror() {
        return maxFerror_;
      }
      /**
       * <code>optional double maxFerror = 300;</code>
       *
       * <pre>
       * max following error 
       * </pre>
       */
      public Builder setMaxFerror(double value) {
        bitField0_ |= 0x20000000;
        maxFerror_ = value;
        onChanged();
        return this;
      }
      /**
       * <code>optional double maxFerror = 300;</code>
       *
       * <pre>
       * max following error 
       * </pre>
       */
      public Builder clearMaxFerror() {
        bitField0_ = (bitField0_ & ~0x20000000);
        maxFerror_ = 0D;
        onChanged();
        return this;
      }

      private int wdWait_ ;
      /**
       * <code>optional fixed32 wdWait = 310;</code>
       *
       * <pre>
       * cycle to wait before toggling wd 
       * </pre>
       */
      public boolean hasWdWait() {
        return ((bitField0_ & 0x40000000) == 0x40000000);
      }
      /**
       * <code>optional fixed32 wdWait = 310;</code>
       *
       * <pre>
       * cycle to wait before toggling wd 
       * </pre>
       */
      public int getWdWait() {
        return wdWait_;
      }
      /**
       * <code>optional fixed32 wdWait = 310;</code>
       *
       * <pre>
       * cycle to wait before toggling wd 
       * </pre>
       */
      public Builder setWdWait(int value) {
        bitField0_ |= 0x40000000;
        wdWait_ = value;
        onChanged();
        return this;
      }
      /**
       * <code>optional fixed32 wdWait = 310;</code>
       *
       * <pre>
       * cycle to wait before toggling wd 
       * </pre>
       */
      public Builder clearWdWait() {
        bitField0_ = (bitField0_ & ~0x40000000);
        wdWait_ = 0;
        onChanged();
        return this;
      }

      private int debug_ ;
      /**
       * <code>optional fixed32 debug = 320;</code>
       *
       * <pre>
       * debug level, from DEBUG in .ini file 
       * </pre>
       */
      public boolean hasDebug() {
        return ((bitField0_ & 0x80000000) == 0x80000000);
      }
      /**
       * <code>optional fixed32 debug = 320;</code>
       *
       * <pre>
       * debug level, from DEBUG in .ini file 
       * </pre>
       */
      public int getDebug() {
        return debug_;
      }
      /**
       * <code>optional fixed32 debug = 320;</code>
       *
       * <pre>
       * debug level, from DEBUG in .ini file 
       * </pre>
       */
      public Builder setDebug(int value) {
        bitField0_ |= 0x80000000;
        debug_ = value;
        onChanged();
        return this;
      }
      /**
       * <code>optional fixed32 debug = 320;</code>
       *
       * <pre>
       * debug level, from DEBUG in .ini file 
       * </pre>
       */
      public Builder clearDebug() {
        bitField0_ = (bitField0_ & ~0x80000000);
        debug_ = 0;
        onChanged();
        return this;
      }

      private int now_ ;
      /**
       * <code>optional int32 now = 330;</code>
       */
      public boolean hasNow() {
        return ((bitField1_ & 0x00000001) == 0x00000001);
      }
      /**
       * <code>optional int32 now = 330;</code>
       */
      public int getNow() {
        return now_;
      }
      /**
       * <code>optional int32 now = 330;</code>
       */
      public Builder setNow(int value) {
        bitField1_ |= 0x00000001;
        now_ = value;
        onChanged();
        return this;
      }
      /**
       * <code>optional int32 now = 330;</code>
       */
      public Builder clearNow() {
        bitField1_ = (bitField1_ & ~0x00000001);
        now_ = 0;
        onChanged();
        return this;
      }

      private int out_ ;
      /**
       * <code>optional int32 out = 340;</code>
       */
      public boolean hasOut() {
        return ((bitField1_ & 0x00000002) == 0x00000002);
      }
      /**
       * <code>optional int32 out = 340;</code>
       */
      public int getOut() {
        return out_;
      }
      /**
       * <code>optional int32 out = 340;</code>
       */
      public Builder setOut(int value) {
        bitField1_ |= 0x00000002;
        out_ = value;
        onChanged();
        return this;
      }
      /**
       * <code>optional int32 out = 340;</code>
       */
      public Builder clearOut() {
        bitField1_ = (bitField1_ & ~0x00000002);
        out_ = 0;
        onChanged();
        return this;
      }

      private int start_ ;
      /**
       * <code>optional int32 start = 350;</code>
       */
      public boolean hasStart() {
        return ((bitField1_ & 0x00000004) == 0x00000004);
      }
      /**
       * <code>optional int32 start = 350;</code>
       */
      public int getStart() {
        return start_;
      }
      /**
       * <code>optional int32 start = 350;</code>
       */
      public Builder setStart(int value) {
        bitField1_ |= 0x00000004;
        start_ = value;
        onChanged();
        return this;
      }
      /**
       * <code>optional int32 start = 350;</code>
       */
      public Builder clearStart() {
        bitField1_ = (bitField1_ & ~0x00000004);
        start_ = 0;
        onChanged();
        return this;
      }

      private int end_ ;
      /**
       * <code>optional int32 end = 360;</code>
       *
       * <pre>
       * these are related to synched AOUT/DOUT
       * </pre>
       */
      public boolean hasEnd() {
        return ((bitField1_ & 0x00000008) == 0x00000008);
      }
      /**
       * <code>optional int32 end = 360;</code>
       *
       * <pre>
       * these are related to synched AOUT/DOUT
       * </pre>
       */
      public int getEnd() {
        return end_;
      }
      /**
       * <code>optional int32 end = 360;</code>
       *
       * <pre>
       * these are related to synched AOUT/DOUT
       * </pre>
       */
      public Builder setEnd(int value) {
        bitField1_ |= 0x00000008;
        end_ = value;
        onChanged();
        return this;
      }
      /**
       * <code>optional int32 end = 360;</code>
       *
       * <pre>
       * these are related to synched AOUT/DOUT
       * </pre>
       */
      public Builder clearEnd() {
        bitField1_ = (bitField1_ & ~0x00000008);
        end_ = 0;
        onChanged();
        return this;
      }

      private int mode_ ;
      /**
       * <code>optional int32 mode = 370;</code>
       *
       * <pre>
       * now=wether now or synched, out = which gets set,
       * start=start value, end=end value
       * </pre>
       */
      public boolean hasMode() {
        return ((bitField1_ & 0x00000010) == 0x00000010);
      }
      /**
       * <code>optional int32 mode = 370;</code>
       *
       * <pre>
       * now=wether now or synched, out = which gets set,
       * start=start value, end=end value
       * </pre>
       */
      public int getMode() {
        return mode_;
      }
      /**
       * <code>optional int32 mode = 370;</code>
       *
       * <pre>
       * now=wether now or synched, out = which gets set,
       * start=start value, end=end value
       * </pre>
       */
      public Builder setMode(int value) {
        bitField1_ |= 0x00000010;
        mode_ = value;
        onChanged();
        return this;
      }
      /**
       * <code>optional int32 mode = 370;</code>
       *
       * <pre>
       * now=wether now or synched, out = which gets set,
       * start=start value, end=end value
       * </pre>
       */
      public Builder clearMode() {
        bitField1_ = (bitField1_ & ~0x00000010);
        mode_ = 0;
        onChanged();
        return this;
      }

      private double compNominal_ ;
      /**
       * <code>optional double comp_nominal = 380;</code>
       *
       * <pre>
       * compensation triplet, nominal, forward, reverse 
       * </pre>
       */
      public boolean hasCompNominal() {
        return ((bitField1_ & 0x00000020) == 0x00000020);
      }
      /**
       * <code>optional double comp_nominal = 380;</code>
       *
       * <pre>
       * compensation triplet, nominal, forward, reverse 
       * </pre>
       */
      public double getCompNominal() {
        return compNominal_;
      }
      /**
       * <code>optional double comp_nominal = 380;</code>
       *
       * <pre>
       * compensation triplet, nominal, forward, reverse 
       * </pre>
       */
      public Builder setCompNominal(double value) {
        bitField1_ |= 0x00000020;
        compNominal_ = value;
        onChanged();
        return this;
      }
      /**
       * <code>optional double comp_nominal = 380;</code>
       *
       * <pre>
       * compensation triplet, nominal, forward, reverse 
       * </pre>
       */
      public Builder clearCompNominal() {
        bitField1_ = (bitField1_ & ~0x00000020);
        compNominal_ = 0D;
        onChanged();
        return this;
      }

      private double compForward_ ;
      /**
       * <code>optional double comp_forward = 390;</code>
       *
       * <pre>
       * compensation triplet, nominal, forward, reverse 
       * </pre>
       */
      public boolean hasCompForward() {
        return ((bitField1_ & 0x00000040) == 0x00000040);
      }
      /**
       * <code>optional double comp_forward = 390;</code>
       *
       * <pre>
       * compensation triplet, nominal, forward, reverse 
       * </pre>
       */
      public double getCompForward() {
        return compForward_;
      }
      /**
       * <code>optional double comp_forward = 390;</code>
       *
       * <pre>
       * compensation triplet, nominal, forward, reverse 
       * </pre>
       */
      public Builder setCompForward(double value) {
        bitField1_ |= 0x00000040;
        compForward_ = value;
        onChanged();
        return this;
      }
      /**
       * <code>optional double comp_forward = 390;</code>
       *
       * <pre>
       * compensation triplet, nominal, forward, reverse 
       * </pre>
       */
      public Builder clearCompForward() {
        bitField1_ = (bitField1_ & ~0x00000040);
        compForward_ = 0D;
        onChanged();
        return this;
      }

      private double compReverse_ ;
      /**
       * <code>optional double comp_reverse = 400;</code>
       *
       * <pre>
       * compensation triplet, nominal, forward, reverse 
       * </pre>
       */
      public boolean hasCompReverse() {
        return ((bitField1_ & 0x00000080) == 0x00000080);
      }
      /**
       * <code>optional double comp_reverse = 400;</code>
       *
       * <pre>
       * compensation triplet, nominal, forward, reverse 
       * </pre>
       */
      public double getCompReverse() {
        return compReverse_;
      }
      /**
       * <code>optional double comp_reverse = 400;</code>
       *
       * <pre>
       * compensation triplet, nominal, forward, reverse 
       * </pre>
       */
      public Builder setCompReverse(double value) {
        bitField1_ |= 0x00000080;
        compReverse_ = value;
        onChanged();
        return this;
      }
      /**
       * <code>optional double comp_reverse = 400;</code>
       *
       * <pre>
       * compensation triplet, nominal, forward, reverse 
       * </pre>
       */
      public Builder clearCompReverse() {
        bitField1_ = (bitField1_ & ~0x00000080);
        compReverse_ = 0D;
        onChanged();
        return this;
      }

      private int probeType_ ;
      /**
       * <code>optional int32 probe_type = 410;</code>
       *
       * <pre>
       * ~1 = error if probe operation is unsuccessful (ngc default)
       *|1 = suppress error, report in # instead
       *~2 = move until probe trips (ngc default)
       *|2 = move until probe clears 
       * </pre>
       */
      public boolean hasProbeType() {
        return ((bitField1_ & 0x00000100) == 0x00000100);
      }
      /**
       * <code>optional int32 probe_type = 410;</code>
       *
       * <pre>
       * ~1 = error if probe operation is unsuccessful (ngc default)
       *|1 = suppress error, report in # instead
       *~2 = move until probe trips (ngc default)
       *|2 = move until probe clears 
       * </pre>
       */
      public int getProbeType() {
        return probeType_;
      }
      /**
       * <code>optional int32 probe_type = 410;</code>
       *
       * <pre>
       * ~1 = error if probe operation is unsuccessful (ngc default)
       *|1 = suppress error, report in # instead
       *~2 = move until probe trips (ngc default)
       *|2 = move until probe clears 
       * </pre>
       */
      public Builder setProbeType(int value) {
        bitField1_ |= 0x00000100;
        probeType_ = value;
        onChanged();
        return this;
      }
      /**
       * <code>optional int32 probe_type = 410;</code>
       *
       * <pre>
       * ~1 = error if probe operation is unsuccessful (ngc default)
       *|1 = suppress error, report in # instead
       *~2 = move until probe trips (ngc default)
       *|2 = move until probe clears 
       * </pre>
       */
      public Builder clearProbeType() {
        bitField1_ = (bitField1_ & ~0x00000100);
        probeType_ = 0;
        onChanged();
        return this;
      }

      private pb.Emcclass.EmcPose toolOffset_ = pb.Emcclass.EmcPose.getDefaultInstance();
      private com.google.protobuf.SingleFieldBuilder<
          pb.Emcclass.EmcPose, pb.Emcclass.EmcPose.Builder, pb.Emcclass.EmcPoseOrBuilder> toolOffsetBuilder_;
      /**
       * <code>optional .pb.EmcPose tool_offset = 420;</code>
       *
       * <pre>
       * TLO 
       * </pre>
       */
      public boolean hasToolOffset() {
        return ((bitField1_ & 0x00000200) == 0x00000200);
      }
      /**
       * <code>optional .pb.EmcPose tool_offset = 420;</code>
       *
       * <pre>
       * TLO 
       * </pre>
       */
      public pb.Emcclass.EmcPose getToolOffset() {
        if (toolOffsetBuilder_ == null) {
          return toolOffset_;
        } else {
          return toolOffsetBuilder_.getMessage();
        }
      }
      /**
       * <code>optional .pb.EmcPose tool_offset = 420;</code>
       *
       * <pre>
       * TLO 
       * </pre>
       */
      public Builder setToolOffset(pb.Emcclass.EmcPose value) {
        if (toolOffsetBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          toolOffset_ = value;
          onChanged();
        } else {
          toolOffsetBuilder_.setMessage(value);
        }
        bitField1_ |= 0x00000200;
        return this;
      }
      /**
       * <code>optional .pb.EmcPose tool_offset = 420;</code>
       *
       * <pre>
       * TLO 
       * </pre>
       */
      public Builder setToolOffset(
          pb.Emcclass.EmcPose.Builder builderForValue) {
        if (toolOffsetBuilder_ == null) {
          toolOffset_ = builderForValue.build();
          onChanged();
        } else {
          toolOffsetBuilder_.setMessage(builderForValue.build());
        }
        bitField1_ |= 0x00000200;
        return this;
      }
      /**
       * <code>optional .pb.EmcPose tool_offset = 420;</code>
       *
       * <pre>
       * TLO 
       * </pre>
       */
      public Builder mergeToolOffset(pb.Emcclass.EmcPose value) {
        if (toolOffsetBuilder_ == null) {
          if (((bitField1_ & 0x00000200) == 0x00000200) &&
              toolOffset_ != pb.Emcclass.EmcPose.getDefaultInstance()) {
            toolOffset_ =
              pb.Emcclass.EmcPose.newBuilder(toolOffset_).mergeFrom(value).buildPartial();
          } else {
            toolOffset_ = value;
          }
          onChanged();
        } else {
          toolOffsetBuilder_.mergeFrom(value);
        }
        bitField1_ |= 0x00000200;
        return this;
      }
      /**
       * <code>optional .pb.EmcPose tool_offset = 420;</code>
       *
       * <pre>
       * TLO 
       * </pre>
       */
      public Builder clearToolOffset() {
        if (toolOffsetBuilder_ == null) {
          toolOffset_ = pb.Emcclass.EmcPose.getDefaultInstance();
          onChanged();
        } else {
          toolOffsetBuilder_.clear();
        }
        bitField1_ = (bitField1_ & ~0x00000200);
        return this;
      }
      /**
       * <code>optional .pb.EmcPose tool_offset = 420;</code>
       *
       * <pre>
       * TLO 
       * </pre>
       */
      public pb.Emcclass.EmcPose.Builder getToolOffsetBuilder() {
        bitField1_ |= 0x00000200;
        onChanged();
        return getToolOffsetFieldBuilder().getBuilder();
      }
      /**
       * <code>optional .pb.EmcPose tool_offset = 420;</code>
       *
       * <pre>
       * TLO 
       * </pre>
       */
      public pb.Emcclass.EmcPoseOrBuilder getToolOffsetOrBuilder() {
        if (toolOffsetBuilder_ != null) {
          return toolOffsetBuilder_.getMessageOrBuilder();
        } else {
          return toolOffset_;
        }
      }
      /**
       * <code>optional .pb.EmcPose tool_offset = 420;</code>
       *
       * <pre>
       * TLO 
       * </pre>
       */
      private com.google.protobuf.SingleFieldBuilder<
          pb.Emcclass.EmcPose, pb.Emcclass.EmcPose.Builder, pb.Emcclass.EmcPoseOrBuilder> 
          getToolOffsetFieldBuilder() {
        if (toolOffsetBuilder_ == null) {
          toolOffsetBuilder_ = new com.google.protobuf.SingleFieldBuilder<
              pb.Emcclass.EmcPose, pb.Emcclass.EmcPose.Builder, pb.Emcclass.EmcPoseOrBuilder>(
                  getToolOffset(),
                  getParentForChildren(),
                  isClean());
          toolOffset_ = null;
        }
        return toolOffsetBuilder_;
      }

      // @@protoc_insertion_point(builder_scope:pb.MotionCommand)
    }

    static {
      defaultInstance = new MotionCommand(true);
      defaultInstance.initFields();
    }

    // @@protoc_insertion_point(class_scope:pb.MotionCommand)
  }

  public interface MotionStatusOrBuilder extends
      // @@protoc_insertion_point(interface_extends:pb.MotionStatus)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <code>required .pb.cmd_code_t commandEcho = 10;</code>
     *
     * <pre>
     * echo of input command 
     * </pre>
     */
    boolean hasCommandEcho();
    /**
     * <code>required .pb.cmd_code_t commandEcho = 10;</code>
     *
     * <pre>
     * echo of input command 
     * </pre>
     */
    pb.Motcmds.cmd_code_t getCommandEcho();

    /**
     * <code>required fixed32 commandNumEcho = 20;</code>
     *
     * <pre>
     * increment this for new command 
     * </pre>
     */
    boolean hasCommandNumEcho();
    /**
     * <code>required fixed32 commandNumEcho = 20;</code>
     *
     * <pre>
     * increment this for new command 
     * </pre>
     */
    int getCommandNumEcho();

    /**
     * <code>required .pb.cmd_status_t commandStatus = 30;</code>
     *
     * <pre>
     * result of most recent command 
     * </pre>
     */
    boolean hasCommandStatus();
    /**
     * <code>required .pb.cmd_status_t commandStatus = 30;</code>
     *
     * <pre>
     * result of most recent command 
     * </pre>
     */
    pb.Motcmds.cmd_status_t getCommandStatus();

    /**
     * <code>optional .pb.EmcPose carte_pos_fb = 40;</code>
     *
     * <pre>
     * actual Cartesian position 
     * </pre>
     */
    boolean hasCartePosFb();
    /**
     * <code>optional .pb.EmcPose carte_pos_fb = 40;</code>
     *
     * <pre>
     * actual Cartesian position 
     * </pre>
     */
    pb.Emcclass.EmcPose getCartePosFb();
    /**
     * <code>optional .pb.EmcPose carte_pos_fb = 40;</code>
     *
     * <pre>
     * actual Cartesian position 
     * </pre>
     */
    pb.Emcclass.EmcPoseOrBuilder getCartePosFbOrBuilder();
  }
  /**
   * Protobuf type {@code pb.MotionStatus}
   */
  public static final class MotionStatus extends
      com.google.protobuf.GeneratedMessage implements
      // @@protoc_insertion_point(message_implements:pb.MotionStatus)
      MotionStatusOrBuilder {
    // Use MotionStatus.newBuilder() to construct.
    private MotionStatus(com.google.protobuf.GeneratedMessage.Builder<?> builder) {
      super(builder);
      this.unknownFields = builder.getUnknownFields();
    }
    private MotionStatus(boolean noInit) { this.unknownFields = com.google.protobuf.UnknownFieldSet.getDefaultInstance(); }

    private static final MotionStatus defaultInstance;
    public static MotionStatus getDefaultInstance() {
      return defaultInstance;
    }

    public MotionStatus getDefaultInstanceForType() {
      return defaultInstance;
    }

    private final com.google.protobuf.UnknownFieldSet unknownFields;
    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
        getUnknownFields() {
      return this.unknownFields;
    }
    private MotionStatus(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      initFields();
      int mutable_bitField0_ = 0;
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            default: {
              if (!parseUnknownField(input, unknownFields,
                                     extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
            case 80: {
              int rawValue = input.readEnum();
              pb.Motcmds.cmd_code_t value = pb.Motcmds.cmd_code_t.valueOf(rawValue);
              if (value == null) {
                unknownFields.mergeVarintField(10, rawValue);
              } else {
                bitField0_ |= 0x00000001;
                commandEcho_ = value;
              }
              break;
            }
            case 165: {
              bitField0_ |= 0x00000002;
              commandNumEcho_ = input.readFixed32();
              break;
            }
            case 240: {
              int rawValue = input.readEnum();
              pb.Motcmds.cmd_status_t value = pb.Motcmds.cmd_status_t.valueOf(rawValue);
              if (value == null) {
                unknownFields.mergeVarintField(30, rawValue);
              } else {
                bitField0_ |= 0x00000004;
                commandStatus_ = value;
              }
              break;
            }
            case 322: {
              pb.Emcclass.EmcPose.Builder subBuilder = null;
              if (((bitField0_ & 0x00000008) == 0x00000008)) {
                subBuilder = cartePosFb_.toBuilder();
              }
              cartePosFb_ = input.readMessage(pb.Emcclass.EmcPose.PARSER, extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(cartePosFb_);
                cartePosFb_ = subBuilder.buildPartial();
              }
              bitField0_ |= 0x00000008;
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e.getMessage()).setUnfinishedMessage(this);
      } finally {
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return pb.Motcmds.internal_static_pb_MotionStatus_descriptor;
    }

    protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return pb.Motcmds.internal_static_pb_MotionStatus_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              pb.Motcmds.MotionStatus.class, pb.Motcmds.MotionStatus.Builder.class);
    }

    public static com.google.protobuf.Parser<MotionStatus> PARSER =
        new com.google.protobuf.AbstractParser<MotionStatus>() {
      public MotionStatus parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return new MotionStatus(input, extensionRegistry);
      }
    };

    @java.lang.Override
    public com.google.protobuf.Parser<MotionStatus> getParserForType() {
      return PARSER;
    }

    private int bitField0_;
    public static final int COMMANDECHO_FIELD_NUMBER = 10;
    private pb.Motcmds.cmd_code_t commandEcho_;
    /**
     * <code>required .pb.cmd_code_t commandEcho = 10;</code>
     *
     * <pre>
     * echo of input command 
     * </pre>
     */
    public boolean hasCommandEcho() {
      return ((bitField0_ & 0x00000001) == 0x00000001);
    }
    /**
     * <code>required .pb.cmd_code_t commandEcho = 10;</code>
     *
     * <pre>
     * echo of input command 
     * </pre>
     */
    public pb.Motcmds.cmd_code_t getCommandEcho() {
      return commandEcho_;
    }

    public static final int COMMANDNUMECHO_FIELD_NUMBER = 20;
    private int commandNumEcho_;
    /**
     * <code>required fixed32 commandNumEcho = 20;</code>
     *
     * <pre>
     * increment this for new command 
     * </pre>
     */
    public boolean hasCommandNumEcho() {
      return ((bitField0_ & 0x00000002) == 0x00000002);
    }
    /**
     * <code>required fixed32 commandNumEcho = 20;</code>
     *
     * <pre>
     * increment this for new command 
     * </pre>
     */
    public int getCommandNumEcho() {
      return commandNumEcho_;
    }

    public static final int COMMANDSTATUS_FIELD_NUMBER = 30;
    private pb.Motcmds.cmd_status_t commandStatus_;
    /**
     * <code>required .pb.cmd_status_t commandStatus = 30;</code>
     *
     * <pre>
     * result of most recent command 
     * </pre>
     */
    public boolean hasCommandStatus() {
      return ((bitField0_ & 0x00000004) == 0x00000004);
    }
    /**
     * <code>required .pb.cmd_status_t commandStatus = 30;</code>
     *
     * <pre>
     * result of most recent command 
     * </pre>
     */
    public pb.Motcmds.cmd_status_t getCommandStatus() {
      return commandStatus_;
    }

    public static final int CARTE_POS_FB_FIELD_NUMBER = 40;
    private pb.Emcclass.EmcPose cartePosFb_;
    /**
     * <code>optional .pb.EmcPose carte_pos_fb = 40;</code>
     *
     * <pre>
     * actual Cartesian position 
     * </pre>
     */
    public boolean hasCartePosFb() {
      return ((bitField0_ & 0x00000008) == 0x00000008);
    }
    /**
     * <code>optional .pb.EmcPose carte_pos_fb = 40;</code>
     *
     * <pre>
     * actual Cartesian position 
     * </pre>
     */
    public pb.Emcclass.EmcPose getCartePosFb() {
      return cartePosFb_;
    }
    /**
     * <code>optional .pb.EmcPose carte_pos_fb = 40;</code>
     *
     * <pre>
     * actual Cartesian position 
     * </pre>
     */
    public pb.Emcclass.EmcPoseOrBuilder getCartePosFbOrBuilder() {
      return cartePosFb_;
    }

    private void initFields() {
      commandEcho_ = pb.Motcmds.cmd_code_t.EMCMOT_ABORT;
      commandNumEcho_ = 0;
      commandStatus_ = pb.Motcmds.cmd_status_t.EMCMOT_COMMAND_OK;
      cartePosFb_ = pb.Emcclass.EmcPose.getDefaultInstance();
    }
    private byte memoizedIsInitialized = -1;
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      if (!hasCommandEcho()) {
        memoizedIsInitialized = 0;
        return false;
      }
      if (!hasCommandNumEcho()) {
        memoizedIsInitialized = 0;
        return false;
      }
      if (!hasCommandStatus()) {
        memoizedIsInitialized = 0;
        return false;
      }
      if (hasCartePosFb()) {
        if (!getCartePosFb().isInitialized()) {
          memoizedIsInitialized = 0;
          return false;
        }
      }
      memoizedIsInitialized = 1;
      return true;
    }

    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      getSerializedSize();
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        output.writeEnum(10, commandEcho_.getNumber());
      }
      if (((bitField0_ & 0x00000002) == 0x00000002)) {
        output.writeFixed32(20, commandNumEcho_);
      }
      if (((bitField0_ & 0x00000004) == 0x00000004)) {
        output.writeEnum(30, commandStatus_.getNumber());
      }
      if (((bitField0_ & 0x00000008) == 0x00000008)) {
        output.writeMessage(40, cartePosFb_);
      }
      getUnknownFields().writeTo(output);
    }

    private int memoizedSerializedSize = -1;
    public int getSerializedSize() {
      int size = memoizedSerializedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        size += com.google.protobuf.CodedOutputStream
          .computeEnumSize(10, commandEcho_.getNumber());
      }
      if (((bitField0_ & 0x00000002) == 0x00000002)) {
        size += com.google.protobuf.CodedOutputStream
          .computeFixed32Size(20, commandNumEcho_);
      }
      if (((bitField0_ & 0x00000004) == 0x00000004)) {
        size += com.google.protobuf.CodedOutputStream
          .computeEnumSize(30, commandStatus_.getNumber());
      }
      if (((bitField0_ & 0x00000008) == 0x00000008)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(40, cartePosFb_);
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSerializedSize = size;
      return size;
    }

    private static final long serialVersionUID = 0L;
    @java.lang.Override
    protected java.lang.Object writeReplace()
        throws java.io.ObjectStreamException {
      return super.writeReplace();
    }

    public static pb.Motcmds.MotionStatus parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static pb.Motcmds.MotionStatus parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static pb.Motcmds.MotionStatus parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static pb.Motcmds.MotionStatus parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static pb.Motcmds.MotionStatus parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return PARSER.parseFrom(input);
    }
    public static pb.Motcmds.MotionStatus parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return PARSER.parseFrom(input, extensionRegistry);
    }
    public static pb.Motcmds.MotionStatus parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return PARSER.parseDelimitedFrom(input);
    }
    public static pb.Motcmds.MotionStatus parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return PARSER.parseDelimitedFrom(input, extensionRegistry);
    }
    public static pb.Motcmds.MotionStatus parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return PARSER.parseFrom(input);
    }
    public static pb.Motcmds.MotionStatus parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return PARSER.parseFrom(input, extensionRegistry);
    }

    public static Builder newBuilder() { return Builder.create(); }
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder(pb.Motcmds.MotionStatus prototype) {
      return newBuilder().mergeFrom(prototype);
    }
    public Builder toBuilder() { return newBuilder(this); }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessage.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * Protobuf type {@code pb.MotionStatus}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessage.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:pb.MotionStatus)
        pb.Motcmds.MotionStatusOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return pb.Motcmds.internal_static_pb_MotionStatus_descriptor;
      }

      protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return pb.Motcmds.internal_static_pb_MotionStatus_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                pb.Motcmds.MotionStatus.class, pb.Motcmds.MotionStatus.Builder.class);
      }

      // Construct using pb.Motcmds.MotionStatus.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessage.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessage.alwaysUseFieldBuilders) {
          getCartePosFbFieldBuilder();
        }
      }
      private static Builder create() {
        return new Builder();
      }

      public Builder clear() {
        super.clear();
        commandEcho_ = pb.Motcmds.cmd_code_t.EMCMOT_ABORT;
        bitField0_ = (bitField0_ & ~0x00000001);
        commandNumEcho_ = 0;
        bitField0_ = (bitField0_ & ~0x00000002);
        commandStatus_ = pb.Motcmds.cmd_status_t.EMCMOT_COMMAND_OK;
        bitField0_ = (bitField0_ & ~0x00000004);
        if (cartePosFbBuilder_ == null) {
          cartePosFb_ = pb.Emcclass.EmcPose.getDefaultInstance();
        } else {
          cartePosFbBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000008);
        return this;
      }

      public Builder clone() {
        return create().mergeFrom(buildPartial());
      }

      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return pb.Motcmds.internal_static_pb_MotionStatus_descriptor;
      }

      public pb.Motcmds.MotionStatus getDefaultInstanceForType() {
        return pb.Motcmds.MotionStatus.getDefaultInstance();
      }

      public pb.Motcmds.MotionStatus build() {
        pb.Motcmds.MotionStatus result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      public pb.Motcmds.MotionStatus buildPartial() {
        pb.Motcmds.MotionStatus result = new pb.Motcmds.MotionStatus(this);
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) == 0x00000001)) {
          to_bitField0_ |= 0x00000001;
        }
        result.commandEcho_ = commandEcho_;
        if (((from_bitField0_ & 0x00000002) == 0x00000002)) {
          to_bitField0_ |= 0x00000002;
        }
        result.commandNumEcho_ = commandNumEcho_;
        if (((from_bitField0_ & 0x00000004) == 0x00000004)) {
          to_bitField0_ |= 0x00000004;
        }
        result.commandStatus_ = commandStatus_;
        if (((from_bitField0_ & 0x00000008) == 0x00000008)) {
          to_bitField0_ |= 0x00000008;
        }
        if (cartePosFbBuilder_ == null) {
          result.cartePosFb_ = cartePosFb_;
        } else {
          result.cartePosFb_ = cartePosFbBuilder_.build();
        }
        result.bitField0_ = to_bitField0_;
        onBuilt();
        return result;
      }

      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof pb.Motcmds.MotionStatus) {
          return mergeFrom((pb.Motcmds.MotionStatus)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(pb.Motcmds.MotionStatus other) {
        if (other == pb.Motcmds.MotionStatus.getDefaultInstance()) return this;
        if (other.hasCommandEcho()) {
          setCommandEcho(other.getCommandEcho());
        }
        if (other.hasCommandNumEcho()) {
          setCommandNumEcho(other.getCommandNumEcho());
        }
        if (other.hasCommandStatus()) {
          setCommandStatus(other.getCommandStatus());
        }
        if (other.hasCartePosFb()) {
          mergeCartePosFb(other.getCartePosFb());
        }
        this.mergeUnknownFields(other.getUnknownFields());
        return this;
      }

      public final boolean isInitialized() {
        if (!hasCommandEcho()) {
          
          return false;
        }
        if (!hasCommandNumEcho()) {
          
          return false;
        }
        if (!hasCommandStatus()) {
          
          return false;
        }
        if (hasCartePosFb()) {
          if (!getCartePosFb().isInitialized()) {
            
            return false;
          }
        }
        return true;
      }

      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        pb.Motcmds.MotionStatus parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (pb.Motcmds.MotionStatus) e.getUnfinishedMessage();
          throw e;
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }
      private int bitField0_;

      private pb.Motcmds.cmd_code_t commandEcho_ = pb.Motcmds.cmd_code_t.EMCMOT_ABORT;
      /**
       * <code>required .pb.cmd_code_t commandEcho = 10;</code>
       *
       * <pre>
       * echo of input command 
       * </pre>
       */
      public boolean hasCommandEcho() {
        return ((bitField0_ & 0x00000001) == 0x00000001);
      }
      /**
       * <code>required .pb.cmd_code_t commandEcho = 10;</code>
       *
       * <pre>
       * echo of input command 
       * </pre>
       */
      public pb.Motcmds.cmd_code_t getCommandEcho() {
        return commandEcho_;
      }
      /**
       * <code>required .pb.cmd_code_t commandEcho = 10;</code>
       *
       * <pre>
       * echo of input command 
       * </pre>
       */
      public Builder setCommandEcho(pb.Motcmds.cmd_code_t value) {
        if (value == null) {
          throw new NullPointerException();
        }
        bitField0_ |= 0x00000001;
        commandEcho_ = value;
        onChanged();
        return this;
      }
      /**
       * <code>required .pb.cmd_code_t commandEcho = 10;</code>
       *
       * <pre>
       * echo of input command 
       * </pre>
       */
      public Builder clearCommandEcho() {
        bitField0_ = (bitField0_ & ~0x00000001);
        commandEcho_ = pb.Motcmds.cmd_code_t.EMCMOT_ABORT;
        onChanged();
        return this;
      }

      private int commandNumEcho_ ;
      /**
       * <code>required fixed32 commandNumEcho = 20;</code>
       *
       * <pre>
       * increment this for new command 
       * </pre>
       */
      public boolean hasCommandNumEcho() {
        return ((bitField0_ & 0x00000002) == 0x00000002);
      }
      /**
       * <code>required fixed32 commandNumEcho = 20;</code>
       *
       * <pre>
       * increment this for new command 
       * </pre>
       */
      public int getCommandNumEcho() {
        return commandNumEcho_;
      }
      /**
       * <code>required fixed32 commandNumEcho = 20;</code>
       *
       * <pre>
       * increment this for new command 
       * </pre>
       */
      public Builder setCommandNumEcho(int value) {
        bitField0_ |= 0x00000002;
        commandNumEcho_ = value;
        onChanged();
        return this;
      }
      /**
       * <code>required fixed32 commandNumEcho = 20;</code>
       *
       * <pre>
       * increment this for new command 
       * </pre>
       */
      public Builder clearCommandNumEcho() {
        bitField0_ = (bitField0_ & ~0x00000002);
        commandNumEcho_ = 0;
        onChanged();
        return this;
      }

      private pb.Motcmds.cmd_status_t commandStatus_ = pb.Motcmds.cmd_status_t.EMCMOT_COMMAND_OK;
      /**
       * <code>required .pb.cmd_status_t commandStatus = 30;</code>
       *
       * <pre>
       * result of most recent command 
       * </pre>
       */
      public boolean hasCommandStatus() {
        return ((bitField0_ & 0x00000004) == 0x00000004);
      }
      /**
       * <code>required .pb.cmd_status_t commandStatus = 30;</code>
       *
       * <pre>
       * result of most recent command 
       * </pre>
       */
      public pb.Motcmds.cmd_status_t getCommandStatus() {
        return commandStatus_;
      }
      /**
       * <code>required .pb.cmd_status_t commandStatus = 30;</code>
       *
       * <pre>
       * result of most recent command 
       * </pre>
       */
      public Builder setCommandStatus(pb.Motcmds.cmd_status_t value) {
        if (value == null) {
          throw new NullPointerException();
        }
        bitField0_ |= 0x00000004;
        commandStatus_ = value;
        onChanged();
        return this;
      }
      /**
       * <code>required .pb.cmd_status_t commandStatus = 30;</code>
       *
       * <pre>
       * result of most recent command 
       * </pre>
       */
      public Builder clearCommandStatus() {
        bitField0_ = (bitField0_ & ~0x00000004);
        commandStatus_ = pb.Motcmds.cmd_status_t.EMCMOT_COMMAND_OK;
        onChanged();
        return this;
      }

      private pb.Emcclass.EmcPose cartePosFb_ = pb.Emcclass.EmcPose.getDefaultInstance();
      private com.google.protobuf.SingleFieldBuilder<
          pb.Emcclass.EmcPose, pb.Emcclass.EmcPose.Builder, pb.Emcclass.EmcPoseOrBuilder> cartePosFbBuilder_;
      /**
       * <code>optional .pb.EmcPose carte_pos_fb = 40;</code>
       *
       * <pre>
       * actual Cartesian position 
       * </pre>
       */
      public boolean hasCartePosFb() {
        return ((bitField0_ & 0x00000008) == 0x00000008);
      }
      /**
       * <code>optional .pb.EmcPose carte_pos_fb = 40;</code>
       *
       * <pre>
       * actual Cartesian position 
       * </pre>
       */
      public pb.Emcclass.EmcPose getCartePosFb() {
        if (cartePosFbBuilder_ == null) {
          return cartePosFb_;
        } else {
          return cartePosFbBuilder_.getMessage();
        }
      }
      /**
       * <code>optional .pb.EmcPose carte_pos_fb = 40;</code>
       *
       * <pre>
       * actual Cartesian position 
       * </pre>
       */
      public Builder setCartePosFb(pb.Emcclass.EmcPose value) {
        if (cartePosFbBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          cartePosFb_ = value;
          onChanged();
        } else {
          cartePosFbBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000008;
        return this;
      }
      /**
       * <code>optional .pb.EmcPose carte_pos_fb = 40;</code>
       *
       * <pre>
       * actual Cartesian position 
       * </pre>
       */
      public Builder setCartePosFb(
          pb.Emcclass.EmcPose.Builder builderForValue) {
        if (cartePosFbBuilder_ == null) {
          cartePosFb_ = builderForValue.build();
          onChanged();
        } else {
          cartePosFbBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000008;
        return this;
      }
      /**
       * <code>optional .pb.EmcPose carte_pos_fb = 40;</code>
       *
       * <pre>
       * actual Cartesian position 
       * </pre>
       */
      public Builder mergeCartePosFb(pb.Emcclass.EmcPose value) {
        if (cartePosFbBuilder_ == null) {
          if (((bitField0_ & 0x00000008) == 0x00000008) &&
              cartePosFb_ != pb.Emcclass.EmcPose.getDefaultInstance()) {
            cartePosFb_ =
              pb.Emcclass.EmcPose.newBuilder(cartePosFb_).mergeFrom(value).buildPartial();
          } else {
            cartePosFb_ = value;
          }
          onChanged();
        } else {
          cartePosFbBuilder_.mergeFrom(value);
        }
        bitField0_ |= 0x00000008;
        return this;
      }
      /**
       * <code>optional .pb.EmcPose carte_pos_fb = 40;</code>
       *
       * <pre>
       * actual Cartesian position 
       * </pre>
       */
      public Builder clearCartePosFb() {
        if (cartePosFbBuilder_ == null) {
          cartePosFb_ = pb.Emcclass.EmcPose.getDefaultInstance();
          onChanged();
        } else {
          cartePosFbBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000008);
        return this;
      }
      /**
       * <code>optional .pb.EmcPose carte_pos_fb = 40;</code>
       *
       * <pre>
       * actual Cartesian position 
       * </pre>
       */
      public pb.Emcclass.EmcPose.Builder getCartePosFbBuilder() {
        bitField0_ |= 0x00000008;
        onChanged();
        return getCartePosFbFieldBuilder().getBuilder();
      }
      /**
       * <code>optional .pb.EmcPose carte_pos_fb = 40;</code>
       *
       * <pre>
       * actual Cartesian position 
       * </pre>
       */
      public pb.Emcclass.EmcPoseOrBuilder getCartePosFbOrBuilder() {
        if (cartePosFbBuilder_ != null) {
          return cartePosFbBuilder_.getMessageOrBuilder();
        } else {
          return cartePosFb_;
        }
      }
      /**
       * <code>optional .pb.EmcPose carte_pos_fb = 40;</code>
       *
       * <pre>
       * actual Cartesian position 
       * </pre>
       */
      private com.google.protobuf.SingleFieldBuilder<
          pb.Emcclass.EmcPose, pb.Emcclass.EmcPose.Builder, pb.Emcclass.EmcPoseOrBuilder> 
          getCartePosFbFieldBuilder() {
        if (cartePosFbBuilder_ == null) {
          cartePosFbBuilder_ = new com.google.protobuf.SingleFieldBuilder<
              pb.Emcclass.EmcPose, pb.Emcclass.EmcPose.Builder, pb.Emcclass.EmcPoseOrBuilder>(
                  getCartePosFb(),
                  getParentForChildren(),
                  isClean());
          cartePosFb_ = null;
        }
        return cartePosFbBuilder_;
      }

      // @@protoc_insertion_point(builder_scope:pb.MotionStatus)
    }

    static {
      defaultInstance = new MotionStatus(true);
      defaultInstance.initFields();
    }

    // @@protoc_insertion_point(class_scope:pb.MotionStatus)
  }

  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_pb_MotionCommand_descriptor;
  private static
    com.google.protobuf.GeneratedMessage.FieldAccessorTable
      internal_static_pb_MotionCommand_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_pb_MotionStatus_descriptor;
  private static
    com.google.protobuf.GeneratedMessage.FieldAccessorTable
      internal_static_pb_MotionStatus_fieldAccessorTable;

  public static com.google.protobuf.Descriptors.FileDescriptor
      getDescriptor() {
    return descriptor;
  }
  private static com.google.protobuf.Descriptors.FileDescriptor
      descriptor;
  static {
    java.lang.String[] descriptorData = {
      "\n\"machinetalk/protobuf/motcmds.proto\022\002pb" +
      "\032#machinetalk/protobuf/emcclass.proto\032!m" +
      "achinetalk/protobuf/nanopb.proto\"\361\006\n\rMot" +
      "ionCommand\022\037\n\007command\030\n \002(\0162\016.pb.cmd_cod" +
      "e_t\022\022\n\ncommandNum\030\024 \002(\007\022\024\n\014motor_offset\030" +
      "\036 \001(\001\022\020\n\010maxLimit\030( \001(\001\022\020\n\010minLimit\0302 \001(" +
      "\001\022\030\n\003pos\030< \001(\0132\013.pb.EmcPose\022\037\n\006center\030F " +
      "\001(\0132\017.pb.PmCartesian\022\037\n\006normal\030P \001(\0132\017.p" +
      "b.PmCartesian\022\014\n\004turn\030Z \001(\007\022\013\n\003vel\030d \001(\001" +
      "\022\022\n\nini_maxvel\030n \001(\001\022#\n\013motion_type\030x \001(",
      "\0162\016.pb.MotionType\022\024\n\013spindlesync\030\202\001 \001(\001\022" +
      "\014\n\003acc\030\214\001 \001(\001\022\021\n\010backlash\030\226\001 \001(\001\022\013\n\002id\030\240" +
      "\001 \001(\007\022\021\n\010termCond\030\252\001 \001(\007\022\022\n\ttolerance\030\264\001" +
      " \001(\001\022\r\n\004axis\030\276\001 \001(\007\022\016\n\005scale\030\310\001 \001(\001\022\017\n\006o" +
      "ffset\030\322\001 \001(\001\022\r\n\004home\030\334\001 \001(\001\022\027\n\016home_fina" +
      "l_vel\030\346\001 \001(\001\022\023\n\nsearch_vel\030\360\001 \001(\001\022\022\n\tlat" +
      "ch_vel\030\372\001 \001(\001\022\016\n\005flags\030\204\002 \001(\007\022\026\n\rhome_se" +
      "quence\030\216\002 \001(\007\022\026\n\rvolatile_home\030\230\002 \001(\007\022\022\n" +
      "\tminFerror\030\242\002 \001(\001\022\022\n\tmaxFerror\030\254\002 \001(\001\022\017\n" +
      "\006wdWait\030\266\002 \001(\007\022\016\n\005debug\030\300\002 \001(\007\022\014\n\003now\030\312\002",
      " \001(\005\022\014\n\003out\030\324\002 \001(\005\022\016\n\005start\030\336\002 \001(\005\022\014\n\003en" +
      "d\030\350\002 \001(\005\022\r\n\004mode\030\362\002 \001(\005\022\025\n\014comp_nominal\030" +
      "\374\002 \001(\001\022\025\n\014comp_forward\030\206\003 \001(\001\022\025\n\014comp_re" +
      "verse\030\220\003 \001(\001\022\023\n\nprobe_type\030\232\003 \001(\005\022!\n\013too" +
      "l_offset\030\244\003 \001(\0132\013.pb.EmcPose:\006\222?\003H\330\004\"\237\001\n" +
      "\014MotionStatus\022#\n\013commandEcho\030\n \002(\0162\016.pb." +
      "cmd_code_t\022\026\n\016commandNumEcho\030\024 \002(\007\022\'\n\rco" +
      "mmandStatus\030\036 \002(\0162\020.pb.cmd_status_t\022!\n\014c" +
      "arte_pos_fb\030( \001(\0132\013.pb.EmcPose:\006\222?\003H\331\004*\334" +
      "\001\n\nMotionType\022\031\n\025_EMC_MOTION_TYPE_NONE\020\000",
      "\022\035\n\031_EMC_MOTION_TYPE_TRAVERSE\020\001\022\031\n\025_EMC_" +
      "MOTION_TYPE_FEED\020\002\022\030\n\024_EMC_MOTION_TYPE_A" +
      "RC\020\003\022\037\n\033_EMC_MOTION_TYPE_TOOLCHANGE\020\004\022\034\n" +
      "\030_EMC_MOTION_TYPE_PROBING\020\005\022 \n\034_EMC_MOTI" +
      "ON_TYPE_INDEXROTARY\020\006*\373\013\n\ncmd_code_t\022\021\n\014" +
      "EMCMOT_ABORT\020\240\037\022\026\n\021EMCMOT_AXIS_ABORT\020\241\037\022" +
      "\022\n\rEMCMOT_ENABLE\020\242\037\022\023\n\016EMCMOT_DISABLE\020\243\037" +
      "\022\034\n\027EMCMOT_ENABLE_AMPLIFIER\020\244\037\022\035\n\030EMCMOT" +
      "_DISABLE_AMPLIFIER\020\245\037\022\033\n\026EMCMOT_ENABLE_W" +
      "ATCHDOG\020\246\037\022\034\n\027EMCMOT_DISABLE_WATCHDOG\020\247\037",
      "\022\032\n\025EMCMOT_ACTIVATE_JOINT\020\250\037\022\034\n\027EMCMOT_D" +
      "EACTIVATE_JOINT\020\251\037\022\021\n\014EMCMOT_PAUSE\020\252\037\022\022\n" +
      "\rEMCMOT_RESUME\020\253\037\022\020\n\013EMCMOT_STEP\020\254\037\022\020\n\013E" +
      "MCMOT_FREE\020\255\037\022\021\n\014EMCMOT_COORD\020\256\037\022\022\n\rEMCM" +
      "OT_TELEOP\020\257\037\022\031\n\024EMCMOT_SPINDLE_SCALE\020\260\037\022" +
      "\025\n\020EMCMOT_SS_ENABLE\020\261\037\022\026\n\021EMCMOT_FEED_SC" +
      "ALE\020\262\037\022\025\n\020EMCMOT_FS_ENABLE\020\263\037\022\025\n\020EMCMOT_" +
      "FH_ENABLE\020\264\037\022\025\n\020EMCMOT_AF_ENABLE\020\265\037\022\033\n\026E" +
      "MCMOT_OVERRIDE_LIMITS\020\266\037\022\020\n\013EMCMOT_HOME\020" +
      "\267\037\022\022\n\rEMCMOT_UNHOME\020\270\037\022\024\n\017EMCMOT_JOG_CON",
      "T\020\271\037\022\024\n\017EMCMOT_JOG_INCR\020\272\037\022\023\n\016EMCMOT_JOG" +
      "_ABS\020\273\037\022\024\n\017EMCMOT_SET_LINE\020\274\037\022\026\n\021EMCMOT_" +
      "SET_CIRCLE\020\275\037\022\035\n\030EMCMOT_SET_TELEOP_VECTO" +
      "R\020\276\037\022\035\n\030EMCMOT_CLEAR_PROBE_FLAGS\020\277\037\022\021\n\014E" +
      "MCMOT_PROBE\020\300\037\022\025\n\020EMCMOT_RIGID_TAP\020\301\037\022\037\n" +
      "\032EMCMOT_SET_POSITION_LIMITS\020\302\037\022\030\n\023EMCMOT" +
      "_SET_BACKLASH\020\303\037\022\032\n\025EMCMOT_SET_MIN_FERRO" +
      "R\020\304\037\022\032\n\025EMCMOT_SET_MAX_FERROR\020\305\037\022\023\n\016EMCM" +
      "OT_SET_VEL\020\306\037\022\031\n\024EMCMOT_SET_VEL_LIMIT\020\307\037" +
      "\022\037\n\032EMCMOT_SET_JOINT_VEL_LIMIT\020\310\037\022\037\n\032EMC",
      "MOT_SET_JOINT_ACC_LIMIT\020\311\037\022\023\n\016EMCMOT_SET" +
      "_ACC\020\312\037\022\031\n\024EMCMOT_SET_TERM_COND\020\313\037\022\030\n\023EM" +
      "CMOT_SET_NUM_AXES\020\314\037\022\032\n\025EMCMOT_SET_WORLD" +
      "_HOME\020\315\037\022\035\n\030EMCMOT_SET_HOMING_PARAMS\020\316\037\022" +
      "\025\n\020EMCMOT_SET_DEBUG\020\317\037\022\024\n\017EMCMOT_SET_DOU" +
      "T\020\320\037\022\024\n\017EMCMOT_SET_AOUT\020\321\037\022\033\n\026EMCMOT_SET" +
      "_SPINDLESYNC\020\322\037\022\026\n\021EMCMOT_SPINDLE_ON\020\323\037\022" +
      "\027\n\022EMCMOT_SPINDLE_OFF\020\324\037\022\034\n\027EMCMOT_SPIND" +
      "LE_INCREASE\020\325\037\022\034\n\027EMCMOT_SPINDLE_DECREAS" +
      "E\020\326\037\022 \n\033EMCMOT_SPINDLE_BRAKE_ENGAGE\020\327\037\022!",
      "\n\034EMCMOT_SPINDLE_BRAKE_RELEASE\020\330\037\022\034\n\027EMC" +
      "MOT_SET_MOTOR_OFFSET\020\331\037\022\032\n\025EMCMOT_SET_JO" +
      "INT_COMP\020\332\037\022\026\n\021EMCMOT_SET_OFFSET\020\333\037*\255\001\n\014" +
      "cmd_status_t\022\025\n\021EMCMOT_COMMAND_OK\020\000\022\"\n\036E" +
      "MCMOT_COMMAND_UNKNOWN_COMMAND\020\001\022\"\n\036EMCMO" +
      "T_COMMAND_INVALID_COMMAND\020\002\022!\n\035EMCMOT_CO" +
      "MMAND_INVALID_PARAMS\020\003\022\033\n\027EMCMOT_COMMAND" +
      "_BAD_EXEC\020\004"
    };
    com.google.protobuf.Descriptors.FileDescriptor.InternalDescriptorAssigner assigner =
        new com.google.protobuf.Descriptors.FileDescriptor.    InternalDescriptorAssigner() {
          public com.google.protobuf.ExtensionRegistry assignDescriptors(
              com.google.protobuf.Descriptors.FileDescriptor root) {
            descriptor = root;
            return null;
          }
        };
    com.google.protobuf.Descriptors.FileDescriptor
      .internalBuildGeneratedFileFrom(descriptorData,
        new com.google.protobuf.Descriptors.FileDescriptor[] {
          pb.Emcclass.getDescriptor(),
          fi.kapsi.koti.jpa.nanopb.Nanopb.getDescriptor(),
        }, assigner);
    internal_static_pb_MotionCommand_descriptor =
      getDescriptor().getMessageTypes().get(0);
    internal_static_pb_MotionCommand_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessage.FieldAccessorTable(
        internal_static_pb_MotionCommand_descriptor,
        new java.lang.String[] { "Command", "CommandNum", "MotorOffset", "MaxLimit", "MinLimit", "Pos", "Center", "Normal", "Turn", "Vel", "IniMaxvel", "MotionType", "Spindlesync", "Acc", "Backlash", "Id", "TermCond", "Tolerance", "Axis", "Scale", "Offset", "Home", "HomeFinalVel", "SearchVel", "LatchVel", "Flags", "HomeSequence", "VolatileHome", "MinFerror", "MaxFerror", "WdWait", "Debug", "Now", "Out", "Start", "End", "Mode", "CompNominal", "CompForward", "CompReverse", "ProbeType", "ToolOffset", });
    internal_static_pb_MotionStatus_descriptor =
      getDescriptor().getMessageTypes().get(1);
    internal_static_pb_MotionStatus_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessage.FieldAccessorTable(
        internal_static_pb_MotionStatus_descriptor,
        new java.lang.String[] { "CommandEcho", "CommandNumEcho", "CommandStatus", "CartePosFb", });
    com.google.protobuf.ExtensionRegistry registry =
        com.google.protobuf.ExtensionRegistry.newInstance();
    registry.add(fi.kapsi.koti.jpa.nanopb.Nanopb.nanopbMsgopt);
    registry.add(fi.kapsi.koti.jpa.nanopb.Nanopb.nanopbMsgopt);
    com.google.protobuf.Descriptors.FileDescriptor
        .internalUpdateFileDescriptor(descriptor, registry);
    pb.Emcclass.getDescriptor();
    fi.kapsi.koti.jpa.nanopb.Nanopb.getDescriptor();
  }

  // @@protoc_insertion_point(outer_class_scope)
}
