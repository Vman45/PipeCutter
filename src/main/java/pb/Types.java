// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: machinetalk/protobuf/types.proto

package pb;

public final class Types {
  private Types() {}
  public static void registerAllExtensions(
      com.google.protobuf.ExtensionRegistry registry) {
  }
  /**
   * Protobuf enum {@code pb.ValueType}
   */
  public enum ValueType
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>HAL_BIT = 1;</code>
     *
     * <pre>
     *  the following tags correspond to hal.h: hal_type_t;
     * </pre>
     */
    HAL_BIT(0, 1),
    /**
     * <code>HAL_FLOAT = 2;</code>
     */
    HAL_FLOAT(1, 2),
    /**
     * <code>HAL_S32 = 3;</code>
     */
    HAL_S32(2, 3),
    /**
     * <code>HAL_U32 = 4;</code>
     */
    HAL_U32(3, 4),
    /**
     * <code>STRING = 5;</code>
     */
    STRING(4, 5),
    /**
     * <code>BYTES = 6;</code>
     */
    BYTES(5, 6),
    /**
     * <code>INT32 = 20;</code>
     */
    INT32(6, 20),
    /**
     * <code>UINT32 = 30;</code>
     */
    UINT32(7, 30),
    /**
     * <code>INT64 = 40;</code>
     */
    INT64(8, 40),
    /**
     * <code>UINT64 = 50;</code>
     */
    UINT64(9, 50),
    /**
     * <code>DOUBLE = 60;</code>
     */
    DOUBLE(10, 60),
    /**
     * <code>BOOL = 80;</code>
     */
    BOOL(11, 80),
    /**
     * <code>CARTESIAN = 100;</code>
     */
    CARTESIAN(12, 100),
    /**
     * <code>LEGACY_CARTESIAN = 110;</code>
     */
    LEGACY_CARTESIAN(13, 110),
    /**
     * <code>POSE = 120;</code>
     */
    POSE(14, 120),
    /**
     * <code>LEGACY_POSE = 130;</code>
     */
    LEGACY_POSE(15, 130),
    ;

    /**
     * <code>HAL_BIT = 1;</code>
     *
     * <pre>
     *  the following tags correspond to hal.h: hal_type_t;
     * </pre>
     */
    public static final int HAL_BIT_VALUE = 1;
    /**
     * <code>HAL_FLOAT = 2;</code>
     */
    public static final int HAL_FLOAT_VALUE = 2;
    /**
     * <code>HAL_S32 = 3;</code>
     */
    public static final int HAL_S32_VALUE = 3;
    /**
     * <code>HAL_U32 = 4;</code>
     */
    public static final int HAL_U32_VALUE = 4;
    /**
     * <code>STRING = 5;</code>
     */
    public static final int STRING_VALUE = 5;
    /**
     * <code>BYTES = 6;</code>
     */
    public static final int BYTES_VALUE = 6;
    /**
     * <code>INT32 = 20;</code>
     */
    public static final int INT32_VALUE = 20;
    /**
     * <code>UINT32 = 30;</code>
     */
    public static final int UINT32_VALUE = 30;
    /**
     * <code>INT64 = 40;</code>
     */
    public static final int INT64_VALUE = 40;
    /**
     * <code>UINT64 = 50;</code>
     */
    public static final int UINT64_VALUE = 50;
    /**
     * <code>DOUBLE = 60;</code>
     */
    public static final int DOUBLE_VALUE = 60;
    /**
     * <code>BOOL = 80;</code>
     */
    public static final int BOOL_VALUE = 80;
    /**
     * <code>CARTESIAN = 100;</code>
     */
    public static final int CARTESIAN_VALUE = 100;
    /**
     * <code>LEGACY_CARTESIAN = 110;</code>
     */
    public static final int LEGACY_CARTESIAN_VALUE = 110;
    /**
     * <code>POSE = 120;</code>
     */
    public static final int POSE_VALUE = 120;
    /**
     * <code>LEGACY_POSE = 130;</code>
     */
    public static final int LEGACY_POSE_VALUE = 130;


    public final int getNumber() { return value; }

    public static ValueType valueOf(int value) {
      switch (value) {
        case 1: return HAL_BIT;
        case 2: return HAL_FLOAT;
        case 3: return HAL_S32;
        case 4: return HAL_U32;
        case 5: return STRING;
        case 6: return BYTES;
        case 20: return INT32;
        case 30: return UINT32;
        case 40: return INT64;
        case 50: return UINT64;
        case 60: return DOUBLE;
        case 80: return BOOL;
        case 100: return CARTESIAN;
        case 110: return LEGACY_CARTESIAN;
        case 120: return POSE;
        case 130: return LEGACY_POSE;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<ValueType>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<ValueType>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<ValueType>() {
            public ValueType findValueByNumber(int number) {
              return ValueType.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return pb.Types.getDescriptor().getEnumTypes().get(0);
    }

    private static final ValueType[] VALUES = values();

    public static ValueType valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new java.lang.IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private ValueType(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:pb.ValueType)
  }

  /**
   * Protobuf enum {@code pb.HalPinDirection}
   */
  public enum HalPinDirection
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>HAL_IN = 16;</code>
     *
     * <pre>
     *  the following tags correspond to hal.h: hal_pin_dir_t
     * </pre>
     */
    HAL_IN(0, 16),
    /**
     * <code>HAL_OUT = 32;</code>
     */
    HAL_OUT(1, 32),
    /**
     * <code>HAL_IO = 48;</code>
     *
     * <pre>
     * (HAL_IN | HAL_OUT),
     * </pre>
     */
    HAL_IO(2, 48),
    ;

    /**
     * <code>HAL_IN = 16;</code>
     *
     * <pre>
     *  the following tags correspond to hal.h: hal_pin_dir_t
     * </pre>
     */
    public static final int HAL_IN_VALUE = 16;
    /**
     * <code>HAL_OUT = 32;</code>
     */
    public static final int HAL_OUT_VALUE = 32;
    /**
     * <code>HAL_IO = 48;</code>
     *
     * <pre>
     * (HAL_IN | HAL_OUT),
     * </pre>
     */
    public static final int HAL_IO_VALUE = 48;


    public final int getNumber() { return value; }

    public static HalPinDirection valueOf(int value) {
      switch (value) {
        case 16: return HAL_IN;
        case 32: return HAL_OUT;
        case 48: return HAL_IO;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<HalPinDirection>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<HalPinDirection>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<HalPinDirection>() {
            public HalPinDirection findValueByNumber(int number) {
              return HalPinDirection.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return pb.Types.getDescriptor().getEnumTypes().get(1);
    }

    private static final HalPinDirection[] VALUES = values();

    public static HalPinDirection valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new java.lang.IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private HalPinDirection(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:pb.HalPinDirection)
  }

  /**
   * Protobuf enum {@code pb.HalParamDirection}
   */
  public enum HalParamDirection
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>HAL_RO = 64;</code>
     *
     * <pre>
     *  the following tags correspond to hal.h: hal_param_dir_t
     * </pre>
     */
    HAL_RO(0, 64),
    /**
     * <code>HAL_RW = 192;</code>
     */
    HAL_RW(1, 192),
    ;

    /**
     * <code>HAL_RO = 64;</code>
     *
     * <pre>
     *  the following tags correspond to hal.h: hal_param_dir_t
     * </pre>
     */
    public static final int HAL_RO_VALUE = 64;
    /**
     * <code>HAL_RW = 192;</code>
     */
    public static final int HAL_RW_VALUE = 192;


    public final int getNumber() { return value; }

    public static HalParamDirection valueOf(int value) {
      switch (value) {
        case 64: return HAL_RO;
        case 192: return HAL_RW;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<HalParamDirection>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<HalParamDirection>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<HalParamDirection>() {
            public HalParamDirection findValueByNumber(int number) {
              return HalParamDirection.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return pb.Types.getDescriptor().getEnumTypes().get(2);
    }

    private static final HalParamDirection[] VALUES = values();

    public static HalParamDirection valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new java.lang.IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private HalParamDirection(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:pb.HalParamDirection)
  }

  /**
   * Protobuf enum {@code pb.ObjectType}
   */
  public enum ObjectType
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>HAL_PIN = 1;</code>
     *
     * <pre>
     * option allow_alias = true; // for src/hal.h enum
     * doesnt work with ptotoc-c
     * NB: leading underscore to disambiguate
     * </pre>
     */
    HAL_PIN(0, 1),
    /**
     * <code>HAL_SIGNAL = 2;</code>
     */
    HAL_SIGNAL(1, 2),
    /**
     * <code>HAL_PARAM = 3;</code>
     */
    HAL_PARAM(2, 3),
    /**
     * <code>HAL_THREAD = 4;</code>
     */
    HAL_THREAD(3, 4),
    /**
     * <code>HAL_FUNCT = 5;</code>
     */
    HAL_FUNCT(4, 5),
    /**
     * <code>HAL_ALIAS = 6;</code>
     */
    HAL_ALIAS(5, 6),
    /**
     * <code>HAL_COMP_RT = 7;</code>
     */
    HAL_COMP_RT(6, 7),
    /**
     * <code>HAL_COMP_USER = 8;</code>
     */
    HAL_COMP_USER(7, 8),
    /**
     * <code>HAL_COMP_REMOTE = 9;</code>
     */
    HAL_COMP_REMOTE(8, 9),
    /**
     * <code>HAL_RING = 10;</code>
     */
    HAL_RING(9, 10),
    /**
     * <code>HAL_GROUP = 11;</code>
     */
    HAL_GROUP(10, 11),
    /**
     * <code>HAL_MEMBER_SIGNAL = 12;</code>
     */
    HAL_MEMBER_SIGNAL(11, 12),
    /**
     * <code>HAL_MEMBER_GROUP = 13;</code>
     */
    HAL_MEMBER_GROUP(12, 13),
    /**
     * <code>HAL_MEMBER_PIN = 14;</code>
     */
    HAL_MEMBER_PIN(13, 14),
    /**
     * <code>HAL_MEMBER_PARAM = 15;</code>
     */
    HAL_MEMBER_PARAM(14, 15),
    /**
     * <code>RING_RECORD = 16;</code>
     */
    RING_RECORD(15, 16),
    /**
     * <code>RING_STREAM = 17;</code>
     */
    RING_STREAM(16, 17),
    /**
     * <code>HAL_VTABLE = 18;</code>
     */
    HAL_VTABLE(17, 18),
    /**
     * <code>HAL_INST = 19;</code>
     */
    HAL_INST(18, 19),
    /**
     * <code>RING_MULTIFRAME = 20;</code>
     */
    RING_MULTIFRAME(19, 20),
    /**
     * <code>VALUE = 120;</code>
     *
     * <pre>
     * used at all?
     * </pre>
     */
    VALUE(20, 120),
    /**
     * <code>INSTANCE = 121;</code>
     */
    INSTANCE(21, 121),
    /**
     * <code>ORIGINATOR = 122;</code>
     */
    ORIGINATOR(22, 122),
    /**
     * <code>NAMED_VALUE = 125;</code>
     */
    NAMED_VALUE(23, 125),
    /**
     * <code>OT_ERROR = 130;</code>
     */
    OT_ERROR(24, 130),
    ;

    /**
     * <code>HAL_PIN = 1;</code>
     *
     * <pre>
     * option allow_alias = true; // for src/hal.h enum
     * doesnt work with ptotoc-c
     * NB: leading underscore to disambiguate
     * </pre>
     */
    public static final int HAL_PIN_VALUE = 1;
    /**
     * <code>HAL_SIGNAL = 2;</code>
     */
    public static final int HAL_SIGNAL_VALUE = 2;
    /**
     * <code>HAL_PARAM = 3;</code>
     */
    public static final int HAL_PARAM_VALUE = 3;
    /**
     * <code>HAL_THREAD = 4;</code>
     */
    public static final int HAL_THREAD_VALUE = 4;
    /**
     * <code>HAL_FUNCT = 5;</code>
     */
    public static final int HAL_FUNCT_VALUE = 5;
    /**
     * <code>HAL_ALIAS = 6;</code>
     */
    public static final int HAL_ALIAS_VALUE = 6;
    /**
     * <code>HAL_COMP_RT = 7;</code>
     */
    public static final int HAL_COMP_RT_VALUE = 7;
    /**
     * <code>HAL_COMP_USER = 8;</code>
     */
    public static final int HAL_COMP_USER_VALUE = 8;
    /**
     * <code>HAL_COMP_REMOTE = 9;</code>
     */
    public static final int HAL_COMP_REMOTE_VALUE = 9;
    /**
     * <code>HAL_RING = 10;</code>
     */
    public static final int HAL_RING_VALUE = 10;
    /**
     * <code>HAL_GROUP = 11;</code>
     */
    public static final int HAL_GROUP_VALUE = 11;
    /**
     * <code>HAL_MEMBER_SIGNAL = 12;</code>
     */
    public static final int HAL_MEMBER_SIGNAL_VALUE = 12;
    /**
     * <code>HAL_MEMBER_GROUP = 13;</code>
     */
    public static final int HAL_MEMBER_GROUP_VALUE = 13;
    /**
     * <code>HAL_MEMBER_PIN = 14;</code>
     */
    public static final int HAL_MEMBER_PIN_VALUE = 14;
    /**
     * <code>HAL_MEMBER_PARAM = 15;</code>
     */
    public static final int HAL_MEMBER_PARAM_VALUE = 15;
    /**
     * <code>RING_RECORD = 16;</code>
     */
    public static final int RING_RECORD_VALUE = 16;
    /**
     * <code>RING_STREAM = 17;</code>
     */
    public static final int RING_STREAM_VALUE = 17;
    /**
     * <code>HAL_VTABLE = 18;</code>
     */
    public static final int HAL_VTABLE_VALUE = 18;
    /**
     * <code>HAL_INST = 19;</code>
     */
    public static final int HAL_INST_VALUE = 19;
    /**
     * <code>RING_MULTIFRAME = 20;</code>
     */
    public static final int RING_MULTIFRAME_VALUE = 20;
    /**
     * <code>VALUE = 120;</code>
     *
     * <pre>
     * used at all?
     * </pre>
     */
    public static final int VALUE_VALUE = 120;
    /**
     * <code>INSTANCE = 121;</code>
     */
    public static final int INSTANCE_VALUE = 121;
    /**
     * <code>ORIGINATOR = 122;</code>
     */
    public static final int ORIGINATOR_VALUE = 122;
    /**
     * <code>NAMED_VALUE = 125;</code>
     */
    public static final int NAMED_VALUE_VALUE = 125;
    /**
     * <code>OT_ERROR = 130;</code>
     */
    public static final int OT_ERROR_VALUE = 130;


    public final int getNumber() { return value; }

    public static ObjectType valueOf(int value) {
      switch (value) {
        case 1: return HAL_PIN;
        case 2: return HAL_SIGNAL;
        case 3: return HAL_PARAM;
        case 4: return HAL_THREAD;
        case 5: return HAL_FUNCT;
        case 6: return HAL_ALIAS;
        case 7: return HAL_COMP_RT;
        case 8: return HAL_COMP_USER;
        case 9: return HAL_COMP_REMOTE;
        case 10: return HAL_RING;
        case 11: return HAL_GROUP;
        case 12: return HAL_MEMBER_SIGNAL;
        case 13: return HAL_MEMBER_GROUP;
        case 14: return HAL_MEMBER_PIN;
        case 15: return HAL_MEMBER_PARAM;
        case 16: return RING_RECORD;
        case 17: return RING_STREAM;
        case 18: return HAL_VTABLE;
        case 19: return HAL_INST;
        case 20: return RING_MULTIFRAME;
        case 120: return VALUE;
        case 121: return INSTANCE;
        case 122: return ORIGINATOR;
        case 125: return NAMED_VALUE;
        case 130: return OT_ERROR;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<ObjectType>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<ObjectType>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<ObjectType>() {
            public ObjectType findValueByNumber(int number) {
              return ObjectType.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return pb.Types.getDescriptor().getEnumTypes().get(3);
    }

    private static final ObjectType[] VALUES = values();

    public static ObjectType valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new java.lang.IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private ObjectType(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:pb.ObjectType)
  }

  /**
   * Protobuf enum {@code pb.RCS_STATUS}
   */
  public enum RCS_STATUS
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>UNINITIALIZED_STATUS = -1;</code>
     */
    UNINITIALIZED_STATUS(0, -1),
    /**
     * <code>RCS_DONE = 1;</code>
     */
    RCS_DONE(1, 1),
    /**
     * <code>RCS_EXEC = 2;</code>
     */
    RCS_EXEC(2, 2),
    /**
     * <code>RCS_ERROR = 3;</code>
     */
    RCS_ERROR(3, 3),
    /**
     * <code>RCS_RECEIVED = 4;</code>
     */
    RCS_RECEIVED(4, 4),
    ;

    /**
     * <code>UNINITIALIZED_STATUS = -1;</code>
     */
    public static final int UNINITIALIZED_STATUS_VALUE = -1;
    /**
     * <code>RCS_DONE = 1;</code>
     */
    public static final int RCS_DONE_VALUE = 1;
    /**
     * <code>RCS_EXEC = 2;</code>
     */
    public static final int RCS_EXEC_VALUE = 2;
    /**
     * <code>RCS_ERROR = 3;</code>
     */
    public static final int RCS_ERROR_VALUE = 3;
    /**
     * <code>RCS_RECEIVED = 4;</code>
     */
    public static final int RCS_RECEIVED_VALUE = 4;


    public final int getNumber() { return value; }

    public static RCS_STATUS valueOf(int value) {
      switch (value) {
        case -1: return UNINITIALIZED_STATUS;
        case 1: return RCS_DONE;
        case 2: return RCS_EXEC;
        case 3: return RCS_ERROR;
        case 4: return RCS_RECEIVED;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<RCS_STATUS>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<RCS_STATUS>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<RCS_STATUS>() {
            public RCS_STATUS findValueByNumber(int number) {
              return RCS_STATUS.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return pb.Types.getDescriptor().getEnumTypes().get(4);
    }

    private static final RCS_STATUS[] VALUES = values();

    public static RCS_STATUS valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new java.lang.IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private RCS_STATUS(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:pb.RCS_STATUS)
  }

  /**
   * Protobuf enum {@code pb.MsgOrigin}
   *
   * <pre>
   * see rtapi.h
   * </pre>
   */
  public enum MsgOrigin
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>MSG_KERNEL = 0;</code>
     */
    MSG_KERNEL(0, 0),
    /**
     * <code>MSG_RTUSER = 1;</code>
     */
    MSG_RTUSER(1, 1),
    /**
     * <code>MSG_ULAPI = 2;</code>
     */
    MSG_ULAPI(2, 2),
    ;

    /**
     * <code>MSG_KERNEL = 0;</code>
     */
    public static final int MSG_KERNEL_VALUE = 0;
    /**
     * <code>MSG_RTUSER = 1;</code>
     */
    public static final int MSG_RTUSER_VALUE = 1;
    /**
     * <code>MSG_ULAPI = 2;</code>
     */
    public static final int MSG_ULAPI_VALUE = 2;


    public final int getNumber() { return value; }

    public static MsgOrigin valueOf(int value) {
      switch (value) {
        case 0: return MSG_KERNEL;
        case 1: return MSG_RTUSER;
        case 2: return MSG_ULAPI;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<MsgOrigin>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<MsgOrigin>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<MsgOrigin>() {
            public MsgOrigin findValueByNumber(int number) {
              return MsgOrigin.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return pb.Types.getDescriptor().getEnumTypes().get(5);
    }

    private static final MsgOrigin[] VALUES = values();

    public static MsgOrigin valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new java.lang.IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private MsgOrigin(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:pb.MsgOrigin)
  }

  /**
   * Protobuf enum {@code pb.MsgLevel}
   */
  public enum MsgLevel
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>RTAPI_MSG_NONE = 0;</code>
     *
     * <pre>
     * see enum msg_level_t in rtapi.h
     * </pre>
     */
    RTAPI_MSG_NONE(0, 0),
    /**
     * <code>RTAPI_MSG_ERR = 1;</code>
     */
    RTAPI_MSG_ERR(1, 1),
    /**
     * <code>RTAPI_MSG_WARN = 2;</code>
     */
    RTAPI_MSG_WARN(2, 2),
    /**
     * <code>RTAPI_MSG_INFO = 3;</code>
     */
    RTAPI_MSG_INFO(3, 3),
    /**
     * <code>RTAPI_MSG_DBG = 4;</code>
     */
    RTAPI_MSG_DBG(4, 4),
    /**
     * <code>RTAPI_MSG_ALL = 5;</code>
     */
    RTAPI_MSG_ALL(5, 5),
    ;

    /**
     * <code>RTAPI_MSG_NONE = 0;</code>
     *
     * <pre>
     * see enum msg_level_t in rtapi.h
     * </pre>
     */
    public static final int RTAPI_MSG_NONE_VALUE = 0;
    /**
     * <code>RTAPI_MSG_ERR = 1;</code>
     */
    public static final int RTAPI_MSG_ERR_VALUE = 1;
    /**
     * <code>RTAPI_MSG_WARN = 2;</code>
     */
    public static final int RTAPI_MSG_WARN_VALUE = 2;
    /**
     * <code>RTAPI_MSG_INFO = 3;</code>
     */
    public static final int RTAPI_MSG_INFO_VALUE = 3;
    /**
     * <code>RTAPI_MSG_DBG = 4;</code>
     */
    public static final int RTAPI_MSG_DBG_VALUE = 4;
    /**
     * <code>RTAPI_MSG_ALL = 5;</code>
     */
    public static final int RTAPI_MSG_ALL_VALUE = 5;


    public final int getNumber() { return value; }

    public static MsgLevel valueOf(int value) {
      switch (value) {
        case 0: return RTAPI_MSG_NONE;
        case 1: return RTAPI_MSG_ERR;
        case 2: return RTAPI_MSG_WARN;
        case 3: return RTAPI_MSG_INFO;
        case 4: return RTAPI_MSG_DBG;
        case 5: return RTAPI_MSG_ALL;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<MsgLevel>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<MsgLevel>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<MsgLevel>() {
            public MsgLevel findValueByNumber(int number) {
              return MsgLevel.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return pb.Types.getDescriptor().getEnumTypes().get(6);
    }

    private static final MsgLevel[] VALUES = values();

    public static MsgLevel valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new java.lang.IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private MsgLevel(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:pb.MsgLevel)
  }

  /**
   * Protobuf enum {@code pb.OriginDetail}
   */
  public enum OriginDetail
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>UNIX_SIGNAL = 10;</code>
     */
    UNIX_SIGNAL(0, 10),
    /**
     * <code>INSTANCE_SHUTDOWN = 20;</code>
     */
    INSTANCE_SHUTDOWN(1, 20),
    /**
     * <code>ZMQ_SOCKET = 70;</code>
     */
    ZMQ_SOCKET(2, 70),
    /**
     * <code>NML_LAYER = 80;</code>
     */
    NML_LAYER(3, 80),
    /**
     * <code>RCS_LAYER = 90;</code>
     */
    RCS_LAYER(4, 90),
    /**
     * <code>CMS_LAYER = 100;</code>
     */
    CMS_LAYER(5, 100),
    /**
     * <code>IP_LAYER = 110;</code>
     */
    IP_LAYER(6, 110),
    /**
     * <code>TCP_LAYER = 120;</code>
     */
    TCP_LAYER(7, 120),
    /**
     * <code>PGM_LAYER = 130;</code>
     */
    PGM_LAYER(8, 130),
    ;

    /**
     * <code>UNIX_SIGNAL = 10;</code>
     */
    public static final int UNIX_SIGNAL_VALUE = 10;
    /**
     * <code>INSTANCE_SHUTDOWN = 20;</code>
     */
    public static final int INSTANCE_SHUTDOWN_VALUE = 20;
    /**
     * <code>ZMQ_SOCKET = 70;</code>
     */
    public static final int ZMQ_SOCKET_VALUE = 70;
    /**
     * <code>NML_LAYER = 80;</code>
     */
    public static final int NML_LAYER_VALUE = 80;
    /**
     * <code>RCS_LAYER = 90;</code>
     */
    public static final int RCS_LAYER_VALUE = 90;
    /**
     * <code>CMS_LAYER = 100;</code>
     */
    public static final int CMS_LAYER_VALUE = 100;
    /**
     * <code>IP_LAYER = 110;</code>
     */
    public static final int IP_LAYER_VALUE = 110;
    /**
     * <code>TCP_LAYER = 120;</code>
     */
    public static final int TCP_LAYER_VALUE = 120;
    /**
     * <code>PGM_LAYER = 130;</code>
     */
    public static final int PGM_LAYER_VALUE = 130;


    public final int getNumber() { return value; }

    public static OriginDetail valueOf(int value) {
      switch (value) {
        case 10: return UNIX_SIGNAL;
        case 20: return INSTANCE_SHUTDOWN;
        case 70: return ZMQ_SOCKET;
        case 80: return NML_LAYER;
        case 90: return RCS_LAYER;
        case 100: return CMS_LAYER;
        case 110: return IP_LAYER;
        case 120: return TCP_LAYER;
        case 130: return PGM_LAYER;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<OriginDetail>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<OriginDetail>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<OriginDetail>() {
            public OriginDetail findValueByNumber(int number) {
              return OriginDetail.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return pb.Types.getDescriptor().getEnumTypes().get(7);
    }

    private static final OriginDetail[] VALUES = values();

    public static OriginDetail valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new java.lang.IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private OriginDetail(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:pb.OriginDetail)
  }

  /**
   * Protobuf enum {@code pb.OriginType}
   */
  public enum OriginType
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>PROCESS = 10;</code>
     */
    PROCESS(0, 10),
    /**
     * <code>USER_THREAD = 20;</code>
     */
    USER_THREAD(1, 20),
    /**
     * <code>RT_THREAD = 30;</code>
     */
    RT_THREAD(2, 30),
    /**
     * <code>COMPONENT = 40;</code>
     */
    COMPONENT(3, 40),
    /**
     * <code>THREAD_FUNCTION = 50;</code>
     */
    THREAD_FUNCTION(4, 50),
    /**
     * <code>COMPONENT_INIT = 60;</code>
     */
    COMPONENT_INIT(5, 60),
    /**
     * <code>COMPONENT_EXIT = 70;</code>
     */
    COMPONENT_EXIT(6, 70),
    /**
     * <code>GROUP = 80;</code>
     */
    GROUP(7, 80),
    /**
     * <code>PIN = 90;</code>
     */
    PIN(8, 90),
    /**
     * <code>SIGNAL = 100;</code>
     */
    SIGNAL(9, 100),
    ;

    /**
     * <code>PROCESS = 10;</code>
     */
    public static final int PROCESS_VALUE = 10;
    /**
     * <code>USER_THREAD = 20;</code>
     */
    public static final int USER_THREAD_VALUE = 20;
    /**
     * <code>RT_THREAD = 30;</code>
     */
    public static final int RT_THREAD_VALUE = 30;
    /**
     * <code>COMPONENT = 40;</code>
     */
    public static final int COMPONENT_VALUE = 40;
    /**
     * <code>THREAD_FUNCTION = 50;</code>
     */
    public static final int THREAD_FUNCTION_VALUE = 50;
    /**
     * <code>COMPONENT_INIT = 60;</code>
     */
    public static final int COMPONENT_INIT_VALUE = 60;
    /**
     * <code>COMPONENT_EXIT = 70;</code>
     */
    public static final int COMPONENT_EXIT_VALUE = 70;
    /**
     * <code>GROUP = 80;</code>
     */
    public static final int GROUP_VALUE = 80;
    /**
     * <code>PIN = 90;</code>
     */
    public static final int PIN_VALUE = 90;
    /**
     * <code>SIGNAL = 100;</code>
     */
    public static final int SIGNAL_VALUE = 100;


    public final int getNumber() { return value; }

    public static OriginType valueOf(int value) {
      switch (value) {
        case 10: return PROCESS;
        case 20: return USER_THREAD;
        case 30: return RT_THREAD;
        case 40: return COMPONENT;
        case 50: return THREAD_FUNCTION;
        case 60: return COMPONENT_INIT;
        case 70: return COMPONENT_EXIT;
        case 80: return GROUP;
        case 90: return PIN;
        case 100: return SIGNAL;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<OriginType>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<OriginType>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<OriginType>() {
            public OriginType findValueByNumber(int number) {
              return OriginType.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return pb.Types.getDescriptor().getEnumTypes().get(8);
    }

    private static final OriginType[] VALUES = values();

    public static OriginType valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new java.lang.IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private OriginType(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:pb.OriginType)
  }

  /**
   * Protobuf enum {@code pb.Severity}
   */
  public enum Severity
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>S_INFORMATIONAL = 1;</code>
     */
    S_INFORMATIONAL(0, 1),
    /**
     * <code>S_WARNING = 2;</code>
     */
    S_WARNING(1, 2),
    /**
     * <code>S_FAIL = 4;</code>
     */
    S_FAIL(2, 4),
    ;

    /**
     * <code>S_INFORMATIONAL = 1;</code>
     */
    public static final int S_INFORMATIONAL_VALUE = 1;
    /**
     * <code>S_WARNING = 2;</code>
     */
    public static final int S_WARNING_VALUE = 2;
    /**
     * <code>S_FAIL = 4;</code>
     */
    public static final int S_FAIL_VALUE = 4;


    public final int getNumber() { return value; }

    public static Severity valueOf(int value) {
      switch (value) {
        case 1: return S_INFORMATIONAL;
        case 2: return S_WARNING;
        case 4: return S_FAIL;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<Severity>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<Severity>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<Severity>() {
            public Severity findValueByNumber(int number) {
              return Severity.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return pb.Types.getDescriptor().getEnumTypes().get(9);
    }

    private static final Severity[] VALUES = values();

    public static Severity valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new java.lang.IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private Severity(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:pb.Severity)
  }

  /**
   * Protobuf enum {@code pb.StatusType}
   */
  public enum StatusType
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>ENQUEUED = 1;</code>
     *
     * <pre>
     * intermediate
     * </pre>
     */
    ENQUEUED(0, 1),
    /**
     * <code>PROCESSING = 2;</code>
     *
     * <pre>
     * -- '' --
     * </pre>
     */
    PROCESSING(1, 2),
    /**
     * <code>COMPLETE = 3;</code>
     *
     * <pre>
     * final
     * </pre>
     */
    COMPLETE(2, 3),
    /**
     * <code>FAILED = 4;</code>
     *
     * <pre>
     * -- '' --
     * </pre>
     */
    FAILED(3, 4),
    ;

    /**
     * <code>ENQUEUED = 1;</code>
     *
     * <pre>
     * intermediate
     * </pre>
     */
    public static final int ENQUEUED_VALUE = 1;
    /**
     * <code>PROCESSING = 2;</code>
     *
     * <pre>
     * -- '' --
     * </pre>
     */
    public static final int PROCESSING_VALUE = 2;
    /**
     * <code>COMPLETE = 3;</code>
     *
     * <pre>
     * final
     * </pre>
     */
    public static final int COMPLETE_VALUE = 3;
    /**
     * <code>FAILED = 4;</code>
     *
     * <pre>
     * -- '' --
     * </pre>
     */
    public static final int FAILED_VALUE = 4;


    public final int getNumber() { return value; }

    public static StatusType valueOf(int value) {
      switch (value) {
        case 1: return ENQUEUED;
        case 2: return PROCESSING;
        case 3: return COMPLETE;
        case 4: return FAILED;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<StatusType>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<StatusType>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<StatusType>() {
            public StatusType findValueByNumber(int number) {
              return StatusType.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return pb.Types.getDescriptor().getEnumTypes().get(10);
    }

    private static final StatusType[] VALUES = values();

    public static StatusType valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new java.lang.IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private StatusType(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:pb.StatusType)
  }

  /**
   * Protobuf enum {@code pb.ReplyType}
   */
  public enum ReplyType
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>NONE = 0;</code>
     *
     * <pre>
     * NONE wont work with zmq REQ/REP sockets:
     * they require a reply
     * better to use XREQ/XREP
     * </pre>
     */
    NONE(0, 0),
    /**
     * <code>ON_RECEPTION = 1;</code>
     */
    ON_RECEPTION(1, 1),
    /**
     * <code>ON_QUEUED = 2;</code>
     */
    ON_QUEUED(2, 2),
    /**
     * <code>ON_COMPLETION = 4;</code>
     */
    ON_COMPLETION(3, 4),
    /**
     * <code>ALL_STEPS = 255;</code>
     */
    ALL_STEPS(4, 255),
    ;

    /**
     * <code>NONE = 0;</code>
     *
     * <pre>
     * NONE wont work with zmq REQ/REP sockets:
     * they require a reply
     * better to use XREQ/XREP
     * </pre>
     */
    public static final int NONE_VALUE = 0;
    /**
     * <code>ON_RECEPTION = 1;</code>
     */
    public static final int ON_RECEPTION_VALUE = 1;
    /**
     * <code>ON_QUEUED = 2;</code>
     */
    public static final int ON_QUEUED_VALUE = 2;
    /**
     * <code>ON_COMPLETION = 4;</code>
     */
    public static final int ON_COMPLETION_VALUE = 4;
    /**
     * <code>ALL_STEPS = 255;</code>
     */
    public static final int ALL_STEPS_VALUE = 255;


    public final int getNumber() { return value; }

    public static ReplyType valueOf(int value) {
      switch (value) {
        case 0: return NONE;
        case 1: return ON_RECEPTION;
        case 2: return ON_QUEUED;
        case 4: return ON_COMPLETION;
        case 255: return ALL_STEPS;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<ReplyType>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<ReplyType>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<ReplyType>() {
            public ReplyType findValueByNumber(int number) {
              return ReplyType.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return pb.Types.getDescriptor().getEnumTypes().get(11);
    }

    private static final ReplyType[] VALUES = values();

    public static ReplyType valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new java.lang.IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private ReplyType(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:pb.ReplyType)
  }

  /**
   * Protobuf enum {@code pb.ServiceType}
   *
   * <pre>
   * services exported by various entities
   * </pre>
   */
  public enum ServiceType
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>ST_LOGGING = 1;</code>
     */
    ST_LOGGING(0, 1),
    /**
     * <code>ST_CONFIG = 2;</code>
     */
    ST_CONFIG(1, 2),
    /**
     * <code>ST_REDIS = 3;</code>
     */
    ST_REDIS(2, 3),
    /**
     * <code>ST_HTTP = 4;</code>
     */
    ST_HTTP(3, 4),
    /**
     * <code>ST_HTTPS = 5;</code>
     */
    ST_HTTPS(4, 5),
    /**
     * <code>ST_WEBSOCKET = 6;</code>
     */
    ST_WEBSOCKET(5, 6),
    /**
     * <code>ST_WEBSOCKETS = 7;</code>
     */
    ST_WEBSOCKETS(6, 7),
    /**
     * <code>ST_RTAPI_COMMAND = 8;</code>
     */
    ST_RTAPI_COMMAND(7, 8),
    /**
     * <code>ST_STP_HALGROUP = 9;</code>
     */
    ST_STP_HALGROUP(8, 9),
    /**
     * <code>ST_STP_HALRCOMP = 10;</code>
     */
    ST_STP_HALRCOMP(9, 10),
    /**
     * <code>ST_STP_INTERP = 11;</code>
     */
    ST_STP_INTERP(10, 11),
    /**
     * <code>ST_STP_TASK = 12;</code>
     */
    ST_STP_TASK(11, 12),
    /**
     * <code>ST_HAL_RCOMMAND = 13;</code>
     */
    ST_HAL_RCOMMAND(12, 13),
    /**
     * <code>ST_TASK_COMMAND = 14;</code>
     */
    ST_TASK_COMMAND(13, 14),
    /**
     * <code>ST_INTERP_COMMAND = 15;</code>
     */
    ST_INTERP_COMMAND(14, 15),
    /**
     * <code>ST_MESSAGEBUS_COMMAND = 16;</code>
     */
    ST_MESSAGEBUS_COMMAND(15, 16),
    /**
     * <code>ST_MESSAGEBUS_RESPONSE = 17;</code>
     */
    ST_MESSAGEBUS_RESPONSE(16, 17),
    ;

    /**
     * <code>ST_LOGGING = 1;</code>
     */
    public static final int ST_LOGGING_VALUE = 1;
    /**
     * <code>ST_CONFIG = 2;</code>
     */
    public static final int ST_CONFIG_VALUE = 2;
    /**
     * <code>ST_REDIS = 3;</code>
     */
    public static final int ST_REDIS_VALUE = 3;
    /**
     * <code>ST_HTTP = 4;</code>
     */
    public static final int ST_HTTP_VALUE = 4;
    /**
     * <code>ST_HTTPS = 5;</code>
     */
    public static final int ST_HTTPS_VALUE = 5;
    /**
     * <code>ST_WEBSOCKET = 6;</code>
     */
    public static final int ST_WEBSOCKET_VALUE = 6;
    /**
     * <code>ST_WEBSOCKETS = 7;</code>
     */
    public static final int ST_WEBSOCKETS_VALUE = 7;
    /**
     * <code>ST_RTAPI_COMMAND = 8;</code>
     */
    public static final int ST_RTAPI_COMMAND_VALUE = 8;
    /**
     * <code>ST_STP_HALGROUP = 9;</code>
     */
    public static final int ST_STP_HALGROUP_VALUE = 9;
    /**
     * <code>ST_STP_HALRCOMP = 10;</code>
     */
    public static final int ST_STP_HALRCOMP_VALUE = 10;
    /**
     * <code>ST_STP_INTERP = 11;</code>
     */
    public static final int ST_STP_INTERP_VALUE = 11;
    /**
     * <code>ST_STP_TASK = 12;</code>
     */
    public static final int ST_STP_TASK_VALUE = 12;
    /**
     * <code>ST_HAL_RCOMMAND = 13;</code>
     */
    public static final int ST_HAL_RCOMMAND_VALUE = 13;
    /**
     * <code>ST_TASK_COMMAND = 14;</code>
     */
    public static final int ST_TASK_COMMAND_VALUE = 14;
    /**
     * <code>ST_INTERP_COMMAND = 15;</code>
     */
    public static final int ST_INTERP_COMMAND_VALUE = 15;
    /**
     * <code>ST_MESSAGEBUS_COMMAND = 16;</code>
     */
    public static final int ST_MESSAGEBUS_COMMAND_VALUE = 16;
    /**
     * <code>ST_MESSAGEBUS_RESPONSE = 17;</code>
     */
    public static final int ST_MESSAGEBUS_RESPONSE_VALUE = 17;


    public final int getNumber() { return value; }

    public static ServiceType valueOf(int value) {
      switch (value) {
        case 1: return ST_LOGGING;
        case 2: return ST_CONFIG;
        case 3: return ST_REDIS;
        case 4: return ST_HTTP;
        case 5: return ST_HTTPS;
        case 6: return ST_WEBSOCKET;
        case 7: return ST_WEBSOCKETS;
        case 8: return ST_RTAPI_COMMAND;
        case 9: return ST_STP_HALGROUP;
        case 10: return ST_STP_HALRCOMP;
        case 11: return ST_STP_INTERP;
        case 12: return ST_STP_TASK;
        case 13: return ST_HAL_RCOMMAND;
        case 14: return ST_TASK_COMMAND;
        case 15: return ST_INTERP_COMMAND;
        case 16: return ST_MESSAGEBUS_COMMAND;
        case 17: return ST_MESSAGEBUS_RESPONSE;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<ServiceType>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<ServiceType>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<ServiceType>() {
            public ServiceType findValueByNumber(int number) {
              return ServiceType.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return pb.Types.getDescriptor().getEnumTypes().get(12);
    }

    private static final ServiceType[] VALUES = values();

    public static ServiceType valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new java.lang.IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private ServiceType(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:pb.ServiceType)
  }

  /**
   * Protobuf enum {@code pb.ServiceAPI}
   */
  public enum ServiceAPI
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>SA_ZMQ_PROTOBUF = 1;</code>
     */
    SA_ZMQ_PROTOBUF(0, 1),
    /**
     * <code>SA_WS_JSON = 2;</code>
     */
    SA_WS_JSON(1, 2),
    ;

    /**
     * <code>SA_ZMQ_PROTOBUF = 1;</code>
     */
    public static final int SA_ZMQ_PROTOBUF_VALUE = 1;
    /**
     * <code>SA_WS_JSON = 2;</code>
     */
    public static final int SA_WS_JSON_VALUE = 2;


    public final int getNumber() { return value; }

    public static ServiceAPI valueOf(int value) {
      switch (value) {
        case 1: return SA_ZMQ_PROTOBUF;
        case 2: return SA_WS_JSON;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<ServiceAPI>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<ServiceAPI>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<ServiceAPI>() {
            public ServiceAPI findValueByNumber(int number) {
              return ServiceAPI.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return pb.Types.getDescriptor().getEnumTypes().get(13);
    }

    private static final ServiceAPI[] VALUES = values();

    public static ServiceAPI valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new java.lang.IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private ServiceAPI(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:pb.ServiceAPI)
  }

  /**
   * Protobuf enum {@code pb.ContainerType}
   */
  public enum ContainerType
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>MT_RTMESSAGE = 2;</code>
     */
    MT_RTMESSAGE(0, 2),
    /**
     * <code>MT_MOTCMD = 3;</code>
     */
    MT_MOTCMD(1, 3),
    /**
     * <code>MT_MOTSTATUS = 4;</code>
     */
    MT_MOTSTATUS(2, 4),
    /**
     * <code>MT_LEGACY_MOTCMD = 5;</code>
     */
    MT_LEGACY_MOTCMD(3, 5),
    /**
     * <code>MT_LEGACY_MOTSTATUS = 6;</code>
     */
    MT_LEGACY_MOTSTATUS(4, 6),
    /**
     * <code>MT_WOU = 7;</code>
     */
    MT_WOU(5, 7),
    /**
     * <code>MT_HALUPDATE = 8;</code>
     */
    MT_HALUPDATE(6, 8),
    /**
     * <code>MT_RTAPI_MESSAGE = 9;</code>
     */
    MT_RTAPI_MESSAGE(7, 9),
    /**
     * <code>MT_LOG_MESSAGE = 10;</code>
     */
    MT_LOG_MESSAGE(8, 10),
    /**
     * <code>MT_PREVIEW = 11;</code>
     */
    MT_PREVIEW(9, 11),
    /**
     * <code>MT_PROGRESS = 12;</code>
     */
    MT_PROGRESS(10, 12),
    /**
     * <code>MT_INTERP_STAT = 13;</code>
     */
    MT_INTERP_STAT(11, 13),
    /**
     * <code>MT_SYSLOG = 18;</code>
     */
    MT_SYSLOG(12, 18),
    /**
     * <code>MT_LEGACY_NML = 19;</code>
     */
    MT_LEGACY_NML(13, 19),
    /**
     * <code>MT_LEGACY_MOTCONFIG = 20;</code>
     */
    MT_LEGACY_MOTCONFIG(14, 20),
    /**
     * <code>MT_STP_UPDATE_FULL = 26;</code>
     *
     * <pre>
     *    MT_HALUPDATE_FULL  = 25;
     * </pre>
     */
    MT_STP_UPDATE_FULL(15, 26),
    /**
     * <code>MT_STP_UPDATE = 28;</code>
     */
    MT_STP_UPDATE(16, 28),
    /**
     * <code>MT_STP_NOGROUP = 27;</code>
     */
    MT_STP_NOGROUP(17, 27),
    /**
     * <code>MT_SHUTDOWN = 45;</code>
     *
     * <pre>
     * MT_OFFER          = 30;
     * MT_CONFIRM_OFFER  = 35;
     * MT_DISPLAY_MESSAGE = 40;
     * </pre>
     */
    MT_SHUTDOWN(18, 45),
    /**
     * <code>MT_CONFIRM_SHUTDOWN = 50;</code>
     */
    MT_CONFIRM_SHUTDOWN(19, 50),
    /**
     * <code>MT_RTMESSAGE0 = 30;</code>
     *
     * <pre>
     * identification of individual RTMessage submessages
     * field Container.rtmessage
     * </pre>
     */
    MT_RTMESSAGE0(20, 30),
    /**
     * <code>MT_RTMESSAGE1 = 31;</code>
     */
    MT_RTMESSAGE1(21, 31),
    /**
     * <code>MT_RTMESSAGE2 = 32;</code>
     */
    MT_RTMESSAGE2(22, 32),
    /**
     * <code>MT_RTMESSAGE3 = 33;</code>
     */
    MT_RTMESSAGE3(23, 33),
    /**
     * <code>MT_RTMESSAGE4 = 34;</code>
     */
    MT_RTMESSAGE4(24, 34),
    /**
     * <code>MT_ASCII = 100;</code>
     */
    MT_ASCII(25, 100),
    /**
     * <code>MT_UNICODE = 101;</code>
     */
    MT_UNICODE(26, 101),
    /**
     * <code>MT_GCODE = 102;</code>
     */
    MT_GCODE(27, 102),
    /**
     * <code>MT_PYTHON = 103;</code>
     */
    MT_PYTHON(28, 103),
    /**
     * <code>MT_PICKLE = 104;</code>
     */
    MT_PICKLE(29, 104),
    /**
     * <code>MT_TCL = 105;</code>
     */
    MT_TCL(30, 105),
    /**
     * <code>MT_XML = 106;</code>
     */
    MT_XML(31, 106),
    /**
     * <code>MT_JSON = 107;</code>
     */
    MT_JSON(32, 107),
    /**
     * <code>MT_JPEG = 108;</code>
     */
    MT_JPEG(33, 108),
    /**
     * <code>MT_PNG = 109;</code>
     */
    MT_PNG(34, 109),
    /**
     * <code>MT_TIFF = 110;</code>
     */
    MT_TIFF(35, 110),
    /**
     * <code>MT_POSTSCRIPT = 111;</code>
     */
    MT_POSTSCRIPT(36, 111),
    /**
     * <code>MT_SVG = 112;</code>
     */
    MT_SVG(37, 112),
    /**
     * <code>MT_ZMQ_SUBSCRIBE = 150;</code>
     */
    MT_ZMQ_SUBSCRIBE(38, 150),
    /**
     * <code>MT_ZMQ_UNSUBSCRIBE = 151;</code>
     */
    MT_ZMQ_UNSUBSCRIBE(39, 151),
    /**
     * <code>MT_PING = 210;</code>
     *
     * <pre>
     * keepalive test
     * </pre>
     */
    MT_PING(40, 210),
    /**
     * <code>MT_PING_ACKNOWLEDGE = 215;</code>
     */
    MT_PING_ACKNOWLEDGE(41, 215),
    /**
     * <code>MT_REJECT = 220;</code>
     */
    MT_REJECT(42, 220),
    /**
     * <code>MT_DONE = 240;</code>
     */
    MT_DONE(43, 240),
    /**
     * <code>MT_SERVICE_REQUEST = 250;</code>
     *
     * <pre>
     * ask for a specific list of services as specified in a ServiceRequest
     * </pre>
     */
    MT_SERVICE_REQUEST(44, 250),
    /**
     * <code>MT_SERVICE_ANNOUNCEMENT = 251;</code>
     *
     * <pre>
     * respond to the above with one or several ServiceDescription messages
     * </pre>
     */
    MT_SERVICE_ANNOUNCEMENT(45, 251),
    /**
     * <code>MT_SERVICE_PROBE = 252;</code>
     *
     * <pre>
     * query for all available services
     * </pre>
     */
    MT_SERVICE_PROBE(46, 252),
    /**
     * <code>MT_MESSAGEBUS_NO_DESTINATION = 255;</code>
     *
     * <pre>
     * error message generated by messagebus
     * also fills in note, destinaton
     * </pre>
     */
    MT_MESSAGEBUS_NO_DESTINATION(47, 255),
    /**
     * <code>MT_HALRCOMP_BIND = 256;</code>
     *
     * <pre>
     * rcomp creation and binding
     * </pre>
     */
    MT_HALRCOMP_BIND(48, 256),
    /**
     * <code>MT_HALRCOMP_BIND_CONFIRM = 257;</code>
     */
    MT_HALRCOMP_BIND_CONFIRM(49, 257),
    /**
     * <code>MT_HALRCOMP_BIND_REJECT = 258;</code>
     */
    MT_HALRCOMP_BIND_REJECT(50, 258),
    /**
     * <code>MT_HALRCOMP_SET = 259;</code>
     *
     * <pre>
     * the following to a similar to MT_HALRCOMMAND_SET and  MT_HALRCOMMAND_GET, except
     * in the context of HALRcomp, only pins and params are evaluated
     * also, to set a pin or param, it must have direction HAL_OUT or HAL_IO
     * </pre>
     */
    MT_HALRCOMP_SET(51, 259),
    /**
     * <code>MT_HALRCOMP_SET_REJECT = 260;</code>
     */
    MT_HALRCOMP_SET_REJECT(52, 260),
    /**
     * <code>MT_HALRCOMP_ACK = 263;</code>
     */
    MT_HALRCOMP_ACK(53, 263),
    /**
     * <code>MT_HALRCOMMAND_SET = 265;</code>
     *
     * <pre>
     * HAL object general setter/getter operations
     * these work as viewed from halcmd and include signals
     * </pre>
     */
    MT_HALRCOMMAND_SET(54, 265),
    /**
     * <code>MT_HALRCOMMAND_SET_REJECT = 266;</code>
     */
    MT_HALRCOMMAND_SET_REJECT(55, 266),
    /**
     * <code>MT_HALRCOMMAND_GET = 267;</code>
     */
    MT_HALRCOMMAND_GET(56, 267),
    /**
     * <code>MT_HALRCOMMAND_GET_REJECT = 268;</code>
     */
    MT_HALRCOMMAND_GET_REJECT(57, 268),
    /**
     * <code>MT_HALRCOMMAND_CREATE = 269;</code>
     */
    MT_HALRCOMMAND_CREATE(58, 269),
    /**
     * <code>MT_HALRCOMMAND_CREATE_REJECT = 270;</code>
     */
    MT_HALRCOMMAND_CREATE_REJECT(59, 270),
    /**
     * <code>MT_HALRCOMMAND_DELETE = 271;</code>
     */
    MT_HALRCOMMAND_DELETE(60, 271),
    /**
     * <code>MT_HALRCOMMAND_DELETE_REJECT = 272;</code>
     */
    MT_HALRCOMMAND_DELETE_REJECT(61, 272),
    /**
     * <code>MT_HALRCOMMAND_ACK = 273;</code>
     */
    MT_HALRCOMMAND_ACK(62, 273),
    /**
     * <code>MT_HALRCOMMAND_ERROR = 274;</code>
     */
    MT_HALRCOMMAND_ERROR(63, 274),
    /**
     * <code>MT_HALRCOMMAND_DESCRIBE = 276;</code>
     *
     * <pre>
     * introspection request
     * </pre>
     */
    MT_HALRCOMMAND_DESCRIBE(64, 276),
    /**
     * <code>MT_HALRCOMMAND_DESCRIPTION = 277;</code>
     *
     * <pre>
     * full HAL description 
     * </pre>
     */
    MT_HALRCOMMAND_DESCRIPTION(65, 277),
    /**
     * <code>MT_HALRCOMP_FULL_UPDATE = 288;</code>
     *
     * <pre>
     * rcomp tracking
     * </pre>
     */
    MT_HALRCOMP_FULL_UPDATE(66, 288),
    /**
     * <code>MT_HALRCOMP_INCREMENTAL_UPDATE = 289;</code>
     */
    MT_HALRCOMP_INCREMENTAL_UPDATE(67, 289),
    /**
     * <code>MT_HALRCOMP_ERROR = 290;</code>
     */
    MT_HALRCOMP_ERROR(68, 290),
    /**
     * <code>MT_HALGROUP_BIND = 294;</code>
     *
     * <pre>
     * group creation and binding
     * </pre>
     */
    MT_HALGROUP_BIND(69, 294),
    /**
     * <code>MT_HALGROUP_BIND_CONFIRM = 295;</code>
     */
    MT_HALGROUP_BIND_CONFIRM(70, 295),
    /**
     * <code>MT_HALGROUP_BIND_REJECT = 296;</code>
     */
    MT_HALGROUP_BIND_REJECT(71, 296),
    /**
     * <code>MT_HALGROUP_FULL_UPDATE = 297;</code>
     *
     * <pre>
     * group tracking
     * </pre>
     */
    MT_HALGROUP_FULL_UPDATE(72, 297),
    /**
     * <code>MT_HALGROUP_INCREMENTAL_UPDATE = 298;</code>
     */
    MT_HALGROUP_INCREMENTAL_UPDATE(73, 298),
    /**
     * <code>MT_HALGROUP_ERROR = 299;</code>
     */
    MT_HALGROUP_ERROR(74, 299),
    /**
     * <code>MT_RTAPI_APP_EXIT = 300;</code>
     *
     * <pre>
     * rtapi_app commands from halcmd:
     * </pre>
     */
    MT_RTAPI_APP_EXIT(75, 300),
    /**
     * <code>MT_RTAPI_APP_PING = 301;</code>
     */
    MT_RTAPI_APP_PING(76, 301),
    /**
     * <code>MT_RTAPI_APP_LOADRT = 302;</code>
     */
    MT_RTAPI_APP_LOADRT(77, 302),
    /**
     * <code>MT_RTAPI_APP_LOG = 303;</code>
     */
    MT_RTAPI_APP_LOG(78, 303),
    /**
     * <code>MT_RTAPI_APP_UNLOADRT = 305;</code>
     */
    MT_RTAPI_APP_UNLOADRT(79, 305),
    /**
     * <code>MT_RTAPI_APP_NEWINST = 306;</code>
     */
    MT_RTAPI_APP_NEWINST(80, 306),
    /**
     * <code>MT_RTAPI_APP_NEWTHREAD = 307;</code>
     */
    MT_RTAPI_APP_NEWTHREAD(81, 307),
    /**
     * <code>MT_RTAPI_APP_DELTHREAD = 308;</code>
     */
    MT_RTAPI_APP_DELTHREAD(82, 308),
    /**
     * <code>MT_RTAPI_APP_CALLFUNC = 309;</code>
     */
    MT_RTAPI_APP_CALLFUNC(83, 309),
    /**
     * <code>MT_RTAPI_APP_REPLY = 310;</code>
     */
    MT_RTAPI_APP_REPLY(84, 310),
    /**
     * <code>MT_RTAPI_APP_DELINST = 311;</code>
     */
    MT_RTAPI_APP_DELINST(85, 311),
    /**
     * <code>MT_LIST_APPLICATIONS = 350;</code>
     *
     * <pre>
     * application discovery
     * </pre>
     */
    MT_LIST_APPLICATIONS(86, 350),
    /**
     * <code>MT_DESCRIBE_APPLICATION = 351;</code>
     *
     * <pre>
     * this is answered with a MT_DESCRIBE_APPLICATION type
     * and repeated field apps
     * (see message Application)
     * </pre>
     */
    MT_DESCRIBE_APPLICATION(87, 351),
    /**
     * <code>MT_RETRIEVE_APPLICATION = 352;</code>
     */
    MT_RETRIEVE_APPLICATION(88, 352),
    /**
     * <code>MT_APPLICATION_DETAIL = 353;</code>
     *
     * <pre>
     * this is answered with a MT_APPLICATION_DETAIL type and
     * a single field apps
     * BUT all files and config items are attached in the
     * message Application
     * </pre>
     */
    MT_APPLICATION_DETAIL(89, 353),
    /**
     * <code>MT_ERROR = 360;</code>
     *
     * <pre>
     * generic error reply. note field contains explanation.
     * </pre>
     */
    MT_ERROR(90, 360),
    /**
     * <code>MT_TASK_REPLY = 400;</code>
     *
     * <pre>
     * task/client comms
     * </pre>
     */
    MT_TASK_REPLY(91, 400),
    /**
     * <code>MT_TICKET_UPDATE = 401;</code>
     */
    MT_TICKET_UPDATE(92, 401),
    /**
     * <code>MT_CREDIT_UPDATE = 450;</code>
     *
     * <pre>
     * credit-based flow control for queues
     * </pre>
     */
    MT_CREDIT_UPDATE(93, 450),
    /**
     * <code>MT_EMCMOT_LOWER = 1000;</code>
     *
     * <pre>
     * adjust this to be below lowest motion message type
     * </pre>
     */
    MT_EMCMOT_LOWER(94, 1000),
    /**
     * <code>MT_EMCMOT_UPPER = 1100;</code>
     *
     * <pre>
     * adjust this to be above highest motion message type
     * </pre>
     */
    MT_EMCMOT_UPPER(95, 1100),
    /**
     * <code>MT_EMCMOT_ABORT = 1001;</code>
     *
     * <pre>
     * --- snip ---
     * </pre>
     */
    MT_EMCMOT_ABORT(96, 1001),
    /**
     * <code>MT_EMCMOT_AXIS_ABORT = 1002;</code>
     */
    MT_EMCMOT_AXIS_ABORT(97, 1002),
    /**
     * <code>MT_EMCMOT_ENABLE = 1003;</code>
     */
    MT_EMCMOT_ENABLE(98, 1003),
    /**
     * <code>MT_EMCMOT_DISABLE = 1004;</code>
     */
    MT_EMCMOT_DISABLE(99, 1004),
    /**
     * <code>MT_EMCMOT_ENABLE_AMPLIFIER = 1005;</code>
     */
    MT_EMCMOT_ENABLE_AMPLIFIER(100, 1005),
    /**
     * <code>MT_EMCMOT_DISABLE_AMPLIFIER = 1006;</code>
     */
    MT_EMCMOT_DISABLE_AMPLIFIER(101, 1006),
    /**
     * <code>MT_EMCMOT_ENABLE_WATCHDOG = 1007;</code>
     */
    MT_EMCMOT_ENABLE_WATCHDOG(102, 1007),
    /**
     * <code>MT_EMCMOT_DISABLE_WATCHDOG = 1008;</code>
     */
    MT_EMCMOT_DISABLE_WATCHDOG(103, 1008),
    /**
     * <code>MT_EMCMOT_ACTIVATE_JOINT = 1009;</code>
     */
    MT_EMCMOT_ACTIVATE_JOINT(104, 1009),
    /**
     * <code>MT_EMCMOT_DEACTIVATE_JOINT = 1010;</code>
     */
    MT_EMCMOT_DEACTIVATE_JOINT(105, 1010),
    /**
     * <code>MT_EMCMOT_PAUSE = 1011;</code>
     */
    MT_EMCMOT_PAUSE(106, 1011),
    /**
     * <code>MT_EMCMOT_RESUME = 1012;</code>
     */
    MT_EMCMOT_RESUME(107, 1012),
    /**
     * <code>MT_EMCMOT_STEP = 1013;</code>
     */
    MT_EMCMOT_STEP(108, 1013),
    /**
     * <code>MT_EMCMOT_FREE = 1014;</code>
     */
    MT_EMCMOT_FREE(109, 1014),
    /**
     * <code>MT_EMCMOT_COORD = 1015;</code>
     */
    MT_EMCMOT_COORD(110, 1015),
    /**
     * <code>MT_EMCMOT_TELEOP = 1016;</code>
     */
    MT_EMCMOT_TELEOP(111, 1016),
    /**
     * <code>MT_EMCMOT_SPINDLE_SCALE = 1017;</code>
     */
    MT_EMCMOT_SPINDLE_SCALE(112, 1017),
    /**
     * <code>MT_EMCMOT_SS_ENABLE = 1018;</code>
     */
    MT_EMCMOT_SS_ENABLE(113, 1018),
    /**
     * <code>MT_EMCMOT_FEED_SCALE = 1019;</code>
     */
    MT_EMCMOT_FEED_SCALE(114, 1019),
    /**
     * <code>MT_EMCMOT_FS_ENABLE = 1020;</code>
     */
    MT_EMCMOT_FS_ENABLE(115, 1020),
    /**
     * <code>MT_EMCMOT_FH_ENABLE = 1021;</code>
     */
    MT_EMCMOT_FH_ENABLE(116, 1021),
    /**
     * <code>MT_EMCMOT_AF_ENABLE = 1022;</code>
     */
    MT_EMCMOT_AF_ENABLE(117, 1022),
    /**
     * <code>MT_EMCMOT_OVERRIDE_LIMITS = 1023;</code>
     */
    MT_EMCMOT_OVERRIDE_LIMITS(118, 1023),
    /**
     * <code>MT_EMCMOT_HOME = 1024;</code>
     */
    MT_EMCMOT_HOME(119, 1024),
    /**
     * <code>MT_EMCMOT_UNHOME = 1025;</code>
     */
    MT_EMCMOT_UNHOME(120, 1025),
    /**
     * <code>MT_EMCMOT_JOG_CONT = 1026;</code>
     */
    MT_EMCMOT_JOG_CONT(121, 1026),
    /**
     * <code>MT_EMCMOT_JOG_INCR = 1027;</code>
     */
    MT_EMCMOT_JOG_INCR(122, 1027),
    /**
     * <code>MT_EMCMOT_JOG_ABS = 1028;</code>
     */
    MT_EMCMOT_JOG_ABS(123, 1028),
    /**
     * <code>MT_EMCMOT_SET_LINE = 1029;</code>
     */
    MT_EMCMOT_SET_LINE(124, 1029),
    /**
     * <code>MT_EMCMOT_SET_CIRCLE = 1030;</code>
     */
    MT_EMCMOT_SET_CIRCLE(125, 1030),
    /**
     * <code>MT_EMCMOT_SET_TELEOP_VECTOR = 1031;</code>
     */
    MT_EMCMOT_SET_TELEOP_VECTOR(126, 1031),
    /**
     * <code>MT_EMCMOT_CLEAR_PROBE_FLAGS = 1032;</code>
     */
    MT_EMCMOT_CLEAR_PROBE_FLAGS(127, 1032),
    /**
     * <code>MT_EMCMOT_PROBE = 1033;</code>
     */
    MT_EMCMOT_PROBE(128, 1033),
    /**
     * <code>MT_EMCMOT_RIGID_TAP = 1034;</code>
     */
    MT_EMCMOT_RIGID_TAP(129, 1034),
    /**
     * <code>MT_EMCMOT_SET_POSITION_LIMITS = 1035;</code>
     */
    MT_EMCMOT_SET_POSITION_LIMITS(130, 1035),
    /**
     * <code>MT_EMCMOT_SET_BACKLASH = 1036;</code>
     */
    MT_EMCMOT_SET_BACKLASH(131, 1036),
    /**
     * <code>MT_EMCMOT_SET_MIN_FERROR = 1037;</code>
     */
    MT_EMCMOT_SET_MIN_FERROR(132, 1037),
    /**
     * <code>MT_EMCMOT_SET_MAX_FERROR = 1038;</code>
     */
    MT_EMCMOT_SET_MAX_FERROR(133, 1038),
    /**
     * <code>MT_EMCMOT_SET_VEL = 1039;</code>
     */
    MT_EMCMOT_SET_VEL(134, 1039),
    /**
     * <code>MT_EMCMOT_SET_VEL_LIMIT = 1040;</code>
     */
    MT_EMCMOT_SET_VEL_LIMIT(135, 1040),
    /**
     * <code>MT_EMCMOT_SET_JOINT_VEL_LIMIT = 1041;</code>
     */
    MT_EMCMOT_SET_JOINT_VEL_LIMIT(136, 1041),
    /**
     * <code>MT_EMCMOT_SET_JOINT_ACC_LIMIT = 1042;</code>
     */
    MT_EMCMOT_SET_JOINT_ACC_LIMIT(137, 1042),
    /**
     * <code>MT_EMCMOT_SET_ACC = 1043;</code>
     */
    MT_EMCMOT_SET_ACC(138, 1043),
    /**
     * <code>MT_EMCMOT_SET_TERM_COND = 1044;</code>
     */
    MT_EMCMOT_SET_TERM_COND(139, 1044),
    /**
     * <code>MT_EMCMOT_SET_NUM_AXES = 1045;</code>
     */
    MT_EMCMOT_SET_NUM_AXES(140, 1045),
    /**
     * <code>MT_EMCMOT_SET_WORLD_HOME = 1046;</code>
     */
    MT_EMCMOT_SET_WORLD_HOME(141, 1046),
    /**
     * <code>MT_EMCMOT_SET_HOMING_PARAMS = 1047;</code>
     */
    MT_EMCMOT_SET_HOMING_PARAMS(142, 1047),
    /**
     * <code>MT_EMCMOT_SET_DEBUG = 1048;</code>
     */
    MT_EMCMOT_SET_DEBUG(143, 1048),
    /**
     * <code>MT_EMCMOT_SET_DOUT = 1049;</code>
     */
    MT_EMCMOT_SET_DOUT(144, 1049),
    /**
     * <code>MT_EMCMOT_SET_AOUT = 1050;</code>
     */
    MT_EMCMOT_SET_AOUT(145, 1050),
    /**
     * <code>MT_EMCMOT_SET_SPINDLESYNC = 1051;</code>
     */
    MT_EMCMOT_SET_SPINDLESYNC(146, 1051),
    /**
     * <code>MT_EMCMOT_SPINDLE_ON = 1052;</code>
     */
    MT_EMCMOT_SPINDLE_ON(147, 1052),
    /**
     * <code>MT_EMCMOT_SPINDLE_OFF = 1053;</code>
     */
    MT_EMCMOT_SPINDLE_OFF(148, 1053),
    /**
     * <code>MT_EMCMOT_SPINDLE_INCREASE = 1054;</code>
     */
    MT_EMCMOT_SPINDLE_INCREASE(149, 1054),
    /**
     * <code>MT_EMCMOT_SPINDLE_DECREASE = 1055;</code>
     */
    MT_EMCMOT_SPINDLE_DECREASE(150, 1055),
    /**
     * <code>MT_EMCMOT_SPINDLE_BRAKE_ENGAGE = 1056;</code>
     */
    MT_EMCMOT_SPINDLE_BRAKE_ENGAGE(151, 1056),
    /**
     * <code>MT_EMCMOT_SPINDLE_BRAKE_RELEASE = 1057;</code>
     */
    MT_EMCMOT_SPINDLE_BRAKE_RELEASE(152, 1057),
    /**
     * <code>MT_EMCMOT_SET_MOTOR_OFFSET = 1058;</code>
     */
    MT_EMCMOT_SET_MOTOR_OFFSET(153, 1058),
    /**
     * <code>MT_EMCMOT_SET_JOINT_COMP = 1059;</code>
     */
    MT_EMCMOT_SET_JOINT_COMP(154, 1059),
    /**
     * <code>MT_EMCMOT_SET_OFFSET = 1060;</code>
     */
    MT_EMCMOT_SET_OFFSET(155, 1060),
    /**
     * <code>MT_EMCMOT_COMMAND_OK = 1061;</code>
     */
    MT_EMCMOT_COMMAND_OK(156, 1061),
    /**
     * <code>MT_EMCMOT_COMMAND_UNKNOWN_COMMAND = 1062;</code>
     */
    MT_EMCMOT_COMMAND_UNKNOWN_COMMAND(157, 1062),
    /**
     * <code>MT_EMCMOT_COMMAND_INVALID_COMMAND = 1063;</code>
     */
    MT_EMCMOT_COMMAND_INVALID_COMMAND(158, 1063),
    /**
     * <code>MT_EMCMOT_COMMAND_INVALID_PARAMS = 1064;</code>
     */
    MT_EMCMOT_COMMAND_INVALID_PARAMS(159, 1064),
    /**
     * <code>MT_EMCMOT_COMMAND_BAD_EXEC = 1065;</code>
     */
    MT_EMCMOT_COMMAND_BAD_EXEC(160, 1065),
    /**
     * <code>MT_EMCMOT_MOTION_DISABLED = 1066;</code>
     */
    MT_EMCMOT_MOTION_DISABLED(161, 1066),
    /**
     * <code>MT_EMCMOT_MOTION_FREE = 1067;</code>
     */
    MT_EMCMOT_MOTION_FREE(162, 1067),
    /**
     * <code>MT_EMCMOT_MOTION_TELEOP = 1068;</code>
     */
    MT_EMCMOT_MOTION_TELEOP(163, 1068),
    /**
     * <code>MT_EMCMOT_MOTION_COORD = 1069;</code>
     */
    MT_EMCMOT_MOTION_COORD(164, 1069),
    /**
     * <code>MT_EMCMOT_JOINT_FLAG = 1070;</code>
     */
    MT_EMCMOT_JOINT_FLAG(165, 1070),
    /**
     * <code>MT_EMCMOT_MOTION_FLAG = 1071;</code>
     *
     * <pre>
     * --- snip ---
     * </pre>
     */
    MT_EMCMOT_MOTION_FLAG(166, 1071),
    /**
     * <code>MT_PRU_FIRMWARE = 2048;</code>
     */
    MT_PRU_FIRMWARE(167, 2048),
    /**
     * <code>MT_MESA_5I20_FIRMWARE = 3000;</code>
     *
     * <pre>
     * Mesanet firmware types: 3000 - 3999
     * </pre>
     */
    MT_MESA_5I20_FIRMWARE(168, 3000),
    /**
     * <code>MT_BLOB = 4000;</code>
     *
     * <pre>
     * a blob of unspecified content - for temporary use during development
     * </pre>
     */
    MT_BLOB(169, 4000),
    /**
     * <code>MT_TEST1 = 5001;</code>
     *
     * <pre>
     * test message range: 5000-5100 - never used by core code
     * </pre>
     */
    MT_TEST1(170, 5001),
    /**
     * <code>MT_TEST2 = 5002;</code>
     */
    MT_TEST2(171, 5002),
    /**
     * <code>MT_TEST3 = 5003;</code>
     */
    MT_TEST3(172, 5003),
    /**
     * <code>MT_EMC_NML_LOWER = 10000;</code>
     *
     * <pre>
     * adjust this to be below lowest NML message type
     * </pre>
     */
    MT_EMC_NML_LOWER(173, 10000),
    /**
     * <code>MT_EMC_NML_UPPER = 13000;</code>
     *
     * <pre>
     * adjust this to be above highest NML message type
     * </pre>
     */
    MT_EMC_NML_UPPER(174, 13000),
    /**
     * <code>MT_EMC_OPERATOR_ERROR = 10011;</code>
     *
     * <pre>
     * --- snip ---
     * </pre>
     */
    MT_EMC_OPERATOR_ERROR(175, 10011),
    /**
     * <code>MT_EMC_OPERATOR_TEXT = 10012;</code>
     */
    MT_EMC_OPERATOR_TEXT(176, 10012),
    /**
     * <code>MT_EMC_OPERATOR_DISPLAY = 10013;</code>
     */
    MT_EMC_OPERATOR_DISPLAY(177, 10013),
    /**
     * <code>MT_EMC_NULL = 10021;</code>
     */
    MT_EMC_NULL(178, 10021),
    /**
     * <code>MT_EMC_SET_DEBUG = 10022;</code>
     */
    MT_EMC_SET_DEBUG(179, 10022),
    /**
     * <code>MT_EMC_SYSTEM_CMD = 10030;</code>
     */
    MT_EMC_SYSTEM_CMD(180, 10030),
    /**
     * <code>MT_EMC_AXIS_SET_AXIS = 10101;</code>
     */
    MT_EMC_AXIS_SET_AXIS(181, 10101),
    /**
     * <code>MT_EMC_AXIS_SET_UNITS = 10102;</code>
     */
    MT_EMC_AXIS_SET_UNITS(182, 10102),
    /**
     * <code>MT_EMC_AXIS_SET_MIN_POSITION_LIMIT = 10107;</code>
     */
    MT_EMC_AXIS_SET_MIN_POSITION_LIMIT(183, 10107),
    /**
     * <code>MT_EMC_AXIS_SET_MAX_POSITION_LIMIT = 10108;</code>
     */
    MT_EMC_AXIS_SET_MAX_POSITION_LIMIT(184, 10108),
    /**
     * <code>MT_EMC_TOOL_START_CHANGE = 1110;</code>
     */
    MT_EMC_TOOL_START_CHANGE(185, 1110),
    /**
     * <code>MT_EMC_EXEC_PLUGIN_CALL = 1112;</code>
     */
    MT_EMC_EXEC_PLUGIN_CALL(186, 1112),
    /**
     * <code>MT_EMC_IO_PLUGIN_CALL = 1113;</code>
     */
    MT_EMC_IO_PLUGIN_CALL(187, 1113),
    /**
     * <code>MT_EMC_AXIS_SET_FERROR = 10111;</code>
     */
    MT_EMC_AXIS_SET_FERROR(188, 10111),
    /**
     * <code>MT_EMC_AXIS_SET_HOMING_PARAMS = 10112;</code>
     */
    MT_EMC_AXIS_SET_HOMING_PARAMS(189, 10112),
    /**
     * <code>MT_EMC_AXIS_SET_MIN_FERROR = 10115;</code>
     */
    MT_EMC_AXIS_SET_MIN_FERROR(190, 10115),
    /**
     * <code>MT_EMC_AXIS_SET_MAX_VELOCITY = 10116;</code>
     */
    MT_EMC_AXIS_SET_MAX_VELOCITY(191, 10116),
    /**
     * <code>MT_EMC_AXIS_INIT = 10118;</code>
     */
    MT_EMC_AXIS_INIT(192, 10118),
    /**
     * <code>MT_EMC_AXIS_HALT = 10119;</code>
     */
    MT_EMC_AXIS_HALT(193, 10119),
    /**
     * <code>MT_EMC_AXIS_ABORT = 10120;</code>
     */
    MT_EMC_AXIS_ABORT(194, 10120),
    /**
     * <code>MT_EMC_AXIS_ENABLE = 10121;</code>
     */
    MT_EMC_AXIS_ENABLE(195, 10121),
    /**
     * <code>MT_EMC_AXIS_DISABLE = 10122;</code>
     */
    MT_EMC_AXIS_DISABLE(196, 10122),
    /**
     * <code>MT_EMC_AXIS_HOME = 10123;</code>
     */
    MT_EMC_AXIS_HOME(197, 10123),
    /**
     * <code>MT_EMC_AXIS_UNHOME = 10135;</code>
     */
    MT_EMC_AXIS_UNHOME(198, 10135),
    /**
     * <code>MT_EMC_AXIS_JOG = 10124;</code>
     */
    MT_EMC_AXIS_JOG(199, 10124),
    /**
     * <code>MT_EMC_AXIS_INCR_JOG = 10125;</code>
     */
    MT_EMC_AXIS_INCR_JOG(200, 10125),
    /**
     * <code>MT_EMC_AXIS_ABS_JOG = 10126;</code>
     */
    MT_EMC_AXIS_ABS_JOG(201, 10126),
    /**
     * <code>MT_EMC_AXIS_ACTIVATE = 10127;</code>
     */
    MT_EMC_AXIS_ACTIVATE(202, 10127),
    /**
     * <code>MT_EMC_AXIS_DEACTIVATE = 10128;</code>
     */
    MT_EMC_AXIS_DEACTIVATE(203, 10128),
    /**
     * <code>MT_EMC_AXIS_OVERRIDE_LIMITS = 10129;</code>
     */
    MT_EMC_AXIS_OVERRIDE_LIMITS(204, 10129),
    /**
     * <code>MT_EMC_AXIS_LOAD_COMP = 10131;</code>
     */
    MT_EMC_AXIS_LOAD_COMP(205, 10131),
    /**
     * <code>MT_EMC_AXIS_SET_BACKLASH = 10134;</code>
     */
    MT_EMC_AXIS_SET_BACKLASH(206, 10134),
    /**
     * <code>MT_EMC_AXIS_STAT = 10199;</code>
     */
    MT_EMC_AXIS_STAT(207, 10199),
    /**
     * <code>MT_EMC_TRAJ_SET_AXES = 10201;</code>
     */
    MT_EMC_TRAJ_SET_AXES(208, 10201),
    /**
     * <code>MT_EMC_TRAJ_SET_UNITS = 10202;</code>
     */
    MT_EMC_TRAJ_SET_UNITS(209, 10202),
    /**
     * <code>MT_EMC_TRAJ_SET_CYCLE_TIME = 10203;</code>
     */
    MT_EMC_TRAJ_SET_CYCLE_TIME(210, 10203),
    /**
     * <code>MT_EMC_TRAJ_SET_MODE = 10204;</code>
     */
    MT_EMC_TRAJ_SET_MODE(211, 10204),
    /**
     * <code>MT_EMC_TRAJ_SET_VELOCITY = 10205;</code>
     */
    MT_EMC_TRAJ_SET_VELOCITY(212, 10205),
    /**
     * <code>MT_EMC_TRAJ_SET_ACCELERATION = 10206;</code>
     */
    MT_EMC_TRAJ_SET_ACCELERATION(213, 10206),
    /**
     * <code>MT_EMC_TRAJ_SET_MAX_VELOCITY = 10207;</code>
     */
    MT_EMC_TRAJ_SET_MAX_VELOCITY(214, 10207),
    /**
     * <code>MT_EMC_TRAJ_SET_MAX_ACCELERATION = 10208;</code>
     */
    MT_EMC_TRAJ_SET_MAX_ACCELERATION(215, 10208),
    /**
     * <code>MT_EMC_TRAJ_SET_SCALE = 10209;</code>
     */
    MT_EMC_TRAJ_SET_SCALE(216, 10209),
    /**
     * <code>MT_EMC_TRAJ_SET_MOTION_ID = 10210;</code>
     */
    MT_EMC_TRAJ_SET_MOTION_ID(217, 10210),
    /**
     * <code>MT_EMC_TRAJ_INIT = 10211;</code>
     */
    MT_EMC_TRAJ_INIT(218, 10211),
    /**
     * <code>MT_EMC_TRAJ_HALT = 10212;</code>
     */
    MT_EMC_TRAJ_HALT(219, 10212),
    /**
     * <code>MT_EMC_TRAJ_ENABLE = 10213;</code>
     */
    MT_EMC_TRAJ_ENABLE(220, 10213),
    /**
     * <code>MT_EMC_TRAJ_DISABLE = 10214;</code>
     */
    MT_EMC_TRAJ_DISABLE(221, 10214),
    /**
     * <code>MT_EMC_TRAJ_ABORT = 10215;</code>
     */
    MT_EMC_TRAJ_ABORT(222, 10215),
    /**
     * <code>MT_EMC_TRAJ_PAUSE = 10216;</code>
     */
    MT_EMC_TRAJ_PAUSE(223, 10216),
    /**
     * <code>MT_EMC_TRAJ_STEP = 10217;</code>
     */
    MT_EMC_TRAJ_STEP(224, 10217),
    /**
     * <code>MT_EMC_TRAJ_RESUME = 10218;</code>
     */
    MT_EMC_TRAJ_RESUME(225, 10218),
    /**
     * <code>MT_EMC_TRAJ_DELAY = 10219;</code>
     */
    MT_EMC_TRAJ_DELAY(226, 10219),
    /**
     * <code>MT_EMC_TRAJ_LINEAR_MOVE = 10220;</code>
     */
    MT_EMC_TRAJ_LINEAR_MOVE(227, 10220),
    /**
     * <code>MT_EMC_TRAJ_CIRCULAR_MOVE = 10221;</code>
     */
    MT_EMC_TRAJ_CIRCULAR_MOVE(228, 10221),
    /**
     * <code>MT_EMC_TRAJ_SET_TERM_COND = 10222;</code>
     */
    MT_EMC_TRAJ_SET_TERM_COND(229, 10222),
    /**
     * <code>MT_EMC_TRAJ_SET_OFFSET = 10223;</code>
     */
    MT_EMC_TRAJ_SET_OFFSET(230, 10223),
    /**
     * <code>MT_EMC_TRAJ_SET_G5X = 10224;</code>
     */
    MT_EMC_TRAJ_SET_G5X(231, 10224),
    /**
     * <code>MT_EMC_TRAJ_SET_HOME = 10225;</code>
     */
    MT_EMC_TRAJ_SET_HOME(232, 10225),
    /**
     * <code>MT_EMC_TRAJ_SET_ROTATION = 10226;</code>
     */
    MT_EMC_TRAJ_SET_ROTATION(233, 10226),
    /**
     * <code>MT_EMC_TRAJ_SET_G92 = 10227;</code>
     */
    MT_EMC_TRAJ_SET_G92(234, 10227),
    /**
     * <code>MT_EMC_TRAJ_CLEAR_PROBE_TRIPPED_FLAG = 10228;</code>
     */
    MT_EMC_TRAJ_CLEAR_PROBE_TRIPPED_FLAG(235, 10228),
    /**
     * <code>MT_EMC_TRAJ_PROBE = 10229;</code>
     */
    MT_EMC_TRAJ_PROBE(236, 10229),
    /**
     * <code>MT_EMC_TRAJ_SET_TELEOP_ENABLE = 10230;</code>
     */
    MT_EMC_TRAJ_SET_TELEOP_ENABLE(237, 10230),
    /**
     * <code>MT_EMC_TRAJ_SET_TELEOP_VECTOR = 10231;</code>
     */
    MT_EMC_TRAJ_SET_TELEOP_VECTOR(238, 10231),
    /**
     * <code>MT_EMC_TRAJ_SET_SPINDLESYNC = 10232;</code>
     */
    MT_EMC_TRAJ_SET_SPINDLESYNC(239, 10232),
    /**
     * <code>MT_EMC_TRAJ_SET_SPINDLE_SCALE = 10233;</code>
     */
    MT_EMC_TRAJ_SET_SPINDLE_SCALE(240, 10233),
    /**
     * <code>MT_EMC_TRAJ_SET_FO_ENABLE = 10234;</code>
     */
    MT_EMC_TRAJ_SET_FO_ENABLE(241, 10234),
    /**
     * <code>MT_EMC_TRAJ_SET_SO_ENABLE = 10235;</code>
     */
    MT_EMC_TRAJ_SET_SO_ENABLE(242, 10235),
    /**
     * <code>MT_EMC_TRAJ_SET_FH_ENABLE = 10236;</code>
     */
    MT_EMC_TRAJ_SET_FH_ENABLE(243, 10236),
    /**
     * <code>MT_EMC_TRAJ_RIGID_TAP = 10237;</code>
     */
    MT_EMC_TRAJ_RIGID_TAP(244, 10237),
    /**
     * <code>MT_EMC_TRAJ_STAT = 10299;</code>
     */
    MT_EMC_TRAJ_STAT(245, 10299),
    /**
     * <code>MT_EMC_MOTION_INIT = 10301;</code>
     */
    MT_EMC_MOTION_INIT(246, 10301),
    /**
     * <code>MT_EMC_MOTION_HALT = 10302;</code>
     */
    MT_EMC_MOTION_HALT(247, 10302),
    /**
     * <code>MT_EMC_MOTION_ABORT = 10303;</code>
     */
    MT_EMC_MOTION_ABORT(248, 10303),
    /**
     * <code>MT_EMC_MOTION_SET_AOUT = 10304;</code>
     */
    MT_EMC_MOTION_SET_AOUT(249, 10304),
    /**
     * <code>MT_EMC_MOTION_SET_DOUT = 10305;</code>
     */
    MT_EMC_MOTION_SET_DOUT(250, 10305),
    /**
     * <code>MT_EMC_MOTION_ADAPTIVE = 10306;</code>
     */
    MT_EMC_MOTION_ADAPTIVE(251, 10306),
    /**
     * <code>MT_EMC_SPINDLE_ORIENT = 10317;</code>
     */
    MT_EMC_SPINDLE_ORIENT(252, 10317),
    /**
     * <code>MT_EMC_SPINDLE_WAIT_ORIENT_COMPLETE = 10318;</code>
     */
    MT_EMC_SPINDLE_WAIT_ORIENT_COMPLETE(253, 10318),
    /**
     * <code>MT_EMC_MOTION_STAT = 10399;</code>
     */
    MT_EMC_MOTION_STAT(254, 10399),
    /**
     * <code>MT_EMC_TASK_INIT = 10501;</code>
     */
    MT_EMC_TASK_INIT(255, 10501),
    /**
     * <code>MT_EMC_TASK_HALT = 10502;</code>
     */
    MT_EMC_TASK_HALT(256, 10502),
    /**
     * <code>MT_EMC_TASK_ABORT = 10503;</code>
     */
    MT_EMC_TASK_ABORT(257, 10503),
    /**
     * <code>MT_EMC_TASK_SET_MODE = 10504;</code>
     */
    MT_EMC_TASK_SET_MODE(258, 10504),
    /**
     * <code>MT_EMC_TASK_SET_STATE = 10505;</code>
     */
    MT_EMC_TASK_SET_STATE(259, 10505),
    /**
     * <code>MT_EMC_TASK_PLAN_OPEN = 10506;</code>
     */
    MT_EMC_TASK_PLAN_OPEN(260, 10506),
    /**
     * <code>MT_EMC_TASK_PLAN_RUN = 10507;</code>
     */
    MT_EMC_TASK_PLAN_RUN(261, 10507),
    /**
     * <code>MT_EMC_TASK_PLAN_READ = 10508;</code>
     */
    MT_EMC_TASK_PLAN_READ(262, 10508),
    /**
     * <code>MT_EMC_TASK_PLAN_EXECUTE = 10509;</code>
     */
    MT_EMC_TASK_PLAN_EXECUTE(263, 10509),
    /**
     * <code>MT_EMC_TASK_PLAN_PAUSE = 10510;</code>
     */
    MT_EMC_TASK_PLAN_PAUSE(264, 10510),
    /**
     * <code>MT_EMC_TASK_PLAN_STEP = 10511;</code>
     */
    MT_EMC_TASK_PLAN_STEP(265, 10511),
    /**
     * <code>MT_EMC_TASK_PLAN_RESUME = 10512;</code>
     */
    MT_EMC_TASK_PLAN_RESUME(266, 10512),
    /**
     * <code>MT_EMC_TASK_PLAN_END = 10513;</code>
     */
    MT_EMC_TASK_PLAN_END(267, 10513),
    /**
     * <code>MT_EMC_TASK_PLAN_CLOSE = 10514;</code>
     */
    MT_EMC_TASK_PLAN_CLOSE(268, 10514),
    /**
     * <code>MT_EMC_TASK_PLAN_INIT = 10515;</code>
     */
    MT_EMC_TASK_PLAN_INIT(269, 10515),
    /**
     * <code>MT_EMC_TASK_PLAN_SYNCH = 10516;</code>
     */
    MT_EMC_TASK_PLAN_SYNCH(270, 10516),
    /**
     * <code>MT_EMC_TASK_PLAN_SET_OPTIONAL_STOP = 10517;</code>
     */
    MT_EMC_TASK_PLAN_SET_OPTIONAL_STOP(271, 10517),
    /**
     * <code>MT_EMC_TASK_PLAN_SET_BLOCK_DELETE = 10518;</code>
     */
    MT_EMC_TASK_PLAN_SET_BLOCK_DELETE(272, 10518),
    /**
     * <code>MT_EMC_TASK_PLAN_OPTIONAL_STOP = 10519;</code>
     */
    MT_EMC_TASK_PLAN_OPTIONAL_STOP(273, 10519),
    /**
     * <code>MT_EMC_TASK_PLAN_RESET = 10520;</code>
     */
    MT_EMC_TASK_PLAN_RESET(274, 10520),
    /**
     * <code>MT_EMC_TASK_PLAN_REPLY = 10530;</code>
     */
    MT_EMC_TASK_PLAN_REPLY(275, 10530),
    /**
     * <code>MT_EMC_TASK_STAT = 10599;</code>
     */
    MT_EMC_TASK_STAT(276, 10599),
    /**
     * <code>MT_EMC_TOOL_INIT = 11101;</code>
     */
    MT_EMC_TOOL_INIT(277, 11101),
    /**
     * <code>MT_EMC_TOOL_HALT = 11102;</code>
     */
    MT_EMC_TOOL_HALT(278, 11102),
    /**
     * <code>MT_EMC_TOOL_ABORT = 11103;</code>
     */
    MT_EMC_TOOL_ABORT(279, 11103),
    /**
     * <code>MT_EMC_TOOL_PREPARE = 11104;</code>
     */
    MT_EMC_TOOL_PREPARE(280, 11104),
    /**
     * <code>MT_EMC_TOOL_LOAD = 11105;</code>
     */
    MT_EMC_TOOL_LOAD(281, 11105),
    /**
     * <code>MT_EMC_TOOL_UNLOAD = 11106;</code>
     */
    MT_EMC_TOOL_UNLOAD(282, 11106),
    /**
     * <code>MT_EMC_TOOL_LOAD_TOOL_TABLE = 11107;</code>
     */
    MT_EMC_TOOL_LOAD_TOOL_TABLE(283, 11107),
    /**
     * <code>MT_EMC_TOOL_SET_OFFSET = 11108;</code>
     */
    MT_EMC_TOOL_SET_OFFSET(284, 11108),
    /**
     * <code>MT_EMC_TOOL_SET_NUMBER = 11109;</code>
     */
    MT_EMC_TOOL_SET_NUMBER(285, 11109),
    /**
     * <code>MT_EMC_TOOL_STAT = 11199;</code>
     */
    MT_EMC_TOOL_STAT(286, 11199),
    /**
     * <code>MT_EMC_AUX_ESTOP_ON = 11206;</code>
     */
    MT_EMC_AUX_ESTOP_ON(287, 11206),
    /**
     * <code>MT_EMC_AUX_ESTOP_OFF = 11207;</code>
     */
    MT_EMC_AUX_ESTOP_OFF(288, 11207),
    /**
     * <code>MT_EMC_AUX_ESTOP_RESET = 11208;</code>
     */
    MT_EMC_AUX_ESTOP_RESET(289, 11208),
    /**
     * <code>MT_EMC_AUX_INPUT_WAIT = 11209;</code>
     */
    MT_EMC_AUX_INPUT_WAIT(290, 11209),
    /**
     * <code>MT_EMC_AUX_STAT = 11299;</code>
     */
    MT_EMC_AUX_STAT(291, 11299),
    /**
     * <code>MT_EMC_SPINDLE_ON = 11304;</code>
     */
    MT_EMC_SPINDLE_ON(292, 11304),
    /**
     * <code>MT_EMC_SPINDLE_OFF = 11305;</code>
     */
    MT_EMC_SPINDLE_OFF(293, 11305),
    /**
     * <code>MT_EMC_SPINDLE_INCREASE = 11309;</code>
     */
    MT_EMC_SPINDLE_INCREASE(294, 11309),
    /**
     * <code>MT_EMC_SPINDLE_DECREASE = 11310;</code>
     */
    MT_EMC_SPINDLE_DECREASE(295, 11310),
    /**
     * <code>MT_EMC_SPINDLE_CONSTANT = 11311;</code>
     */
    MT_EMC_SPINDLE_CONSTANT(296, 11311),
    /**
     * <code>MT_EMC_SPINDLE_BRAKE_RELEASE = 11312;</code>
     */
    MT_EMC_SPINDLE_BRAKE_RELEASE(297, 11312),
    /**
     * <code>MT_EMC_SPINDLE_BRAKE_ENGAGE = 11313;</code>
     */
    MT_EMC_SPINDLE_BRAKE_ENGAGE(298, 11313),
    /**
     * <code>MT_EMC_SPINDLE_SPEED = 11316;</code>
     */
    MT_EMC_SPINDLE_SPEED(299, 11316),
    /**
     * <code>MT_EMC_SPINDLE_STAT = 11399;</code>
     */
    MT_EMC_SPINDLE_STAT(300, 11399),
    /**
     * <code>MT_EMC_COOLANT_MIST_ON = 11404;</code>
     */
    MT_EMC_COOLANT_MIST_ON(301, 11404),
    /**
     * <code>MT_EMC_COOLANT_MIST_OFF = 11405;</code>
     */
    MT_EMC_COOLANT_MIST_OFF(302, 11405),
    /**
     * <code>MT_EMC_COOLANT_FLOOD_ON = 11406;</code>
     */
    MT_EMC_COOLANT_FLOOD_ON(303, 11406),
    /**
     * <code>MT_EMC_COOLANT_FLOOD_OFF = 11407;</code>
     */
    MT_EMC_COOLANT_FLOOD_OFF(304, 11407),
    /**
     * <code>MT_EMC_COOLANT_STAT = 11499;</code>
     */
    MT_EMC_COOLANT_STAT(305, 11499),
    /**
     * <code>MT_EMC_LUBE_ON = 11504;</code>
     */
    MT_EMC_LUBE_ON(306, 11504),
    /**
     * <code>MT_EMC_LUBE_OFF = 11505;</code>
     */
    MT_EMC_LUBE_OFF(307, 11505),
    /**
     * <code>MT_EMC_LUBE_STAT = 11599;</code>
     */
    MT_EMC_LUBE_STAT(308, 11599),
    /**
     * <code>MT_EMC_IO_INIT = 11601;</code>
     */
    MT_EMC_IO_INIT(309, 11601),
    /**
     * <code>MT_EMC_IO_HALT = 11602;</code>
     */
    MT_EMC_IO_HALT(310, 11602),
    /**
     * <code>MT_EMC_IO_ABORT = 11603;</code>
     */
    MT_EMC_IO_ABORT(311, 11603),
    /**
     * <code>MT_EMC_IO_SET_CYCLE_TIME = 11604;</code>
     */
    MT_EMC_IO_SET_CYCLE_TIME(312, 11604),
    /**
     * <code>MT_EMC_IO_STAT = 11699;</code>
     */
    MT_EMC_IO_STAT(313, 11699),
    /**
     * <code>MT_EMC_INIT = 11901;</code>
     */
    MT_EMC_INIT(314, 11901),
    /**
     * <code>MT_EMC_HALT = 11902;</code>
     */
    MT_EMC_HALT(315, 11902),
    /**
     * <code>MT_EMC_ABORT = 11903;</code>
     */
    MT_EMC_ABORT(316, 11903),
    /**
     * <code>MT_EMC_STAT = 11999;</code>
     *
     * <pre>
     * --- snip ---
     * </pre>
     */
    MT_EMC_STAT(317, 11999),
    /**
     * <code>MT_EMCSTAT_FULL_UPDATE = 12500;</code>
     *
     * <pre>
     * EMC status
     * </pre>
     */
    MT_EMCSTAT_FULL_UPDATE(318, 12500),
    /**
     * <code>MT_EMCSTAT_INCREMENTAL_UPDATE = 12501;</code>
     */
    MT_EMCSTAT_INCREMENTAL_UPDATE(319, 12501),
    /**
     * <code>MT_EMC_NML_ERROR = 12510;</code>
     *
     * <pre>
     * EMC error
     * </pre>
     */
    MT_EMC_NML_ERROR(320, 12510),
    /**
     * <code>MT_EMC_NML_TEXT = 12511;</code>
     */
    MT_EMC_NML_TEXT(321, 12511),
    /**
     * <code>MT_EMC_NML_DISPLAY = 12512;</code>
     */
    MT_EMC_NML_DISPLAY(322, 12512),
    /**
     * <code>MT_EMCCMD_EXECUTED = 12520;</code>
     *
     * <pre>
     * EMC command
     * </pre>
     */
    MT_EMCCMD_EXECUTED(323, 12520),
    /**
     * <code>MT_EMCCMD_COMPLETED = 12521;</code>
     */
    MT_EMCCMD_COMPLETED(324, 12521),
    /**
     * <code>MT_LAUNCHER_FULL_UPDATE = 12600;</code>
     *
     * <pre>
     * launcher pub-sub
     * </pre>
     */
    MT_LAUNCHER_FULL_UPDATE(325, 12600),
    /**
     * <code>MT_LAUNCHER_INCREMENTAL_UPDATE = 12601;</code>
     */
    MT_LAUNCHER_INCREMENTAL_UPDATE(326, 12601),
    /**
     * <code>MT_LAUNCHER_ERROR = 12602;</code>
     */
    MT_LAUNCHER_ERROR(327, 12602),
    /**
     * <code>MT_LAUNCHER_START = 12610;</code>
     *
     * <pre>
     * launcher command
     * </pre>
     */
    MT_LAUNCHER_START(328, 12610),
    /**
     * <code>MT_LAUNCHER_TERMINATE = 12611;</code>
     */
    MT_LAUNCHER_TERMINATE(329, 12611),
    /**
     * <code>MT_LAUNCHER_KILL = 12612;</code>
     */
    MT_LAUNCHER_KILL(330, 12612),
    /**
     * <code>MT_LAUNCHER_WRITE_STDIN = 12613;</code>
     */
    MT_LAUNCHER_WRITE_STDIN(331, 12613),
    /**
     * <code>MT_LAUNCHER_CALL = 12614;</code>
     */
    MT_LAUNCHER_CALL(332, 12614),
    /**
     * <code>MT_LAUNCHER_SHUTDOWN = 12615;</code>
     */
    MT_LAUNCHER_SHUTDOWN(333, 12615),
    ;

    /**
     * <code>MT_RTMESSAGE = 2;</code>
     */
    public static final int MT_RTMESSAGE_VALUE = 2;
    /**
     * <code>MT_MOTCMD = 3;</code>
     */
    public static final int MT_MOTCMD_VALUE = 3;
    /**
     * <code>MT_MOTSTATUS = 4;</code>
     */
    public static final int MT_MOTSTATUS_VALUE = 4;
    /**
     * <code>MT_LEGACY_MOTCMD = 5;</code>
     */
    public static final int MT_LEGACY_MOTCMD_VALUE = 5;
    /**
     * <code>MT_LEGACY_MOTSTATUS = 6;</code>
     */
    public static final int MT_LEGACY_MOTSTATUS_VALUE = 6;
    /**
     * <code>MT_WOU = 7;</code>
     */
    public static final int MT_WOU_VALUE = 7;
    /**
     * <code>MT_HALUPDATE = 8;</code>
     */
    public static final int MT_HALUPDATE_VALUE = 8;
    /**
     * <code>MT_RTAPI_MESSAGE = 9;</code>
     */
    public static final int MT_RTAPI_MESSAGE_VALUE = 9;
    /**
     * <code>MT_LOG_MESSAGE = 10;</code>
     */
    public static final int MT_LOG_MESSAGE_VALUE = 10;
    /**
     * <code>MT_PREVIEW = 11;</code>
     */
    public static final int MT_PREVIEW_VALUE = 11;
    /**
     * <code>MT_PROGRESS = 12;</code>
     */
    public static final int MT_PROGRESS_VALUE = 12;
    /**
     * <code>MT_INTERP_STAT = 13;</code>
     */
    public static final int MT_INTERP_STAT_VALUE = 13;
    /**
     * <code>MT_SYSLOG = 18;</code>
     */
    public static final int MT_SYSLOG_VALUE = 18;
    /**
     * <code>MT_LEGACY_NML = 19;</code>
     */
    public static final int MT_LEGACY_NML_VALUE = 19;
    /**
     * <code>MT_LEGACY_MOTCONFIG = 20;</code>
     */
    public static final int MT_LEGACY_MOTCONFIG_VALUE = 20;
    /**
     * <code>MT_STP_UPDATE_FULL = 26;</code>
     *
     * <pre>
     *    MT_HALUPDATE_FULL  = 25;
     * </pre>
     */
    public static final int MT_STP_UPDATE_FULL_VALUE = 26;
    /**
     * <code>MT_STP_UPDATE = 28;</code>
     */
    public static final int MT_STP_UPDATE_VALUE = 28;
    /**
     * <code>MT_STP_NOGROUP = 27;</code>
     */
    public static final int MT_STP_NOGROUP_VALUE = 27;
    /**
     * <code>MT_SHUTDOWN = 45;</code>
     *
     * <pre>
     * MT_OFFER          = 30;
     * MT_CONFIRM_OFFER  = 35;
     * MT_DISPLAY_MESSAGE = 40;
     * </pre>
     */
    public static final int MT_SHUTDOWN_VALUE = 45;
    /**
     * <code>MT_CONFIRM_SHUTDOWN = 50;</code>
     */
    public static final int MT_CONFIRM_SHUTDOWN_VALUE = 50;
    /**
     * <code>MT_RTMESSAGE0 = 30;</code>
     *
     * <pre>
     * identification of individual RTMessage submessages
     * field Container.rtmessage
     * </pre>
     */
    public static final int MT_RTMESSAGE0_VALUE = 30;
    /**
     * <code>MT_RTMESSAGE1 = 31;</code>
     */
    public static final int MT_RTMESSAGE1_VALUE = 31;
    /**
     * <code>MT_RTMESSAGE2 = 32;</code>
     */
    public static final int MT_RTMESSAGE2_VALUE = 32;
    /**
     * <code>MT_RTMESSAGE3 = 33;</code>
     */
    public static final int MT_RTMESSAGE3_VALUE = 33;
    /**
     * <code>MT_RTMESSAGE4 = 34;</code>
     */
    public static final int MT_RTMESSAGE4_VALUE = 34;
    /**
     * <code>MT_ASCII = 100;</code>
     */
    public static final int MT_ASCII_VALUE = 100;
    /**
     * <code>MT_UNICODE = 101;</code>
     */
    public static final int MT_UNICODE_VALUE = 101;
    /**
     * <code>MT_GCODE = 102;</code>
     */
    public static final int MT_GCODE_VALUE = 102;
    /**
     * <code>MT_PYTHON = 103;</code>
     */
    public static final int MT_PYTHON_VALUE = 103;
    /**
     * <code>MT_PICKLE = 104;</code>
     */
    public static final int MT_PICKLE_VALUE = 104;
    /**
     * <code>MT_TCL = 105;</code>
     */
    public static final int MT_TCL_VALUE = 105;
    /**
     * <code>MT_XML = 106;</code>
     */
    public static final int MT_XML_VALUE = 106;
    /**
     * <code>MT_JSON = 107;</code>
     */
    public static final int MT_JSON_VALUE = 107;
    /**
     * <code>MT_JPEG = 108;</code>
     */
    public static final int MT_JPEG_VALUE = 108;
    /**
     * <code>MT_PNG = 109;</code>
     */
    public static final int MT_PNG_VALUE = 109;
    /**
     * <code>MT_TIFF = 110;</code>
     */
    public static final int MT_TIFF_VALUE = 110;
    /**
     * <code>MT_POSTSCRIPT = 111;</code>
     */
    public static final int MT_POSTSCRIPT_VALUE = 111;
    /**
     * <code>MT_SVG = 112;</code>
     */
    public static final int MT_SVG_VALUE = 112;
    /**
     * <code>MT_ZMQ_SUBSCRIBE = 150;</code>
     */
    public static final int MT_ZMQ_SUBSCRIBE_VALUE = 150;
    /**
     * <code>MT_ZMQ_UNSUBSCRIBE = 151;</code>
     */
    public static final int MT_ZMQ_UNSUBSCRIBE_VALUE = 151;
    /**
     * <code>MT_PING = 210;</code>
     *
     * <pre>
     * keepalive test
     * </pre>
     */
    public static final int MT_PING_VALUE = 210;
    /**
     * <code>MT_PING_ACKNOWLEDGE = 215;</code>
     */
    public static final int MT_PING_ACKNOWLEDGE_VALUE = 215;
    /**
     * <code>MT_REJECT = 220;</code>
     */
    public static final int MT_REJECT_VALUE = 220;
    /**
     * <code>MT_DONE = 240;</code>
     */
    public static final int MT_DONE_VALUE = 240;
    /**
     * <code>MT_SERVICE_REQUEST = 250;</code>
     *
     * <pre>
     * ask for a specific list of services as specified in a ServiceRequest
     * </pre>
     */
    public static final int MT_SERVICE_REQUEST_VALUE = 250;
    /**
     * <code>MT_SERVICE_ANNOUNCEMENT = 251;</code>
     *
     * <pre>
     * respond to the above with one or several ServiceDescription messages
     * </pre>
     */
    public static final int MT_SERVICE_ANNOUNCEMENT_VALUE = 251;
    /**
     * <code>MT_SERVICE_PROBE = 252;</code>
     *
     * <pre>
     * query for all available services
     * </pre>
     */
    public static final int MT_SERVICE_PROBE_VALUE = 252;
    /**
     * <code>MT_MESSAGEBUS_NO_DESTINATION = 255;</code>
     *
     * <pre>
     * error message generated by messagebus
     * also fills in note, destinaton
     * </pre>
     */
    public static final int MT_MESSAGEBUS_NO_DESTINATION_VALUE = 255;
    /**
     * <code>MT_HALRCOMP_BIND = 256;</code>
     *
     * <pre>
     * rcomp creation and binding
     * </pre>
     */
    public static final int MT_HALRCOMP_BIND_VALUE = 256;
    /**
     * <code>MT_HALRCOMP_BIND_CONFIRM = 257;</code>
     */
    public static final int MT_HALRCOMP_BIND_CONFIRM_VALUE = 257;
    /**
     * <code>MT_HALRCOMP_BIND_REJECT = 258;</code>
     */
    public static final int MT_HALRCOMP_BIND_REJECT_VALUE = 258;
    /**
     * <code>MT_HALRCOMP_SET = 259;</code>
     *
     * <pre>
     * the following to a similar to MT_HALRCOMMAND_SET and  MT_HALRCOMMAND_GET, except
     * in the context of HALRcomp, only pins and params are evaluated
     * also, to set a pin or param, it must have direction HAL_OUT or HAL_IO
     * </pre>
     */
    public static final int MT_HALRCOMP_SET_VALUE = 259;
    /**
     * <code>MT_HALRCOMP_SET_REJECT = 260;</code>
     */
    public static final int MT_HALRCOMP_SET_REJECT_VALUE = 260;
    /**
     * <code>MT_HALRCOMP_ACK = 263;</code>
     */
    public static final int MT_HALRCOMP_ACK_VALUE = 263;
    /**
     * <code>MT_HALRCOMMAND_SET = 265;</code>
     *
     * <pre>
     * HAL object general setter/getter operations
     * these work as viewed from halcmd and include signals
     * </pre>
     */
    public static final int MT_HALRCOMMAND_SET_VALUE = 265;
    /**
     * <code>MT_HALRCOMMAND_SET_REJECT = 266;</code>
     */
    public static final int MT_HALRCOMMAND_SET_REJECT_VALUE = 266;
    /**
     * <code>MT_HALRCOMMAND_GET = 267;</code>
     */
    public static final int MT_HALRCOMMAND_GET_VALUE = 267;
    /**
     * <code>MT_HALRCOMMAND_GET_REJECT = 268;</code>
     */
    public static final int MT_HALRCOMMAND_GET_REJECT_VALUE = 268;
    /**
     * <code>MT_HALRCOMMAND_CREATE = 269;</code>
     */
    public static final int MT_HALRCOMMAND_CREATE_VALUE = 269;
    /**
     * <code>MT_HALRCOMMAND_CREATE_REJECT = 270;</code>
     */
    public static final int MT_HALRCOMMAND_CREATE_REJECT_VALUE = 270;
    /**
     * <code>MT_HALRCOMMAND_DELETE = 271;</code>
     */
    public static final int MT_HALRCOMMAND_DELETE_VALUE = 271;
    /**
     * <code>MT_HALRCOMMAND_DELETE_REJECT = 272;</code>
     */
    public static final int MT_HALRCOMMAND_DELETE_REJECT_VALUE = 272;
    /**
     * <code>MT_HALRCOMMAND_ACK = 273;</code>
     */
    public static final int MT_HALRCOMMAND_ACK_VALUE = 273;
    /**
     * <code>MT_HALRCOMMAND_ERROR = 274;</code>
     */
    public static final int MT_HALRCOMMAND_ERROR_VALUE = 274;
    /**
     * <code>MT_HALRCOMMAND_DESCRIBE = 276;</code>
     *
     * <pre>
     * introspection request
     * </pre>
     */
    public static final int MT_HALRCOMMAND_DESCRIBE_VALUE = 276;
    /**
     * <code>MT_HALRCOMMAND_DESCRIPTION = 277;</code>
     *
     * <pre>
     * full HAL description 
     * </pre>
     */
    public static final int MT_HALRCOMMAND_DESCRIPTION_VALUE = 277;
    /**
     * <code>MT_HALRCOMP_FULL_UPDATE = 288;</code>
     *
     * <pre>
     * rcomp tracking
     * </pre>
     */
    public static final int MT_HALRCOMP_FULL_UPDATE_VALUE = 288;
    /**
     * <code>MT_HALRCOMP_INCREMENTAL_UPDATE = 289;</code>
     */
    public static final int MT_HALRCOMP_INCREMENTAL_UPDATE_VALUE = 289;
    /**
     * <code>MT_HALRCOMP_ERROR = 290;</code>
     */
    public static final int MT_HALRCOMP_ERROR_VALUE = 290;
    /**
     * <code>MT_HALGROUP_BIND = 294;</code>
     *
     * <pre>
     * group creation and binding
     * </pre>
     */
    public static final int MT_HALGROUP_BIND_VALUE = 294;
    /**
     * <code>MT_HALGROUP_BIND_CONFIRM = 295;</code>
     */
    public static final int MT_HALGROUP_BIND_CONFIRM_VALUE = 295;
    /**
     * <code>MT_HALGROUP_BIND_REJECT = 296;</code>
     */
    public static final int MT_HALGROUP_BIND_REJECT_VALUE = 296;
    /**
     * <code>MT_HALGROUP_FULL_UPDATE = 297;</code>
     *
     * <pre>
     * group tracking
     * </pre>
     */
    public static final int MT_HALGROUP_FULL_UPDATE_VALUE = 297;
    /**
     * <code>MT_HALGROUP_INCREMENTAL_UPDATE = 298;</code>
     */
    public static final int MT_HALGROUP_INCREMENTAL_UPDATE_VALUE = 298;
    /**
     * <code>MT_HALGROUP_ERROR = 299;</code>
     */
    public static final int MT_HALGROUP_ERROR_VALUE = 299;
    /**
     * <code>MT_RTAPI_APP_EXIT = 300;</code>
     *
     * <pre>
     * rtapi_app commands from halcmd:
     * </pre>
     */
    public static final int MT_RTAPI_APP_EXIT_VALUE = 300;
    /**
     * <code>MT_RTAPI_APP_PING = 301;</code>
     */
    public static final int MT_RTAPI_APP_PING_VALUE = 301;
    /**
     * <code>MT_RTAPI_APP_LOADRT = 302;</code>
     */
    public static final int MT_RTAPI_APP_LOADRT_VALUE = 302;
    /**
     * <code>MT_RTAPI_APP_LOG = 303;</code>
     */
    public static final int MT_RTAPI_APP_LOG_VALUE = 303;
    /**
     * <code>MT_RTAPI_APP_UNLOADRT = 305;</code>
     */
    public static final int MT_RTAPI_APP_UNLOADRT_VALUE = 305;
    /**
     * <code>MT_RTAPI_APP_NEWINST = 306;</code>
     */
    public static final int MT_RTAPI_APP_NEWINST_VALUE = 306;
    /**
     * <code>MT_RTAPI_APP_NEWTHREAD = 307;</code>
     */
    public static final int MT_RTAPI_APP_NEWTHREAD_VALUE = 307;
    /**
     * <code>MT_RTAPI_APP_DELTHREAD = 308;</code>
     */
    public static final int MT_RTAPI_APP_DELTHREAD_VALUE = 308;
    /**
     * <code>MT_RTAPI_APP_CALLFUNC = 309;</code>
     */
    public static final int MT_RTAPI_APP_CALLFUNC_VALUE = 309;
    /**
     * <code>MT_RTAPI_APP_REPLY = 310;</code>
     */
    public static final int MT_RTAPI_APP_REPLY_VALUE = 310;
    /**
     * <code>MT_RTAPI_APP_DELINST = 311;</code>
     */
    public static final int MT_RTAPI_APP_DELINST_VALUE = 311;
    /**
     * <code>MT_LIST_APPLICATIONS = 350;</code>
     *
     * <pre>
     * application discovery
     * </pre>
     */
    public static final int MT_LIST_APPLICATIONS_VALUE = 350;
    /**
     * <code>MT_DESCRIBE_APPLICATION = 351;</code>
     *
     * <pre>
     * this is answered with a MT_DESCRIBE_APPLICATION type
     * and repeated field apps
     * (see message Application)
     * </pre>
     */
    public static final int MT_DESCRIBE_APPLICATION_VALUE = 351;
    /**
     * <code>MT_RETRIEVE_APPLICATION = 352;</code>
     */
    public static final int MT_RETRIEVE_APPLICATION_VALUE = 352;
    /**
     * <code>MT_APPLICATION_DETAIL = 353;</code>
     *
     * <pre>
     * this is answered with a MT_APPLICATION_DETAIL type and
     * a single field apps
     * BUT all files and config items are attached in the
     * message Application
     * </pre>
     */
    public static final int MT_APPLICATION_DETAIL_VALUE = 353;
    /**
     * <code>MT_ERROR = 360;</code>
     *
     * <pre>
     * generic error reply. note field contains explanation.
     * </pre>
     */
    public static final int MT_ERROR_VALUE = 360;
    /**
     * <code>MT_TASK_REPLY = 400;</code>
     *
     * <pre>
     * task/client comms
     * </pre>
     */
    public static final int MT_TASK_REPLY_VALUE = 400;
    /**
     * <code>MT_TICKET_UPDATE = 401;</code>
     */
    public static final int MT_TICKET_UPDATE_VALUE = 401;
    /**
     * <code>MT_CREDIT_UPDATE = 450;</code>
     *
     * <pre>
     * credit-based flow control for queues
     * </pre>
     */
    public static final int MT_CREDIT_UPDATE_VALUE = 450;
    /**
     * <code>MT_EMCMOT_LOWER = 1000;</code>
     *
     * <pre>
     * adjust this to be below lowest motion message type
     * </pre>
     */
    public static final int MT_EMCMOT_LOWER_VALUE = 1000;
    /**
     * <code>MT_EMCMOT_UPPER = 1100;</code>
     *
     * <pre>
     * adjust this to be above highest motion message type
     * </pre>
     */
    public static final int MT_EMCMOT_UPPER_VALUE = 1100;
    /**
     * <code>MT_EMCMOT_ABORT = 1001;</code>
     *
     * <pre>
     * --- snip ---
     * </pre>
     */
    public static final int MT_EMCMOT_ABORT_VALUE = 1001;
    /**
     * <code>MT_EMCMOT_AXIS_ABORT = 1002;</code>
     */
    public static final int MT_EMCMOT_AXIS_ABORT_VALUE = 1002;
    /**
     * <code>MT_EMCMOT_ENABLE = 1003;</code>
     */
    public static final int MT_EMCMOT_ENABLE_VALUE = 1003;
    /**
     * <code>MT_EMCMOT_DISABLE = 1004;</code>
     */
    public static final int MT_EMCMOT_DISABLE_VALUE = 1004;
    /**
     * <code>MT_EMCMOT_ENABLE_AMPLIFIER = 1005;</code>
     */
    public static final int MT_EMCMOT_ENABLE_AMPLIFIER_VALUE = 1005;
    /**
     * <code>MT_EMCMOT_DISABLE_AMPLIFIER = 1006;</code>
     */
    public static final int MT_EMCMOT_DISABLE_AMPLIFIER_VALUE = 1006;
    /**
     * <code>MT_EMCMOT_ENABLE_WATCHDOG = 1007;</code>
     */
    public static final int MT_EMCMOT_ENABLE_WATCHDOG_VALUE = 1007;
    /**
     * <code>MT_EMCMOT_DISABLE_WATCHDOG = 1008;</code>
     */
    public static final int MT_EMCMOT_DISABLE_WATCHDOG_VALUE = 1008;
    /**
     * <code>MT_EMCMOT_ACTIVATE_JOINT = 1009;</code>
     */
    public static final int MT_EMCMOT_ACTIVATE_JOINT_VALUE = 1009;
    /**
     * <code>MT_EMCMOT_DEACTIVATE_JOINT = 1010;</code>
     */
    public static final int MT_EMCMOT_DEACTIVATE_JOINT_VALUE = 1010;
    /**
     * <code>MT_EMCMOT_PAUSE = 1011;</code>
     */
    public static final int MT_EMCMOT_PAUSE_VALUE = 1011;
    /**
     * <code>MT_EMCMOT_RESUME = 1012;</code>
     */
    public static final int MT_EMCMOT_RESUME_VALUE = 1012;
    /**
     * <code>MT_EMCMOT_STEP = 1013;</code>
     */
    public static final int MT_EMCMOT_STEP_VALUE = 1013;
    /**
     * <code>MT_EMCMOT_FREE = 1014;</code>
     */
    public static final int MT_EMCMOT_FREE_VALUE = 1014;
    /**
     * <code>MT_EMCMOT_COORD = 1015;</code>
     */
    public static final int MT_EMCMOT_COORD_VALUE = 1015;
    /**
     * <code>MT_EMCMOT_TELEOP = 1016;</code>
     */
    public static final int MT_EMCMOT_TELEOP_VALUE = 1016;
    /**
     * <code>MT_EMCMOT_SPINDLE_SCALE = 1017;</code>
     */
    public static final int MT_EMCMOT_SPINDLE_SCALE_VALUE = 1017;
    /**
     * <code>MT_EMCMOT_SS_ENABLE = 1018;</code>
     */
    public static final int MT_EMCMOT_SS_ENABLE_VALUE = 1018;
    /**
     * <code>MT_EMCMOT_FEED_SCALE = 1019;</code>
     */
    public static final int MT_EMCMOT_FEED_SCALE_VALUE = 1019;
    /**
     * <code>MT_EMCMOT_FS_ENABLE = 1020;</code>
     */
    public static final int MT_EMCMOT_FS_ENABLE_VALUE = 1020;
    /**
     * <code>MT_EMCMOT_FH_ENABLE = 1021;</code>
     */
    public static final int MT_EMCMOT_FH_ENABLE_VALUE = 1021;
    /**
     * <code>MT_EMCMOT_AF_ENABLE = 1022;</code>
     */
    public static final int MT_EMCMOT_AF_ENABLE_VALUE = 1022;
    /**
     * <code>MT_EMCMOT_OVERRIDE_LIMITS = 1023;</code>
     */
    public static final int MT_EMCMOT_OVERRIDE_LIMITS_VALUE = 1023;
    /**
     * <code>MT_EMCMOT_HOME = 1024;</code>
     */
    public static final int MT_EMCMOT_HOME_VALUE = 1024;
    /**
     * <code>MT_EMCMOT_UNHOME = 1025;</code>
     */
    public static final int MT_EMCMOT_UNHOME_VALUE = 1025;
    /**
     * <code>MT_EMCMOT_JOG_CONT = 1026;</code>
     */
    public static final int MT_EMCMOT_JOG_CONT_VALUE = 1026;
    /**
     * <code>MT_EMCMOT_JOG_INCR = 1027;</code>
     */
    public static final int MT_EMCMOT_JOG_INCR_VALUE = 1027;
    /**
     * <code>MT_EMCMOT_JOG_ABS = 1028;</code>
     */
    public static final int MT_EMCMOT_JOG_ABS_VALUE = 1028;
    /**
     * <code>MT_EMCMOT_SET_LINE = 1029;</code>
     */
    public static final int MT_EMCMOT_SET_LINE_VALUE = 1029;
    /**
     * <code>MT_EMCMOT_SET_CIRCLE = 1030;</code>
     */
    public static final int MT_EMCMOT_SET_CIRCLE_VALUE = 1030;
    /**
     * <code>MT_EMCMOT_SET_TELEOP_VECTOR = 1031;</code>
     */
    public static final int MT_EMCMOT_SET_TELEOP_VECTOR_VALUE = 1031;
    /**
     * <code>MT_EMCMOT_CLEAR_PROBE_FLAGS = 1032;</code>
     */
    public static final int MT_EMCMOT_CLEAR_PROBE_FLAGS_VALUE = 1032;
    /**
     * <code>MT_EMCMOT_PROBE = 1033;</code>
     */
    public static final int MT_EMCMOT_PROBE_VALUE = 1033;
    /**
     * <code>MT_EMCMOT_RIGID_TAP = 1034;</code>
     */
    public static final int MT_EMCMOT_RIGID_TAP_VALUE = 1034;
    /**
     * <code>MT_EMCMOT_SET_POSITION_LIMITS = 1035;</code>
     */
    public static final int MT_EMCMOT_SET_POSITION_LIMITS_VALUE = 1035;
    /**
     * <code>MT_EMCMOT_SET_BACKLASH = 1036;</code>
     */
    public static final int MT_EMCMOT_SET_BACKLASH_VALUE = 1036;
    /**
     * <code>MT_EMCMOT_SET_MIN_FERROR = 1037;</code>
     */
    public static final int MT_EMCMOT_SET_MIN_FERROR_VALUE = 1037;
    /**
     * <code>MT_EMCMOT_SET_MAX_FERROR = 1038;</code>
     */
    public static final int MT_EMCMOT_SET_MAX_FERROR_VALUE = 1038;
    /**
     * <code>MT_EMCMOT_SET_VEL = 1039;</code>
     */
    public static final int MT_EMCMOT_SET_VEL_VALUE = 1039;
    /**
     * <code>MT_EMCMOT_SET_VEL_LIMIT = 1040;</code>
     */
    public static final int MT_EMCMOT_SET_VEL_LIMIT_VALUE = 1040;
    /**
     * <code>MT_EMCMOT_SET_JOINT_VEL_LIMIT = 1041;</code>
     */
    public static final int MT_EMCMOT_SET_JOINT_VEL_LIMIT_VALUE = 1041;
    /**
     * <code>MT_EMCMOT_SET_JOINT_ACC_LIMIT = 1042;</code>
     */
    public static final int MT_EMCMOT_SET_JOINT_ACC_LIMIT_VALUE = 1042;
    /**
     * <code>MT_EMCMOT_SET_ACC = 1043;</code>
     */
    public static final int MT_EMCMOT_SET_ACC_VALUE = 1043;
    /**
     * <code>MT_EMCMOT_SET_TERM_COND = 1044;</code>
     */
    public static final int MT_EMCMOT_SET_TERM_COND_VALUE = 1044;
    /**
     * <code>MT_EMCMOT_SET_NUM_AXES = 1045;</code>
     */
    public static final int MT_EMCMOT_SET_NUM_AXES_VALUE = 1045;
    /**
     * <code>MT_EMCMOT_SET_WORLD_HOME = 1046;</code>
     */
    public static final int MT_EMCMOT_SET_WORLD_HOME_VALUE = 1046;
    /**
     * <code>MT_EMCMOT_SET_HOMING_PARAMS = 1047;</code>
     */
    public static final int MT_EMCMOT_SET_HOMING_PARAMS_VALUE = 1047;
    /**
     * <code>MT_EMCMOT_SET_DEBUG = 1048;</code>
     */
    public static final int MT_EMCMOT_SET_DEBUG_VALUE = 1048;
    /**
     * <code>MT_EMCMOT_SET_DOUT = 1049;</code>
     */
    public static final int MT_EMCMOT_SET_DOUT_VALUE = 1049;
    /**
     * <code>MT_EMCMOT_SET_AOUT = 1050;</code>
     */
    public static final int MT_EMCMOT_SET_AOUT_VALUE = 1050;
    /**
     * <code>MT_EMCMOT_SET_SPINDLESYNC = 1051;</code>
     */
    public static final int MT_EMCMOT_SET_SPINDLESYNC_VALUE = 1051;
    /**
     * <code>MT_EMCMOT_SPINDLE_ON = 1052;</code>
     */
    public static final int MT_EMCMOT_SPINDLE_ON_VALUE = 1052;
    /**
     * <code>MT_EMCMOT_SPINDLE_OFF = 1053;</code>
     */
    public static final int MT_EMCMOT_SPINDLE_OFF_VALUE = 1053;
    /**
     * <code>MT_EMCMOT_SPINDLE_INCREASE = 1054;</code>
     */
    public static final int MT_EMCMOT_SPINDLE_INCREASE_VALUE = 1054;
    /**
     * <code>MT_EMCMOT_SPINDLE_DECREASE = 1055;</code>
     */
    public static final int MT_EMCMOT_SPINDLE_DECREASE_VALUE = 1055;
    /**
     * <code>MT_EMCMOT_SPINDLE_BRAKE_ENGAGE = 1056;</code>
     */
    public static final int MT_EMCMOT_SPINDLE_BRAKE_ENGAGE_VALUE = 1056;
    /**
     * <code>MT_EMCMOT_SPINDLE_BRAKE_RELEASE = 1057;</code>
     */
    public static final int MT_EMCMOT_SPINDLE_BRAKE_RELEASE_VALUE = 1057;
    /**
     * <code>MT_EMCMOT_SET_MOTOR_OFFSET = 1058;</code>
     */
    public static final int MT_EMCMOT_SET_MOTOR_OFFSET_VALUE = 1058;
    /**
     * <code>MT_EMCMOT_SET_JOINT_COMP = 1059;</code>
     */
    public static final int MT_EMCMOT_SET_JOINT_COMP_VALUE = 1059;
    /**
     * <code>MT_EMCMOT_SET_OFFSET = 1060;</code>
     */
    public static final int MT_EMCMOT_SET_OFFSET_VALUE = 1060;
    /**
     * <code>MT_EMCMOT_COMMAND_OK = 1061;</code>
     */
    public static final int MT_EMCMOT_COMMAND_OK_VALUE = 1061;
    /**
     * <code>MT_EMCMOT_COMMAND_UNKNOWN_COMMAND = 1062;</code>
     */
    public static final int MT_EMCMOT_COMMAND_UNKNOWN_COMMAND_VALUE = 1062;
    /**
     * <code>MT_EMCMOT_COMMAND_INVALID_COMMAND = 1063;</code>
     */
    public static final int MT_EMCMOT_COMMAND_INVALID_COMMAND_VALUE = 1063;
    /**
     * <code>MT_EMCMOT_COMMAND_INVALID_PARAMS = 1064;</code>
     */
    public static final int MT_EMCMOT_COMMAND_INVALID_PARAMS_VALUE = 1064;
    /**
     * <code>MT_EMCMOT_COMMAND_BAD_EXEC = 1065;</code>
     */
    public static final int MT_EMCMOT_COMMAND_BAD_EXEC_VALUE = 1065;
    /**
     * <code>MT_EMCMOT_MOTION_DISABLED = 1066;</code>
     */
    public static final int MT_EMCMOT_MOTION_DISABLED_VALUE = 1066;
    /**
     * <code>MT_EMCMOT_MOTION_FREE = 1067;</code>
     */
    public static final int MT_EMCMOT_MOTION_FREE_VALUE = 1067;
    /**
     * <code>MT_EMCMOT_MOTION_TELEOP = 1068;</code>
     */
    public static final int MT_EMCMOT_MOTION_TELEOP_VALUE = 1068;
    /**
     * <code>MT_EMCMOT_MOTION_COORD = 1069;</code>
     */
    public static final int MT_EMCMOT_MOTION_COORD_VALUE = 1069;
    /**
     * <code>MT_EMCMOT_JOINT_FLAG = 1070;</code>
     */
    public static final int MT_EMCMOT_JOINT_FLAG_VALUE = 1070;
    /**
     * <code>MT_EMCMOT_MOTION_FLAG = 1071;</code>
     *
     * <pre>
     * --- snip ---
     * </pre>
     */
    public static final int MT_EMCMOT_MOTION_FLAG_VALUE = 1071;
    /**
     * <code>MT_PRU_FIRMWARE = 2048;</code>
     */
    public static final int MT_PRU_FIRMWARE_VALUE = 2048;
    /**
     * <code>MT_MESA_5I20_FIRMWARE = 3000;</code>
     *
     * <pre>
     * Mesanet firmware types: 3000 - 3999
     * </pre>
     */
    public static final int MT_MESA_5I20_FIRMWARE_VALUE = 3000;
    /**
     * <code>MT_BLOB = 4000;</code>
     *
     * <pre>
     * a blob of unspecified content - for temporary use during development
     * </pre>
     */
    public static final int MT_BLOB_VALUE = 4000;
    /**
     * <code>MT_TEST1 = 5001;</code>
     *
     * <pre>
     * test message range: 5000-5100 - never used by core code
     * </pre>
     */
    public static final int MT_TEST1_VALUE = 5001;
    /**
     * <code>MT_TEST2 = 5002;</code>
     */
    public static final int MT_TEST2_VALUE = 5002;
    /**
     * <code>MT_TEST3 = 5003;</code>
     */
    public static final int MT_TEST3_VALUE = 5003;
    /**
     * <code>MT_EMC_NML_LOWER = 10000;</code>
     *
     * <pre>
     * adjust this to be below lowest NML message type
     * </pre>
     */
    public static final int MT_EMC_NML_LOWER_VALUE = 10000;
    /**
     * <code>MT_EMC_NML_UPPER = 13000;</code>
     *
     * <pre>
     * adjust this to be above highest NML message type
     * </pre>
     */
    public static final int MT_EMC_NML_UPPER_VALUE = 13000;
    /**
     * <code>MT_EMC_OPERATOR_ERROR = 10011;</code>
     *
     * <pre>
     * --- snip ---
     * </pre>
     */
    public static final int MT_EMC_OPERATOR_ERROR_VALUE = 10011;
    /**
     * <code>MT_EMC_OPERATOR_TEXT = 10012;</code>
     */
    public static final int MT_EMC_OPERATOR_TEXT_VALUE = 10012;
    /**
     * <code>MT_EMC_OPERATOR_DISPLAY = 10013;</code>
     */
    public static final int MT_EMC_OPERATOR_DISPLAY_VALUE = 10013;
    /**
     * <code>MT_EMC_NULL = 10021;</code>
     */
    public static final int MT_EMC_NULL_VALUE = 10021;
    /**
     * <code>MT_EMC_SET_DEBUG = 10022;</code>
     */
    public static final int MT_EMC_SET_DEBUG_VALUE = 10022;
    /**
     * <code>MT_EMC_SYSTEM_CMD = 10030;</code>
     */
    public static final int MT_EMC_SYSTEM_CMD_VALUE = 10030;
    /**
     * <code>MT_EMC_AXIS_SET_AXIS = 10101;</code>
     */
    public static final int MT_EMC_AXIS_SET_AXIS_VALUE = 10101;
    /**
     * <code>MT_EMC_AXIS_SET_UNITS = 10102;</code>
     */
    public static final int MT_EMC_AXIS_SET_UNITS_VALUE = 10102;
    /**
     * <code>MT_EMC_AXIS_SET_MIN_POSITION_LIMIT = 10107;</code>
     */
    public static final int MT_EMC_AXIS_SET_MIN_POSITION_LIMIT_VALUE = 10107;
    /**
     * <code>MT_EMC_AXIS_SET_MAX_POSITION_LIMIT = 10108;</code>
     */
    public static final int MT_EMC_AXIS_SET_MAX_POSITION_LIMIT_VALUE = 10108;
    /**
     * <code>MT_EMC_TOOL_START_CHANGE = 1110;</code>
     */
    public static final int MT_EMC_TOOL_START_CHANGE_VALUE = 1110;
    /**
     * <code>MT_EMC_EXEC_PLUGIN_CALL = 1112;</code>
     */
    public static final int MT_EMC_EXEC_PLUGIN_CALL_VALUE = 1112;
    /**
     * <code>MT_EMC_IO_PLUGIN_CALL = 1113;</code>
     */
    public static final int MT_EMC_IO_PLUGIN_CALL_VALUE = 1113;
    /**
     * <code>MT_EMC_AXIS_SET_FERROR = 10111;</code>
     */
    public static final int MT_EMC_AXIS_SET_FERROR_VALUE = 10111;
    /**
     * <code>MT_EMC_AXIS_SET_HOMING_PARAMS = 10112;</code>
     */
    public static final int MT_EMC_AXIS_SET_HOMING_PARAMS_VALUE = 10112;
    /**
     * <code>MT_EMC_AXIS_SET_MIN_FERROR = 10115;</code>
     */
    public static final int MT_EMC_AXIS_SET_MIN_FERROR_VALUE = 10115;
    /**
     * <code>MT_EMC_AXIS_SET_MAX_VELOCITY = 10116;</code>
     */
    public static final int MT_EMC_AXIS_SET_MAX_VELOCITY_VALUE = 10116;
    /**
     * <code>MT_EMC_AXIS_INIT = 10118;</code>
     */
    public static final int MT_EMC_AXIS_INIT_VALUE = 10118;
    /**
     * <code>MT_EMC_AXIS_HALT = 10119;</code>
     */
    public static final int MT_EMC_AXIS_HALT_VALUE = 10119;
    /**
     * <code>MT_EMC_AXIS_ABORT = 10120;</code>
     */
    public static final int MT_EMC_AXIS_ABORT_VALUE = 10120;
    /**
     * <code>MT_EMC_AXIS_ENABLE = 10121;</code>
     */
    public static final int MT_EMC_AXIS_ENABLE_VALUE = 10121;
    /**
     * <code>MT_EMC_AXIS_DISABLE = 10122;</code>
     */
    public static final int MT_EMC_AXIS_DISABLE_VALUE = 10122;
    /**
     * <code>MT_EMC_AXIS_HOME = 10123;</code>
     */
    public static final int MT_EMC_AXIS_HOME_VALUE = 10123;
    /**
     * <code>MT_EMC_AXIS_UNHOME = 10135;</code>
     */
    public static final int MT_EMC_AXIS_UNHOME_VALUE = 10135;
    /**
     * <code>MT_EMC_AXIS_JOG = 10124;</code>
     */
    public static final int MT_EMC_AXIS_JOG_VALUE = 10124;
    /**
     * <code>MT_EMC_AXIS_INCR_JOG = 10125;</code>
     */
    public static final int MT_EMC_AXIS_INCR_JOG_VALUE = 10125;
    /**
     * <code>MT_EMC_AXIS_ABS_JOG = 10126;</code>
     */
    public static final int MT_EMC_AXIS_ABS_JOG_VALUE = 10126;
    /**
     * <code>MT_EMC_AXIS_ACTIVATE = 10127;</code>
     */
    public static final int MT_EMC_AXIS_ACTIVATE_VALUE = 10127;
    /**
     * <code>MT_EMC_AXIS_DEACTIVATE = 10128;</code>
     */
    public static final int MT_EMC_AXIS_DEACTIVATE_VALUE = 10128;
    /**
     * <code>MT_EMC_AXIS_OVERRIDE_LIMITS = 10129;</code>
     */
    public static final int MT_EMC_AXIS_OVERRIDE_LIMITS_VALUE = 10129;
    /**
     * <code>MT_EMC_AXIS_LOAD_COMP = 10131;</code>
     */
    public static final int MT_EMC_AXIS_LOAD_COMP_VALUE = 10131;
    /**
     * <code>MT_EMC_AXIS_SET_BACKLASH = 10134;</code>
     */
    public static final int MT_EMC_AXIS_SET_BACKLASH_VALUE = 10134;
    /**
     * <code>MT_EMC_AXIS_STAT = 10199;</code>
     */
    public static final int MT_EMC_AXIS_STAT_VALUE = 10199;
    /**
     * <code>MT_EMC_TRAJ_SET_AXES = 10201;</code>
     */
    public static final int MT_EMC_TRAJ_SET_AXES_VALUE = 10201;
    /**
     * <code>MT_EMC_TRAJ_SET_UNITS = 10202;</code>
     */
    public static final int MT_EMC_TRAJ_SET_UNITS_VALUE = 10202;
    /**
     * <code>MT_EMC_TRAJ_SET_CYCLE_TIME = 10203;</code>
     */
    public static final int MT_EMC_TRAJ_SET_CYCLE_TIME_VALUE = 10203;
    /**
     * <code>MT_EMC_TRAJ_SET_MODE = 10204;</code>
     */
    public static final int MT_EMC_TRAJ_SET_MODE_VALUE = 10204;
    /**
     * <code>MT_EMC_TRAJ_SET_VELOCITY = 10205;</code>
     */
    public static final int MT_EMC_TRAJ_SET_VELOCITY_VALUE = 10205;
    /**
     * <code>MT_EMC_TRAJ_SET_ACCELERATION = 10206;</code>
     */
    public static final int MT_EMC_TRAJ_SET_ACCELERATION_VALUE = 10206;
    /**
     * <code>MT_EMC_TRAJ_SET_MAX_VELOCITY = 10207;</code>
     */
    public static final int MT_EMC_TRAJ_SET_MAX_VELOCITY_VALUE = 10207;
    /**
     * <code>MT_EMC_TRAJ_SET_MAX_ACCELERATION = 10208;</code>
     */
    public static final int MT_EMC_TRAJ_SET_MAX_ACCELERATION_VALUE = 10208;
    /**
     * <code>MT_EMC_TRAJ_SET_SCALE = 10209;</code>
     */
    public static final int MT_EMC_TRAJ_SET_SCALE_VALUE = 10209;
    /**
     * <code>MT_EMC_TRAJ_SET_MOTION_ID = 10210;</code>
     */
    public static final int MT_EMC_TRAJ_SET_MOTION_ID_VALUE = 10210;
    /**
     * <code>MT_EMC_TRAJ_INIT = 10211;</code>
     */
    public static final int MT_EMC_TRAJ_INIT_VALUE = 10211;
    /**
     * <code>MT_EMC_TRAJ_HALT = 10212;</code>
     */
    public static final int MT_EMC_TRAJ_HALT_VALUE = 10212;
    /**
     * <code>MT_EMC_TRAJ_ENABLE = 10213;</code>
     */
    public static final int MT_EMC_TRAJ_ENABLE_VALUE = 10213;
    /**
     * <code>MT_EMC_TRAJ_DISABLE = 10214;</code>
     */
    public static final int MT_EMC_TRAJ_DISABLE_VALUE = 10214;
    /**
     * <code>MT_EMC_TRAJ_ABORT = 10215;</code>
     */
    public static final int MT_EMC_TRAJ_ABORT_VALUE = 10215;
    /**
     * <code>MT_EMC_TRAJ_PAUSE = 10216;</code>
     */
    public static final int MT_EMC_TRAJ_PAUSE_VALUE = 10216;
    /**
     * <code>MT_EMC_TRAJ_STEP = 10217;</code>
     */
    public static final int MT_EMC_TRAJ_STEP_VALUE = 10217;
    /**
     * <code>MT_EMC_TRAJ_RESUME = 10218;</code>
     */
    public static final int MT_EMC_TRAJ_RESUME_VALUE = 10218;
    /**
     * <code>MT_EMC_TRAJ_DELAY = 10219;</code>
     */
    public static final int MT_EMC_TRAJ_DELAY_VALUE = 10219;
    /**
     * <code>MT_EMC_TRAJ_LINEAR_MOVE = 10220;</code>
     */
    public static final int MT_EMC_TRAJ_LINEAR_MOVE_VALUE = 10220;
    /**
     * <code>MT_EMC_TRAJ_CIRCULAR_MOVE = 10221;</code>
     */
    public static final int MT_EMC_TRAJ_CIRCULAR_MOVE_VALUE = 10221;
    /**
     * <code>MT_EMC_TRAJ_SET_TERM_COND = 10222;</code>
     */
    public static final int MT_EMC_TRAJ_SET_TERM_COND_VALUE = 10222;
    /**
     * <code>MT_EMC_TRAJ_SET_OFFSET = 10223;</code>
     */
    public static final int MT_EMC_TRAJ_SET_OFFSET_VALUE = 10223;
    /**
     * <code>MT_EMC_TRAJ_SET_G5X = 10224;</code>
     */
    public static final int MT_EMC_TRAJ_SET_G5X_VALUE = 10224;
    /**
     * <code>MT_EMC_TRAJ_SET_HOME = 10225;</code>
     */
    public static final int MT_EMC_TRAJ_SET_HOME_VALUE = 10225;
    /**
     * <code>MT_EMC_TRAJ_SET_ROTATION = 10226;</code>
     */
    public static final int MT_EMC_TRAJ_SET_ROTATION_VALUE = 10226;
    /**
     * <code>MT_EMC_TRAJ_SET_G92 = 10227;</code>
     */
    public static final int MT_EMC_TRAJ_SET_G92_VALUE = 10227;
    /**
     * <code>MT_EMC_TRAJ_CLEAR_PROBE_TRIPPED_FLAG = 10228;</code>
     */
    public static final int MT_EMC_TRAJ_CLEAR_PROBE_TRIPPED_FLAG_VALUE = 10228;
    /**
     * <code>MT_EMC_TRAJ_PROBE = 10229;</code>
     */
    public static final int MT_EMC_TRAJ_PROBE_VALUE = 10229;
    /**
     * <code>MT_EMC_TRAJ_SET_TELEOP_ENABLE = 10230;</code>
     */
    public static final int MT_EMC_TRAJ_SET_TELEOP_ENABLE_VALUE = 10230;
    /**
     * <code>MT_EMC_TRAJ_SET_TELEOP_VECTOR = 10231;</code>
     */
    public static final int MT_EMC_TRAJ_SET_TELEOP_VECTOR_VALUE = 10231;
    /**
     * <code>MT_EMC_TRAJ_SET_SPINDLESYNC = 10232;</code>
     */
    public static final int MT_EMC_TRAJ_SET_SPINDLESYNC_VALUE = 10232;
    /**
     * <code>MT_EMC_TRAJ_SET_SPINDLE_SCALE = 10233;</code>
     */
    public static final int MT_EMC_TRAJ_SET_SPINDLE_SCALE_VALUE = 10233;
    /**
     * <code>MT_EMC_TRAJ_SET_FO_ENABLE = 10234;</code>
     */
    public static final int MT_EMC_TRAJ_SET_FO_ENABLE_VALUE = 10234;
    /**
     * <code>MT_EMC_TRAJ_SET_SO_ENABLE = 10235;</code>
     */
    public static final int MT_EMC_TRAJ_SET_SO_ENABLE_VALUE = 10235;
    /**
     * <code>MT_EMC_TRAJ_SET_FH_ENABLE = 10236;</code>
     */
    public static final int MT_EMC_TRAJ_SET_FH_ENABLE_VALUE = 10236;
    /**
     * <code>MT_EMC_TRAJ_RIGID_TAP = 10237;</code>
     */
    public static final int MT_EMC_TRAJ_RIGID_TAP_VALUE = 10237;
    /**
     * <code>MT_EMC_TRAJ_STAT = 10299;</code>
     */
    public static final int MT_EMC_TRAJ_STAT_VALUE = 10299;
    /**
     * <code>MT_EMC_MOTION_INIT = 10301;</code>
     */
    public static final int MT_EMC_MOTION_INIT_VALUE = 10301;
    /**
     * <code>MT_EMC_MOTION_HALT = 10302;</code>
     */
    public static final int MT_EMC_MOTION_HALT_VALUE = 10302;
    /**
     * <code>MT_EMC_MOTION_ABORT = 10303;</code>
     */
    public static final int MT_EMC_MOTION_ABORT_VALUE = 10303;
    /**
     * <code>MT_EMC_MOTION_SET_AOUT = 10304;</code>
     */
    public static final int MT_EMC_MOTION_SET_AOUT_VALUE = 10304;
    /**
     * <code>MT_EMC_MOTION_SET_DOUT = 10305;</code>
     */
    public static final int MT_EMC_MOTION_SET_DOUT_VALUE = 10305;
    /**
     * <code>MT_EMC_MOTION_ADAPTIVE = 10306;</code>
     */
    public static final int MT_EMC_MOTION_ADAPTIVE_VALUE = 10306;
    /**
     * <code>MT_EMC_SPINDLE_ORIENT = 10317;</code>
     */
    public static final int MT_EMC_SPINDLE_ORIENT_VALUE = 10317;
    /**
     * <code>MT_EMC_SPINDLE_WAIT_ORIENT_COMPLETE = 10318;</code>
     */
    public static final int MT_EMC_SPINDLE_WAIT_ORIENT_COMPLETE_VALUE = 10318;
    /**
     * <code>MT_EMC_MOTION_STAT = 10399;</code>
     */
    public static final int MT_EMC_MOTION_STAT_VALUE = 10399;
    /**
     * <code>MT_EMC_TASK_INIT = 10501;</code>
     */
    public static final int MT_EMC_TASK_INIT_VALUE = 10501;
    /**
     * <code>MT_EMC_TASK_HALT = 10502;</code>
     */
    public static final int MT_EMC_TASK_HALT_VALUE = 10502;
    /**
     * <code>MT_EMC_TASK_ABORT = 10503;</code>
     */
    public static final int MT_EMC_TASK_ABORT_VALUE = 10503;
    /**
     * <code>MT_EMC_TASK_SET_MODE = 10504;</code>
     */
    public static final int MT_EMC_TASK_SET_MODE_VALUE = 10504;
    /**
     * <code>MT_EMC_TASK_SET_STATE = 10505;</code>
     */
    public static final int MT_EMC_TASK_SET_STATE_VALUE = 10505;
    /**
     * <code>MT_EMC_TASK_PLAN_OPEN = 10506;</code>
     */
    public static final int MT_EMC_TASK_PLAN_OPEN_VALUE = 10506;
    /**
     * <code>MT_EMC_TASK_PLAN_RUN = 10507;</code>
     */
    public static final int MT_EMC_TASK_PLAN_RUN_VALUE = 10507;
    /**
     * <code>MT_EMC_TASK_PLAN_READ = 10508;</code>
     */
    public static final int MT_EMC_TASK_PLAN_READ_VALUE = 10508;
    /**
     * <code>MT_EMC_TASK_PLAN_EXECUTE = 10509;</code>
     */
    public static final int MT_EMC_TASK_PLAN_EXECUTE_VALUE = 10509;
    /**
     * <code>MT_EMC_TASK_PLAN_PAUSE = 10510;</code>
     */
    public static final int MT_EMC_TASK_PLAN_PAUSE_VALUE = 10510;
    /**
     * <code>MT_EMC_TASK_PLAN_STEP = 10511;</code>
     */
    public static final int MT_EMC_TASK_PLAN_STEP_VALUE = 10511;
    /**
     * <code>MT_EMC_TASK_PLAN_RESUME = 10512;</code>
     */
    public static final int MT_EMC_TASK_PLAN_RESUME_VALUE = 10512;
    /**
     * <code>MT_EMC_TASK_PLAN_END = 10513;</code>
     */
    public static final int MT_EMC_TASK_PLAN_END_VALUE = 10513;
    /**
     * <code>MT_EMC_TASK_PLAN_CLOSE = 10514;</code>
     */
    public static final int MT_EMC_TASK_PLAN_CLOSE_VALUE = 10514;
    /**
     * <code>MT_EMC_TASK_PLAN_INIT = 10515;</code>
     */
    public static final int MT_EMC_TASK_PLAN_INIT_VALUE = 10515;
    /**
     * <code>MT_EMC_TASK_PLAN_SYNCH = 10516;</code>
     */
    public static final int MT_EMC_TASK_PLAN_SYNCH_VALUE = 10516;
    /**
     * <code>MT_EMC_TASK_PLAN_SET_OPTIONAL_STOP = 10517;</code>
     */
    public static final int MT_EMC_TASK_PLAN_SET_OPTIONAL_STOP_VALUE = 10517;
    /**
     * <code>MT_EMC_TASK_PLAN_SET_BLOCK_DELETE = 10518;</code>
     */
    public static final int MT_EMC_TASK_PLAN_SET_BLOCK_DELETE_VALUE = 10518;
    /**
     * <code>MT_EMC_TASK_PLAN_OPTIONAL_STOP = 10519;</code>
     */
    public static final int MT_EMC_TASK_PLAN_OPTIONAL_STOP_VALUE = 10519;
    /**
     * <code>MT_EMC_TASK_PLAN_RESET = 10520;</code>
     */
    public static final int MT_EMC_TASK_PLAN_RESET_VALUE = 10520;
    /**
     * <code>MT_EMC_TASK_PLAN_REPLY = 10530;</code>
     */
    public static final int MT_EMC_TASK_PLAN_REPLY_VALUE = 10530;
    /**
     * <code>MT_EMC_TASK_STAT = 10599;</code>
     */
    public static final int MT_EMC_TASK_STAT_VALUE = 10599;
    /**
     * <code>MT_EMC_TOOL_INIT = 11101;</code>
     */
    public static final int MT_EMC_TOOL_INIT_VALUE = 11101;
    /**
     * <code>MT_EMC_TOOL_HALT = 11102;</code>
     */
    public static final int MT_EMC_TOOL_HALT_VALUE = 11102;
    /**
     * <code>MT_EMC_TOOL_ABORT = 11103;</code>
     */
    public static final int MT_EMC_TOOL_ABORT_VALUE = 11103;
    /**
     * <code>MT_EMC_TOOL_PREPARE = 11104;</code>
     */
    public static final int MT_EMC_TOOL_PREPARE_VALUE = 11104;
    /**
     * <code>MT_EMC_TOOL_LOAD = 11105;</code>
     */
    public static final int MT_EMC_TOOL_LOAD_VALUE = 11105;
    /**
     * <code>MT_EMC_TOOL_UNLOAD = 11106;</code>
     */
    public static final int MT_EMC_TOOL_UNLOAD_VALUE = 11106;
    /**
     * <code>MT_EMC_TOOL_LOAD_TOOL_TABLE = 11107;</code>
     */
    public static final int MT_EMC_TOOL_LOAD_TOOL_TABLE_VALUE = 11107;
    /**
     * <code>MT_EMC_TOOL_SET_OFFSET = 11108;</code>
     */
    public static final int MT_EMC_TOOL_SET_OFFSET_VALUE = 11108;
    /**
     * <code>MT_EMC_TOOL_SET_NUMBER = 11109;</code>
     */
    public static final int MT_EMC_TOOL_SET_NUMBER_VALUE = 11109;
    /**
     * <code>MT_EMC_TOOL_STAT = 11199;</code>
     */
    public static final int MT_EMC_TOOL_STAT_VALUE = 11199;
    /**
     * <code>MT_EMC_AUX_ESTOP_ON = 11206;</code>
     */
    public static final int MT_EMC_AUX_ESTOP_ON_VALUE = 11206;
    /**
     * <code>MT_EMC_AUX_ESTOP_OFF = 11207;</code>
     */
    public static final int MT_EMC_AUX_ESTOP_OFF_VALUE = 11207;
    /**
     * <code>MT_EMC_AUX_ESTOP_RESET = 11208;</code>
     */
    public static final int MT_EMC_AUX_ESTOP_RESET_VALUE = 11208;
    /**
     * <code>MT_EMC_AUX_INPUT_WAIT = 11209;</code>
     */
    public static final int MT_EMC_AUX_INPUT_WAIT_VALUE = 11209;
    /**
     * <code>MT_EMC_AUX_STAT = 11299;</code>
     */
    public static final int MT_EMC_AUX_STAT_VALUE = 11299;
    /**
     * <code>MT_EMC_SPINDLE_ON = 11304;</code>
     */
    public static final int MT_EMC_SPINDLE_ON_VALUE = 11304;
    /**
     * <code>MT_EMC_SPINDLE_OFF = 11305;</code>
     */
    public static final int MT_EMC_SPINDLE_OFF_VALUE = 11305;
    /**
     * <code>MT_EMC_SPINDLE_INCREASE = 11309;</code>
     */
    public static final int MT_EMC_SPINDLE_INCREASE_VALUE = 11309;
    /**
     * <code>MT_EMC_SPINDLE_DECREASE = 11310;</code>
     */
    public static final int MT_EMC_SPINDLE_DECREASE_VALUE = 11310;
    /**
     * <code>MT_EMC_SPINDLE_CONSTANT = 11311;</code>
     */
    public static final int MT_EMC_SPINDLE_CONSTANT_VALUE = 11311;
    /**
     * <code>MT_EMC_SPINDLE_BRAKE_RELEASE = 11312;</code>
     */
    public static final int MT_EMC_SPINDLE_BRAKE_RELEASE_VALUE = 11312;
    /**
     * <code>MT_EMC_SPINDLE_BRAKE_ENGAGE = 11313;</code>
     */
    public static final int MT_EMC_SPINDLE_BRAKE_ENGAGE_VALUE = 11313;
    /**
     * <code>MT_EMC_SPINDLE_SPEED = 11316;</code>
     */
    public static final int MT_EMC_SPINDLE_SPEED_VALUE = 11316;
    /**
     * <code>MT_EMC_SPINDLE_STAT = 11399;</code>
     */
    public static final int MT_EMC_SPINDLE_STAT_VALUE = 11399;
    /**
     * <code>MT_EMC_COOLANT_MIST_ON = 11404;</code>
     */
    public static final int MT_EMC_COOLANT_MIST_ON_VALUE = 11404;
    /**
     * <code>MT_EMC_COOLANT_MIST_OFF = 11405;</code>
     */
    public static final int MT_EMC_COOLANT_MIST_OFF_VALUE = 11405;
    /**
     * <code>MT_EMC_COOLANT_FLOOD_ON = 11406;</code>
     */
    public static final int MT_EMC_COOLANT_FLOOD_ON_VALUE = 11406;
    /**
     * <code>MT_EMC_COOLANT_FLOOD_OFF = 11407;</code>
     */
    public static final int MT_EMC_COOLANT_FLOOD_OFF_VALUE = 11407;
    /**
     * <code>MT_EMC_COOLANT_STAT = 11499;</code>
     */
    public static final int MT_EMC_COOLANT_STAT_VALUE = 11499;
    /**
     * <code>MT_EMC_LUBE_ON = 11504;</code>
     */
    public static final int MT_EMC_LUBE_ON_VALUE = 11504;
    /**
     * <code>MT_EMC_LUBE_OFF = 11505;</code>
     */
    public static final int MT_EMC_LUBE_OFF_VALUE = 11505;
    /**
     * <code>MT_EMC_LUBE_STAT = 11599;</code>
     */
    public static final int MT_EMC_LUBE_STAT_VALUE = 11599;
    /**
     * <code>MT_EMC_IO_INIT = 11601;</code>
     */
    public static final int MT_EMC_IO_INIT_VALUE = 11601;
    /**
     * <code>MT_EMC_IO_HALT = 11602;</code>
     */
    public static final int MT_EMC_IO_HALT_VALUE = 11602;
    /**
     * <code>MT_EMC_IO_ABORT = 11603;</code>
     */
    public static final int MT_EMC_IO_ABORT_VALUE = 11603;
    /**
     * <code>MT_EMC_IO_SET_CYCLE_TIME = 11604;</code>
     */
    public static final int MT_EMC_IO_SET_CYCLE_TIME_VALUE = 11604;
    /**
     * <code>MT_EMC_IO_STAT = 11699;</code>
     */
    public static final int MT_EMC_IO_STAT_VALUE = 11699;
    /**
     * <code>MT_EMC_INIT = 11901;</code>
     */
    public static final int MT_EMC_INIT_VALUE = 11901;
    /**
     * <code>MT_EMC_HALT = 11902;</code>
     */
    public static final int MT_EMC_HALT_VALUE = 11902;
    /**
     * <code>MT_EMC_ABORT = 11903;</code>
     */
    public static final int MT_EMC_ABORT_VALUE = 11903;
    /**
     * <code>MT_EMC_STAT = 11999;</code>
     *
     * <pre>
     * --- snip ---
     * </pre>
     */
    public static final int MT_EMC_STAT_VALUE = 11999;
    /**
     * <code>MT_EMCSTAT_FULL_UPDATE = 12500;</code>
     *
     * <pre>
     * EMC status
     * </pre>
     */
    public static final int MT_EMCSTAT_FULL_UPDATE_VALUE = 12500;
    /**
     * <code>MT_EMCSTAT_INCREMENTAL_UPDATE = 12501;</code>
     */
    public static final int MT_EMCSTAT_INCREMENTAL_UPDATE_VALUE = 12501;
    /**
     * <code>MT_EMC_NML_ERROR = 12510;</code>
     *
     * <pre>
     * EMC error
     * </pre>
     */
    public static final int MT_EMC_NML_ERROR_VALUE = 12510;
    /**
     * <code>MT_EMC_NML_TEXT = 12511;</code>
     */
    public static final int MT_EMC_NML_TEXT_VALUE = 12511;
    /**
     * <code>MT_EMC_NML_DISPLAY = 12512;</code>
     */
    public static final int MT_EMC_NML_DISPLAY_VALUE = 12512;
    /**
     * <code>MT_EMCCMD_EXECUTED = 12520;</code>
     *
     * <pre>
     * EMC command
     * </pre>
     */
    public static final int MT_EMCCMD_EXECUTED_VALUE = 12520;
    /**
     * <code>MT_EMCCMD_COMPLETED = 12521;</code>
     */
    public static final int MT_EMCCMD_COMPLETED_VALUE = 12521;
    /**
     * <code>MT_LAUNCHER_FULL_UPDATE = 12600;</code>
     *
     * <pre>
     * launcher pub-sub
     * </pre>
     */
    public static final int MT_LAUNCHER_FULL_UPDATE_VALUE = 12600;
    /**
     * <code>MT_LAUNCHER_INCREMENTAL_UPDATE = 12601;</code>
     */
    public static final int MT_LAUNCHER_INCREMENTAL_UPDATE_VALUE = 12601;
    /**
     * <code>MT_LAUNCHER_ERROR = 12602;</code>
     */
    public static final int MT_LAUNCHER_ERROR_VALUE = 12602;
    /**
     * <code>MT_LAUNCHER_START = 12610;</code>
     *
     * <pre>
     * launcher command
     * </pre>
     */
    public static final int MT_LAUNCHER_START_VALUE = 12610;
    /**
     * <code>MT_LAUNCHER_TERMINATE = 12611;</code>
     */
    public static final int MT_LAUNCHER_TERMINATE_VALUE = 12611;
    /**
     * <code>MT_LAUNCHER_KILL = 12612;</code>
     */
    public static final int MT_LAUNCHER_KILL_VALUE = 12612;
    /**
     * <code>MT_LAUNCHER_WRITE_STDIN = 12613;</code>
     */
    public static final int MT_LAUNCHER_WRITE_STDIN_VALUE = 12613;
    /**
     * <code>MT_LAUNCHER_CALL = 12614;</code>
     */
    public static final int MT_LAUNCHER_CALL_VALUE = 12614;
    /**
     * <code>MT_LAUNCHER_SHUTDOWN = 12615;</code>
     */
    public static final int MT_LAUNCHER_SHUTDOWN_VALUE = 12615;


    public final int getNumber() { return value; }

    public static ContainerType valueOf(int value) {
      switch (value) {
        case 2: return MT_RTMESSAGE;
        case 3: return MT_MOTCMD;
        case 4: return MT_MOTSTATUS;
        case 5: return MT_LEGACY_MOTCMD;
        case 6: return MT_LEGACY_MOTSTATUS;
        case 7: return MT_WOU;
        case 8: return MT_HALUPDATE;
        case 9: return MT_RTAPI_MESSAGE;
        case 10: return MT_LOG_MESSAGE;
        case 11: return MT_PREVIEW;
        case 12: return MT_PROGRESS;
        case 13: return MT_INTERP_STAT;
        case 18: return MT_SYSLOG;
        case 19: return MT_LEGACY_NML;
        case 20: return MT_LEGACY_MOTCONFIG;
        case 26: return MT_STP_UPDATE_FULL;
        case 28: return MT_STP_UPDATE;
        case 27: return MT_STP_NOGROUP;
        case 45: return MT_SHUTDOWN;
        case 50: return MT_CONFIRM_SHUTDOWN;
        case 30: return MT_RTMESSAGE0;
        case 31: return MT_RTMESSAGE1;
        case 32: return MT_RTMESSAGE2;
        case 33: return MT_RTMESSAGE3;
        case 34: return MT_RTMESSAGE4;
        case 100: return MT_ASCII;
        case 101: return MT_UNICODE;
        case 102: return MT_GCODE;
        case 103: return MT_PYTHON;
        case 104: return MT_PICKLE;
        case 105: return MT_TCL;
        case 106: return MT_XML;
        case 107: return MT_JSON;
        case 108: return MT_JPEG;
        case 109: return MT_PNG;
        case 110: return MT_TIFF;
        case 111: return MT_POSTSCRIPT;
        case 112: return MT_SVG;
        case 150: return MT_ZMQ_SUBSCRIBE;
        case 151: return MT_ZMQ_UNSUBSCRIBE;
        case 210: return MT_PING;
        case 215: return MT_PING_ACKNOWLEDGE;
        case 220: return MT_REJECT;
        case 240: return MT_DONE;
        case 250: return MT_SERVICE_REQUEST;
        case 251: return MT_SERVICE_ANNOUNCEMENT;
        case 252: return MT_SERVICE_PROBE;
        case 255: return MT_MESSAGEBUS_NO_DESTINATION;
        case 256: return MT_HALRCOMP_BIND;
        case 257: return MT_HALRCOMP_BIND_CONFIRM;
        case 258: return MT_HALRCOMP_BIND_REJECT;
        case 259: return MT_HALRCOMP_SET;
        case 260: return MT_HALRCOMP_SET_REJECT;
        case 263: return MT_HALRCOMP_ACK;
        case 265: return MT_HALRCOMMAND_SET;
        case 266: return MT_HALRCOMMAND_SET_REJECT;
        case 267: return MT_HALRCOMMAND_GET;
        case 268: return MT_HALRCOMMAND_GET_REJECT;
        case 269: return MT_HALRCOMMAND_CREATE;
        case 270: return MT_HALRCOMMAND_CREATE_REJECT;
        case 271: return MT_HALRCOMMAND_DELETE;
        case 272: return MT_HALRCOMMAND_DELETE_REJECT;
        case 273: return MT_HALRCOMMAND_ACK;
        case 274: return MT_HALRCOMMAND_ERROR;
        case 276: return MT_HALRCOMMAND_DESCRIBE;
        case 277: return MT_HALRCOMMAND_DESCRIPTION;
        case 288: return MT_HALRCOMP_FULL_UPDATE;
        case 289: return MT_HALRCOMP_INCREMENTAL_UPDATE;
        case 290: return MT_HALRCOMP_ERROR;
        case 294: return MT_HALGROUP_BIND;
        case 295: return MT_HALGROUP_BIND_CONFIRM;
        case 296: return MT_HALGROUP_BIND_REJECT;
        case 297: return MT_HALGROUP_FULL_UPDATE;
        case 298: return MT_HALGROUP_INCREMENTAL_UPDATE;
        case 299: return MT_HALGROUP_ERROR;
        case 300: return MT_RTAPI_APP_EXIT;
        case 301: return MT_RTAPI_APP_PING;
        case 302: return MT_RTAPI_APP_LOADRT;
        case 303: return MT_RTAPI_APP_LOG;
        case 305: return MT_RTAPI_APP_UNLOADRT;
        case 306: return MT_RTAPI_APP_NEWINST;
        case 307: return MT_RTAPI_APP_NEWTHREAD;
        case 308: return MT_RTAPI_APP_DELTHREAD;
        case 309: return MT_RTAPI_APP_CALLFUNC;
        case 310: return MT_RTAPI_APP_REPLY;
        case 311: return MT_RTAPI_APP_DELINST;
        case 350: return MT_LIST_APPLICATIONS;
        case 351: return MT_DESCRIBE_APPLICATION;
        case 352: return MT_RETRIEVE_APPLICATION;
        case 353: return MT_APPLICATION_DETAIL;
        case 360: return MT_ERROR;
        case 400: return MT_TASK_REPLY;
        case 401: return MT_TICKET_UPDATE;
        case 450: return MT_CREDIT_UPDATE;
        case 1000: return MT_EMCMOT_LOWER;
        case 1100: return MT_EMCMOT_UPPER;
        case 1001: return MT_EMCMOT_ABORT;
        case 1002: return MT_EMCMOT_AXIS_ABORT;
        case 1003: return MT_EMCMOT_ENABLE;
        case 1004: return MT_EMCMOT_DISABLE;
        case 1005: return MT_EMCMOT_ENABLE_AMPLIFIER;
        case 1006: return MT_EMCMOT_DISABLE_AMPLIFIER;
        case 1007: return MT_EMCMOT_ENABLE_WATCHDOG;
        case 1008: return MT_EMCMOT_DISABLE_WATCHDOG;
        case 1009: return MT_EMCMOT_ACTIVATE_JOINT;
        case 1010: return MT_EMCMOT_DEACTIVATE_JOINT;
        case 1011: return MT_EMCMOT_PAUSE;
        case 1012: return MT_EMCMOT_RESUME;
        case 1013: return MT_EMCMOT_STEP;
        case 1014: return MT_EMCMOT_FREE;
        case 1015: return MT_EMCMOT_COORD;
        case 1016: return MT_EMCMOT_TELEOP;
        case 1017: return MT_EMCMOT_SPINDLE_SCALE;
        case 1018: return MT_EMCMOT_SS_ENABLE;
        case 1019: return MT_EMCMOT_FEED_SCALE;
        case 1020: return MT_EMCMOT_FS_ENABLE;
        case 1021: return MT_EMCMOT_FH_ENABLE;
        case 1022: return MT_EMCMOT_AF_ENABLE;
        case 1023: return MT_EMCMOT_OVERRIDE_LIMITS;
        case 1024: return MT_EMCMOT_HOME;
        case 1025: return MT_EMCMOT_UNHOME;
        case 1026: return MT_EMCMOT_JOG_CONT;
        case 1027: return MT_EMCMOT_JOG_INCR;
        case 1028: return MT_EMCMOT_JOG_ABS;
        case 1029: return MT_EMCMOT_SET_LINE;
        case 1030: return MT_EMCMOT_SET_CIRCLE;
        case 1031: return MT_EMCMOT_SET_TELEOP_VECTOR;
        case 1032: return MT_EMCMOT_CLEAR_PROBE_FLAGS;
        case 1033: return MT_EMCMOT_PROBE;
        case 1034: return MT_EMCMOT_RIGID_TAP;
        case 1035: return MT_EMCMOT_SET_POSITION_LIMITS;
        case 1036: return MT_EMCMOT_SET_BACKLASH;
        case 1037: return MT_EMCMOT_SET_MIN_FERROR;
        case 1038: return MT_EMCMOT_SET_MAX_FERROR;
        case 1039: return MT_EMCMOT_SET_VEL;
        case 1040: return MT_EMCMOT_SET_VEL_LIMIT;
        case 1041: return MT_EMCMOT_SET_JOINT_VEL_LIMIT;
        case 1042: return MT_EMCMOT_SET_JOINT_ACC_LIMIT;
        case 1043: return MT_EMCMOT_SET_ACC;
        case 1044: return MT_EMCMOT_SET_TERM_COND;
        case 1045: return MT_EMCMOT_SET_NUM_AXES;
        case 1046: return MT_EMCMOT_SET_WORLD_HOME;
        case 1047: return MT_EMCMOT_SET_HOMING_PARAMS;
        case 1048: return MT_EMCMOT_SET_DEBUG;
        case 1049: return MT_EMCMOT_SET_DOUT;
        case 1050: return MT_EMCMOT_SET_AOUT;
        case 1051: return MT_EMCMOT_SET_SPINDLESYNC;
        case 1052: return MT_EMCMOT_SPINDLE_ON;
        case 1053: return MT_EMCMOT_SPINDLE_OFF;
        case 1054: return MT_EMCMOT_SPINDLE_INCREASE;
        case 1055: return MT_EMCMOT_SPINDLE_DECREASE;
        case 1056: return MT_EMCMOT_SPINDLE_BRAKE_ENGAGE;
        case 1057: return MT_EMCMOT_SPINDLE_BRAKE_RELEASE;
        case 1058: return MT_EMCMOT_SET_MOTOR_OFFSET;
        case 1059: return MT_EMCMOT_SET_JOINT_COMP;
        case 1060: return MT_EMCMOT_SET_OFFSET;
        case 1061: return MT_EMCMOT_COMMAND_OK;
        case 1062: return MT_EMCMOT_COMMAND_UNKNOWN_COMMAND;
        case 1063: return MT_EMCMOT_COMMAND_INVALID_COMMAND;
        case 1064: return MT_EMCMOT_COMMAND_INVALID_PARAMS;
        case 1065: return MT_EMCMOT_COMMAND_BAD_EXEC;
        case 1066: return MT_EMCMOT_MOTION_DISABLED;
        case 1067: return MT_EMCMOT_MOTION_FREE;
        case 1068: return MT_EMCMOT_MOTION_TELEOP;
        case 1069: return MT_EMCMOT_MOTION_COORD;
        case 1070: return MT_EMCMOT_JOINT_FLAG;
        case 1071: return MT_EMCMOT_MOTION_FLAG;
        case 2048: return MT_PRU_FIRMWARE;
        case 3000: return MT_MESA_5I20_FIRMWARE;
        case 4000: return MT_BLOB;
        case 5001: return MT_TEST1;
        case 5002: return MT_TEST2;
        case 5003: return MT_TEST3;
        case 10000: return MT_EMC_NML_LOWER;
        case 13000: return MT_EMC_NML_UPPER;
        case 10011: return MT_EMC_OPERATOR_ERROR;
        case 10012: return MT_EMC_OPERATOR_TEXT;
        case 10013: return MT_EMC_OPERATOR_DISPLAY;
        case 10021: return MT_EMC_NULL;
        case 10022: return MT_EMC_SET_DEBUG;
        case 10030: return MT_EMC_SYSTEM_CMD;
        case 10101: return MT_EMC_AXIS_SET_AXIS;
        case 10102: return MT_EMC_AXIS_SET_UNITS;
        case 10107: return MT_EMC_AXIS_SET_MIN_POSITION_LIMIT;
        case 10108: return MT_EMC_AXIS_SET_MAX_POSITION_LIMIT;
        case 1110: return MT_EMC_TOOL_START_CHANGE;
        case 1112: return MT_EMC_EXEC_PLUGIN_CALL;
        case 1113: return MT_EMC_IO_PLUGIN_CALL;
        case 10111: return MT_EMC_AXIS_SET_FERROR;
        case 10112: return MT_EMC_AXIS_SET_HOMING_PARAMS;
        case 10115: return MT_EMC_AXIS_SET_MIN_FERROR;
        case 10116: return MT_EMC_AXIS_SET_MAX_VELOCITY;
        case 10118: return MT_EMC_AXIS_INIT;
        case 10119: return MT_EMC_AXIS_HALT;
        case 10120: return MT_EMC_AXIS_ABORT;
        case 10121: return MT_EMC_AXIS_ENABLE;
        case 10122: return MT_EMC_AXIS_DISABLE;
        case 10123: return MT_EMC_AXIS_HOME;
        case 10135: return MT_EMC_AXIS_UNHOME;
        case 10124: return MT_EMC_AXIS_JOG;
        case 10125: return MT_EMC_AXIS_INCR_JOG;
        case 10126: return MT_EMC_AXIS_ABS_JOG;
        case 10127: return MT_EMC_AXIS_ACTIVATE;
        case 10128: return MT_EMC_AXIS_DEACTIVATE;
        case 10129: return MT_EMC_AXIS_OVERRIDE_LIMITS;
        case 10131: return MT_EMC_AXIS_LOAD_COMP;
        case 10134: return MT_EMC_AXIS_SET_BACKLASH;
        case 10199: return MT_EMC_AXIS_STAT;
        case 10201: return MT_EMC_TRAJ_SET_AXES;
        case 10202: return MT_EMC_TRAJ_SET_UNITS;
        case 10203: return MT_EMC_TRAJ_SET_CYCLE_TIME;
        case 10204: return MT_EMC_TRAJ_SET_MODE;
        case 10205: return MT_EMC_TRAJ_SET_VELOCITY;
        case 10206: return MT_EMC_TRAJ_SET_ACCELERATION;
        case 10207: return MT_EMC_TRAJ_SET_MAX_VELOCITY;
        case 10208: return MT_EMC_TRAJ_SET_MAX_ACCELERATION;
        case 10209: return MT_EMC_TRAJ_SET_SCALE;
        case 10210: return MT_EMC_TRAJ_SET_MOTION_ID;
        case 10211: return MT_EMC_TRAJ_INIT;
        case 10212: return MT_EMC_TRAJ_HALT;
        case 10213: return MT_EMC_TRAJ_ENABLE;
        case 10214: return MT_EMC_TRAJ_DISABLE;
        case 10215: return MT_EMC_TRAJ_ABORT;
        case 10216: return MT_EMC_TRAJ_PAUSE;
        case 10217: return MT_EMC_TRAJ_STEP;
        case 10218: return MT_EMC_TRAJ_RESUME;
        case 10219: return MT_EMC_TRAJ_DELAY;
        case 10220: return MT_EMC_TRAJ_LINEAR_MOVE;
        case 10221: return MT_EMC_TRAJ_CIRCULAR_MOVE;
        case 10222: return MT_EMC_TRAJ_SET_TERM_COND;
        case 10223: return MT_EMC_TRAJ_SET_OFFSET;
        case 10224: return MT_EMC_TRAJ_SET_G5X;
        case 10225: return MT_EMC_TRAJ_SET_HOME;
        case 10226: return MT_EMC_TRAJ_SET_ROTATION;
        case 10227: return MT_EMC_TRAJ_SET_G92;
        case 10228: return MT_EMC_TRAJ_CLEAR_PROBE_TRIPPED_FLAG;
        case 10229: return MT_EMC_TRAJ_PROBE;
        case 10230: return MT_EMC_TRAJ_SET_TELEOP_ENABLE;
        case 10231: return MT_EMC_TRAJ_SET_TELEOP_VECTOR;
        case 10232: return MT_EMC_TRAJ_SET_SPINDLESYNC;
        case 10233: return MT_EMC_TRAJ_SET_SPINDLE_SCALE;
        case 10234: return MT_EMC_TRAJ_SET_FO_ENABLE;
        case 10235: return MT_EMC_TRAJ_SET_SO_ENABLE;
        case 10236: return MT_EMC_TRAJ_SET_FH_ENABLE;
        case 10237: return MT_EMC_TRAJ_RIGID_TAP;
        case 10299: return MT_EMC_TRAJ_STAT;
        case 10301: return MT_EMC_MOTION_INIT;
        case 10302: return MT_EMC_MOTION_HALT;
        case 10303: return MT_EMC_MOTION_ABORT;
        case 10304: return MT_EMC_MOTION_SET_AOUT;
        case 10305: return MT_EMC_MOTION_SET_DOUT;
        case 10306: return MT_EMC_MOTION_ADAPTIVE;
        case 10317: return MT_EMC_SPINDLE_ORIENT;
        case 10318: return MT_EMC_SPINDLE_WAIT_ORIENT_COMPLETE;
        case 10399: return MT_EMC_MOTION_STAT;
        case 10501: return MT_EMC_TASK_INIT;
        case 10502: return MT_EMC_TASK_HALT;
        case 10503: return MT_EMC_TASK_ABORT;
        case 10504: return MT_EMC_TASK_SET_MODE;
        case 10505: return MT_EMC_TASK_SET_STATE;
        case 10506: return MT_EMC_TASK_PLAN_OPEN;
        case 10507: return MT_EMC_TASK_PLAN_RUN;
        case 10508: return MT_EMC_TASK_PLAN_READ;
        case 10509: return MT_EMC_TASK_PLAN_EXECUTE;
        case 10510: return MT_EMC_TASK_PLAN_PAUSE;
        case 10511: return MT_EMC_TASK_PLAN_STEP;
        case 10512: return MT_EMC_TASK_PLAN_RESUME;
        case 10513: return MT_EMC_TASK_PLAN_END;
        case 10514: return MT_EMC_TASK_PLAN_CLOSE;
        case 10515: return MT_EMC_TASK_PLAN_INIT;
        case 10516: return MT_EMC_TASK_PLAN_SYNCH;
        case 10517: return MT_EMC_TASK_PLAN_SET_OPTIONAL_STOP;
        case 10518: return MT_EMC_TASK_PLAN_SET_BLOCK_DELETE;
        case 10519: return MT_EMC_TASK_PLAN_OPTIONAL_STOP;
        case 10520: return MT_EMC_TASK_PLAN_RESET;
        case 10530: return MT_EMC_TASK_PLAN_REPLY;
        case 10599: return MT_EMC_TASK_STAT;
        case 11101: return MT_EMC_TOOL_INIT;
        case 11102: return MT_EMC_TOOL_HALT;
        case 11103: return MT_EMC_TOOL_ABORT;
        case 11104: return MT_EMC_TOOL_PREPARE;
        case 11105: return MT_EMC_TOOL_LOAD;
        case 11106: return MT_EMC_TOOL_UNLOAD;
        case 11107: return MT_EMC_TOOL_LOAD_TOOL_TABLE;
        case 11108: return MT_EMC_TOOL_SET_OFFSET;
        case 11109: return MT_EMC_TOOL_SET_NUMBER;
        case 11199: return MT_EMC_TOOL_STAT;
        case 11206: return MT_EMC_AUX_ESTOP_ON;
        case 11207: return MT_EMC_AUX_ESTOP_OFF;
        case 11208: return MT_EMC_AUX_ESTOP_RESET;
        case 11209: return MT_EMC_AUX_INPUT_WAIT;
        case 11299: return MT_EMC_AUX_STAT;
        case 11304: return MT_EMC_SPINDLE_ON;
        case 11305: return MT_EMC_SPINDLE_OFF;
        case 11309: return MT_EMC_SPINDLE_INCREASE;
        case 11310: return MT_EMC_SPINDLE_DECREASE;
        case 11311: return MT_EMC_SPINDLE_CONSTANT;
        case 11312: return MT_EMC_SPINDLE_BRAKE_RELEASE;
        case 11313: return MT_EMC_SPINDLE_BRAKE_ENGAGE;
        case 11316: return MT_EMC_SPINDLE_SPEED;
        case 11399: return MT_EMC_SPINDLE_STAT;
        case 11404: return MT_EMC_COOLANT_MIST_ON;
        case 11405: return MT_EMC_COOLANT_MIST_OFF;
        case 11406: return MT_EMC_COOLANT_FLOOD_ON;
        case 11407: return MT_EMC_COOLANT_FLOOD_OFF;
        case 11499: return MT_EMC_COOLANT_STAT;
        case 11504: return MT_EMC_LUBE_ON;
        case 11505: return MT_EMC_LUBE_OFF;
        case 11599: return MT_EMC_LUBE_STAT;
        case 11601: return MT_EMC_IO_INIT;
        case 11602: return MT_EMC_IO_HALT;
        case 11603: return MT_EMC_IO_ABORT;
        case 11604: return MT_EMC_IO_SET_CYCLE_TIME;
        case 11699: return MT_EMC_IO_STAT;
        case 11901: return MT_EMC_INIT;
        case 11902: return MT_EMC_HALT;
        case 11903: return MT_EMC_ABORT;
        case 11999: return MT_EMC_STAT;
        case 12500: return MT_EMCSTAT_FULL_UPDATE;
        case 12501: return MT_EMCSTAT_INCREMENTAL_UPDATE;
        case 12510: return MT_EMC_NML_ERROR;
        case 12511: return MT_EMC_NML_TEXT;
        case 12512: return MT_EMC_NML_DISPLAY;
        case 12520: return MT_EMCCMD_EXECUTED;
        case 12521: return MT_EMCCMD_COMPLETED;
        case 12600: return MT_LAUNCHER_FULL_UPDATE;
        case 12601: return MT_LAUNCHER_INCREMENTAL_UPDATE;
        case 12602: return MT_LAUNCHER_ERROR;
        case 12610: return MT_LAUNCHER_START;
        case 12611: return MT_LAUNCHER_TERMINATE;
        case 12612: return MT_LAUNCHER_KILL;
        case 12613: return MT_LAUNCHER_WRITE_STDIN;
        case 12614: return MT_LAUNCHER_CALL;
        case 12615: return MT_LAUNCHER_SHUTDOWN;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<ContainerType>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<ContainerType>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<ContainerType>() {
            public ContainerType findValueByNumber(int number) {
              return ContainerType.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return pb.Types.getDescriptor().getEnumTypes().get(14);
    }

    private static final ContainerType[] VALUES = values();

    public static ContainerType valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new java.lang.IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private ContainerType(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:pb.ContainerType)
  }

  /**
   * Protobuf enum {@code pb.OriginIndex}
   */
  public enum OriginIndex
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>ORIGIN_UNKNOWN = 0;</code>
     */
    ORIGIN_UNKNOWN(0, 0),
    /**
     * <code>ORIGIN_G54 = 1;</code>
     */
    ORIGIN_G54(1, 1),
    /**
     * <code>ORIGIN_G55 = 2;</code>
     */
    ORIGIN_G55(2, 2),
    /**
     * <code>ORIGIN_G56 = 3;</code>
     */
    ORIGIN_G56(3, 3),
    /**
     * <code>ORIGIN_G57 = 4;</code>
     */
    ORIGIN_G57(4, 4),
    /**
     * <code>ORIGIN_G58 = 5;</code>
     */
    ORIGIN_G58(5, 5),
    /**
     * <code>ORIGIN_G59 = 6;</code>
     */
    ORIGIN_G59(6, 6),
    /**
     * <code>ORIGIN_G59_1 = 7;</code>
     */
    ORIGIN_G59_1(7, 7),
    /**
     * <code>ORIGIN_G59_2 = 8;</code>
     */
    ORIGIN_G59_2(8, 8),
    /**
     * <code>ORIGIN_G59_3 = 9;</code>
     */
    ORIGIN_G59_3(9, 9),
    ;

    /**
     * <code>ORIGIN_UNKNOWN = 0;</code>
     */
    public static final int ORIGIN_UNKNOWN_VALUE = 0;
    /**
     * <code>ORIGIN_G54 = 1;</code>
     */
    public static final int ORIGIN_G54_VALUE = 1;
    /**
     * <code>ORIGIN_G55 = 2;</code>
     */
    public static final int ORIGIN_G55_VALUE = 2;
    /**
     * <code>ORIGIN_G56 = 3;</code>
     */
    public static final int ORIGIN_G56_VALUE = 3;
    /**
     * <code>ORIGIN_G57 = 4;</code>
     */
    public static final int ORIGIN_G57_VALUE = 4;
    /**
     * <code>ORIGIN_G58 = 5;</code>
     */
    public static final int ORIGIN_G58_VALUE = 5;
    /**
     * <code>ORIGIN_G59 = 6;</code>
     */
    public static final int ORIGIN_G59_VALUE = 6;
    /**
     * <code>ORIGIN_G59_1 = 7;</code>
     */
    public static final int ORIGIN_G59_1_VALUE = 7;
    /**
     * <code>ORIGIN_G59_2 = 8;</code>
     */
    public static final int ORIGIN_G59_2_VALUE = 8;
    /**
     * <code>ORIGIN_G59_3 = 9;</code>
     */
    public static final int ORIGIN_G59_3_VALUE = 9;


    public final int getNumber() { return value; }

    public static OriginIndex valueOf(int value) {
      switch (value) {
        case 0: return ORIGIN_UNKNOWN;
        case 1: return ORIGIN_G54;
        case 2: return ORIGIN_G55;
        case 3: return ORIGIN_G56;
        case 4: return ORIGIN_G57;
        case 5: return ORIGIN_G58;
        case 6: return ORIGIN_G59;
        case 7: return ORIGIN_G59_1;
        case 8: return ORIGIN_G59_2;
        case 9: return ORIGIN_G59_3;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<OriginIndex>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<OriginIndex>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<OriginIndex>() {
            public OriginIndex findValueByNumber(int number) {
              return OriginIndex.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return pb.Types.getDescriptor().getEnumTypes().get(15);
    }

    private static final OriginIndex[] VALUES = values();

    public static OriginIndex valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new java.lang.IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private OriginIndex(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:pb.OriginIndex)
  }

  /**
   * Protobuf enum {@code pb.TermConditionType}
   *
   * <pre>
   * add leading _ to avoid collision with macros in emc.hh
   * </pre>
   */
  public enum TermConditionType
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>_EMC_TRAJ_TERM_COND_STOP = 1;</code>
     */
    _EMC_TRAJ_TERM_COND_STOP(0, 1),
    /**
     * <code>_EMC_TRAJ_TERM_COND_BLEND = 2;</code>
     */
    _EMC_TRAJ_TERM_COND_BLEND(1, 2),
    ;

    /**
     * <code>_EMC_TRAJ_TERM_COND_STOP = 1;</code>
     */
    public static final int _EMC_TRAJ_TERM_COND_STOP_VALUE = 1;
    /**
     * <code>_EMC_TRAJ_TERM_COND_BLEND = 2;</code>
     */
    public static final int _EMC_TRAJ_TERM_COND_BLEND_VALUE = 2;


    public final int getNumber() { return value; }

    public static TermConditionType valueOf(int value) {
      switch (value) {
        case 1: return _EMC_TRAJ_TERM_COND_STOP;
        case 2: return _EMC_TRAJ_TERM_COND_BLEND;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<TermConditionType>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<TermConditionType>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<TermConditionType>() {
            public TermConditionType findValueByNumber(int number) {
              return TermConditionType.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return pb.Types.getDescriptor().getEnumTypes().get(16);
    }

    private static final TermConditionType[] VALUES = values();

    public static TermConditionType valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new java.lang.IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private TermConditionType(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:pb.TermConditionType)
  }

  /**
   * Protobuf enum {@code pb.CanonDirection}
   */
  public enum CanonDirection
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>_CANON_STOPPED = 1;</code>
     */
    _CANON_STOPPED(0, 1),
    /**
     * <code>_CANON_CLOCKWISE = 2;</code>
     */
    _CANON_CLOCKWISE(1, 2),
    /**
     * <code>_CANON_COUNTERCLOCKWISE = 3;</code>
     */
    _CANON_COUNTERCLOCKWISE(2, 3),
    ;

    /**
     * <code>_CANON_STOPPED = 1;</code>
     */
    public static final int _CANON_STOPPED_VALUE = 1;
    /**
     * <code>_CANON_CLOCKWISE = 2;</code>
     */
    public static final int _CANON_CLOCKWISE_VALUE = 2;
    /**
     * <code>_CANON_COUNTERCLOCKWISE = 3;</code>
     */
    public static final int _CANON_COUNTERCLOCKWISE_VALUE = 3;


    public final int getNumber() { return value; }

    public static CanonDirection valueOf(int value) {
      switch (value) {
        case 1: return _CANON_STOPPED;
        case 2: return _CANON_CLOCKWISE;
        case 3: return _CANON_COUNTERCLOCKWISE;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<CanonDirection>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<CanonDirection>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<CanonDirection>() {
            public CanonDirection findValueByNumber(int number) {
              return CanonDirection.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return pb.Types.getDescriptor().getEnumTypes().get(17);
    }

    private static final CanonDirection[] VALUES = values();

    public static CanonDirection valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new java.lang.IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private CanonDirection(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:pb.CanonDirection)
  }

  /**
   * Protobuf enum {@code pb.InputType}
   */
  public enum InputType
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>_ANALOG_INPUT = 0;</code>
     */
    _ANALOG_INPUT(0, 0),
    /**
     * <code>_DIGITAL_INPUT = 1;</code>
     */
    _DIGITAL_INPUT(1, 1),
    ;

    /**
     * <code>_ANALOG_INPUT = 0;</code>
     */
    public static final int _ANALOG_INPUT_VALUE = 0;
    /**
     * <code>_DIGITAL_INPUT = 1;</code>
     */
    public static final int _DIGITAL_INPUT_VALUE = 1;


    public final int getNumber() { return value; }

    public static InputType valueOf(int value) {
      switch (value) {
        case 0: return _ANALOG_INPUT;
        case 1: return _DIGITAL_INPUT;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<InputType>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<InputType>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<InputType>() {
            public InputType findValueByNumber(int number) {
              return InputType.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return pb.Types.getDescriptor().getEnumTypes().get(18);
    }

    private static final InputType[] VALUES = values();

    public static InputType valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new java.lang.IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private InputType(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:pb.InputType)
  }

  /**
   * Protobuf enum {@code pb.WaitType}
   */
  public enum WaitType
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>IMMEDIATE = 0;</code>
     */
    IMMEDIATE(0, 0),
    /**
     * <code>RISE = 1;</code>
     */
    RISE(1, 1),
    /**
     * <code>FALL = 2;</code>
     */
    FALL(2, 2),
    /**
     * <code>BE_HIGH = 3;</code>
     */
    BE_HIGH(3, 3),
    /**
     * <code>BE_LOW = 4;</code>
     */
    BE_LOW(4, 4),
    ;

    /**
     * <code>IMMEDIATE = 0;</code>
     */
    public static final int IMMEDIATE_VALUE = 0;
    /**
     * <code>RISE = 1;</code>
     */
    public static final int RISE_VALUE = 1;
    /**
     * <code>FALL = 2;</code>
     */
    public static final int FALL_VALUE = 2;
    /**
     * <code>BE_HIGH = 3;</code>
     */
    public static final int BE_HIGH_VALUE = 3;
    /**
     * <code>BE_LOW = 4;</code>
     */
    public static final int BE_LOW_VALUE = 4;


    public final int getNumber() { return value; }

    public static WaitType valueOf(int value) {
      switch (value) {
        case 0: return IMMEDIATE;
        case 1: return RISE;
        case 2: return FALL;
        case 3: return BE_HIGH;
        case 4: return BE_LOW;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<WaitType>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<WaitType>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<WaitType>() {
            public WaitType findValueByNumber(int number) {
              return WaitType.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return pb.Types.getDescriptor().getEnumTypes().get(19);
    }

    private static final WaitType[] VALUES = values();

    public static WaitType valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new java.lang.IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private WaitType(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:pb.WaitType)
  }

  /**
   * Protobuf enum {@code pb.InterpreterStateType}
   *
   * <pre>
   * types for EMC_TASK interpState
   * </pre>
   */
  public enum InterpreterStateType
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>INTERP_IDLE = 1;</code>
     */
    INTERP_IDLE(0, 1),
    /**
     * <code>INTERP_RUNNING = 2;</code>
     */
    INTERP_RUNNING(1, 2),
    /**
     * <code>INTERP_SYNC_WAIT = 3;</code>
     */
    INTERP_SYNC_WAIT(2, 3),
    /**
     * <code>INTERP_PAUSED = 4;</code>
     */
    INTERP_PAUSED(3, 4),
    /**
     * <code>INTERP_QUEUE_WAIT = 5;</code>
     */
    INTERP_QUEUE_WAIT(4, 5),
    /**
     * <code>INTERP_ABORT_WAIT = 6;</code>
     */
    INTERP_ABORT_WAIT(5, 6),
    /**
     * <code>INTERP_STATE_UNSET = 99;</code>
     *
     * <pre>
     * to ease change tracking
     * </pre>
     */
    INTERP_STATE_UNSET(6, 99),
    ;

    /**
     * <code>INTERP_IDLE = 1;</code>
     */
    public static final int INTERP_IDLE_VALUE = 1;
    /**
     * <code>INTERP_RUNNING = 2;</code>
     */
    public static final int INTERP_RUNNING_VALUE = 2;
    /**
     * <code>INTERP_SYNC_WAIT = 3;</code>
     */
    public static final int INTERP_SYNC_WAIT_VALUE = 3;
    /**
     * <code>INTERP_PAUSED = 4;</code>
     */
    public static final int INTERP_PAUSED_VALUE = 4;
    /**
     * <code>INTERP_QUEUE_WAIT = 5;</code>
     */
    public static final int INTERP_QUEUE_WAIT_VALUE = 5;
    /**
     * <code>INTERP_ABORT_WAIT = 6;</code>
     */
    public static final int INTERP_ABORT_WAIT_VALUE = 6;
    /**
     * <code>INTERP_STATE_UNSET = 99;</code>
     *
     * <pre>
     * to ease change tracking
     * </pre>
     */
    public static final int INTERP_STATE_UNSET_VALUE = 99;


    public final int getNumber() { return value; }

    public static InterpreterStateType valueOf(int value) {
      switch (value) {
        case 1: return INTERP_IDLE;
        case 2: return INTERP_RUNNING;
        case 3: return INTERP_SYNC_WAIT;
        case 4: return INTERP_PAUSED;
        case 5: return INTERP_QUEUE_WAIT;
        case 6: return INTERP_ABORT_WAIT;
        case 99: return INTERP_STATE_UNSET;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<InterpreterStateType>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<InterpreterStateType>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<InterpreterStateType>() {
            public InterpreterStateType findValueByNumber(int number) {
              return InterpreterStateType.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return pb.Types.getDescriptor().getEnumTypes().get(20);
    }

    private static final InterpreterStateType[] VALUES = values();

    public static InterpreterStateType valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new java.lang.IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private InterpreterStateType(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:pb.InterpreterStateType)
  }


  public static com.google.protobuf.Descriptors.FileDescriptor
      getDescriptor() {
    return descriptor;
  }
  private static com.google.protobuf.Descriptors.FileDescriptor
      descriptor;
  static {
    java.lang.String[] descriptorData = {
      "\n machinetalk/protobuf/types.proto\022\002pb\032!" +
      "machinetalk/protobuf/nanopb.proto*\335\001\n\tVa" +
      "lueType\022\013\n\007HAL_BIT\020\001\022\r\n\tHAL_FLOAT\020\002\022\013\n\007H" +
      "AL_S32\020\003\022\013\n\007HAL_U32\020\004\022\n\n\006STRING\020\005\022\t\n\005BYT" +
      "ES\020\006\022\t\n\005INT32\020\024\022\n\n\006UINT32\020\036\022\t\n\005INT64\020(\022\n" +
      "\n\006UINT64\0202\022\n\n\006DOUBLE\020<\022\010\n\004BOOL\020P\022\r\n\tCART" +
      "ESIAN\020d\022\024\n\020LEGACY_CARTESIAN\020n\022\010\n\004POSE\020x\022" +
      "\020\n\013LEGACY_POSE\020\202\001*6\n\017HalPinDirection\022\n\n\006" +
      "HAL_IN\020\020\022\013\n\007HAL_OUT\020 \022\n\n\006HAL_IO\0200*,\n\021Hal" +
      "ParamDirection\022\n\n\006HAL_RO\020@\022\013\n\006HAL_RW\020\300\001*",
      "\261\003\n\nObjectType\022\013\n\007HAL_PIN\020\001\022\016\n\nHAL_SIGNA" +
      "L\020\002\022\r\n\tHAL_PARAM\020\003\022\016\n\nHAL_THREAD\020\004\022\r\n\tHA" +
      "L_FUNCT\020\005\022\r\n\tHAL_ALIAS\020\006\022\017\n\013HAL_COMP_RT\020" +
      "\007\022\021\n\rHAL_COMP_USER\020\010\022\023\n\017HAL_COMP_REMOTE\020" +
      "\t\022\014\n\010HAL_RING\020\n\022\r\n\tHAL_GROUP\020\013\022\025\n\021HAL_ME" +
      "MBER_SIGNAL\020\014\022\024\n\020HAL_MEMBER_GROUP\020\r\022\022\n\016H" +
      "AL_MEMBER_PIN\020\016\022\024\n\020HAL_MEMBER_PARAM\020\017\022\017\n" +
      "\013RING_RECORD\020\020\022\017\n\013RING_STREAM\020\021\022\016\n\nHAL_V" +
      "TABLE\020\022\022\014\n\010HAL_INST\020\023\022\023\n\017RING_MULTIFRAME" +
      "\020\024\022\t\n\005VALUE\020x\022\014\n\010INSTANCE\020y\022\016\n\nORIGINATO",
      "R\020z\022\017\n\013NAMED_VALUE\020}\022\r\n\010OT_ERROR\020\202\001*l\n\nR" +
      "CS_STATUS\022!\n\024UNINITIALIZED_STATUS\020\377\377\377\377\377\377" +
      "\377\377\377\001\022\014\n\010RCS_DONE\020\001\022\014\n\010RCS_EXEC\020\002\022\r\n\tRCS_" +
      "ERROR\020\003\022\020\n\014RCS_RECEIVED\020\004*:\n\tMsgOrigin\022\016" +
      "\n\nMSG_KERNEL\020\000\022\016\n\nMSG_RTUSER\020\001\022\r\n\tMSG_UL" +
      "API\020\002*\177\n\010MsgLevel\022\022\n\016RTAPI_MSG_NONE\020\000\022\021\n" +
      "\rRTAPI_MSG_ERR\020\001\022\022\n\016RTAPI_MSG_WARN\020\002\022\022\n\016" +
      "RTAPI_MSG_INFO\020\003\022\021\n\rRTAPI_MSG_DBG\020\004\022\021\n\rR" +
      "TAPI_MSG_ALL\020\005*\240\001\n\014OriginDetail\022\017\n\013UNIX_" +
      "SIGNAL\020\n\022\025\n\021INSTANCE_SHUTDOWN\020\024\022\016\n\nZMQ_S",
      "OCKET\020F\022\r\n\tNML_LAYER\020P\022\r\n\tRCS_LAYER\020Z\022\r\n" +
      "\tCMS_LAYER\020d\022\014\n\010IP_LAYER\020n\022\r\n\tTCP_LAYER\020" +
      "x\022\016\n\tPGM_LAYER\020\202\001*\245\001\n\nOriginType\022\013\n\007PROC" +
      "ESS\020\n\022\017\n\013USER_THREAD\020\024\022\r\n\tRT_THREAD\020\036\022\r\n" +
      "\tCOMPONENT\020(\022\023\n\017THREAD_FUNCTION\0202\022\022\n\016COM" +
      "PONENT_INIT\020<\022\022\n\016COMPONENT_EXIT\020F\022\t\n\005GRO" +
      "UP\020P\022\007\n\003PIN\020Z\022\n\n\006SIGNAL\020d*:\n\010Severity\022\023\n" +
      "\017S_INFORMATIONAL\020\001\022\r\n\tS_WARNING\020\002\022\n\n\006S_F" +
      "AIL\020\004*D\n\nStatusType\022\014\n\010ENQUEUED\020\001\022\016\n\nPRO" +
      "CESSING\020\002\022\014\n\010COMPLETE\020\003\022\n\n\006FAILED\020\004*Y\n\tR",
      "eplyType\022\010\n\004NONE\020\000\022\020\n\014ON_RECEPTION\020\001\022\r\n\t" +
      "ON_QUEUED\020\002\022\021\n\rON_COMPLETION\020\004\022\016\n\tALL_ST" +
      "EPS\020\377\001*\326\002\n\013ServiceType\022\016\n\nST_LOGGING\020\001\022\r" +
      "\n\tST_CONFIG\020\002\022\014\n\010ST_REDIS\020\003\022\013\n\007ST_HTTP\020\004" +
      "\022\014\n\010ST_HTTPS\020\005\022\020\n\014ST_WEBSOCKET\020\006\022\021\n\rST_W" +
      "EBSOCKETS\020\007\022\024\n\020ST_RTAPI_COMMAND\020\010\022\023\n\017ST_" +
      "STP_HALGROUP\020\t\022\023\n\017ST_STP_HALRCOMP\020\n\022\021\n\rS" +
      "T_STP_INTERP\020\013\022\017\n\013ST_STP_TASK\020\014\022\023\n\017ST_HA" +
      "L_RCOMMAND\020\r\022\023\n\017ST_TASK_COMMAND\020\016\022\025\n\021ST_" +
      "INTERP_COMMAND\020\017\022\031\n\025ST_MESSAGEBUS_COMMAN",
      "D\020\020\022\032\n\026ST_MESSAGEBUS_RESPONSE\020\021*1\n\nServi" +
      "ceAPI\022\023\n\017SA_ZMQ_PROTOBUF\020\001\022\016\n\nSA_WS_JSON" +
      "\020\002*\222E\n\rContainerType\022\020\n\014MT_RTMESSAGE\020\002\022\r" +
      "\n\tMT_MOTCMD\020\003\022\020\n\014MT_MOTSTATUS\020\004\022\024\n\020MT_LE" +
      "GACY_MOTCMD\020\005\022\027\n\023MT_LEGACY_MOTSTATUS\020\006\022\n" +
      "\n\006MT_WOU\020\007\022\020\n\014MT_HALUPDATE\020\010\022\024\n\020MT_RTAPI" +
      "_MESSAGE\020\t\022\022\n\016MT_LOG_MESSAGE\020\n\022\016\n\nMT_PRE" +
      "VIEW\020\013\022\017\n\013MT_PROGRESS\020\014\022\022\n\016MT_INTERP_STA" +
      "T\020\r\022\r\n\tMT_SYSLOG\020\022\022\021\n\rMT_LEGACY_NML\020\023\022\027\n" +
      "\023MT_LEGACY_MOTCONFIG\020\024\022\026\n\022MT_STP_UPDATE_",
      "FULL\020\032\022\021\n\rMT_STP_UPDATE\020\034\022\022\n\016MT_STP_NOGR" +
      "OUP\020\033\022\017\n\013MT_SHUTDOWN\020-\022\027\n\023MT_CONFIRM_SHU" +
      "TDOWN\0202\022\021\n\rMT_RTMESSAGE0\020\036\022\021\n\rMT_RTMESSA" +
      "GE1\020\037\022\021\n\rMT_RTMESSAGE2\020 \022\021\n\rMT_RTMESSAGE" +
      "3\020!\022\021\n\rMT_RTMESSAGE4\020\"\022\014\n\010MT_ASCII\020d\022\016\n\n" +
      "MT_UNICODE\020e\022\014\n\010MT_GCODE\020f\022\r\n\tMT_PYTHON\020" +
      "g\022\r\n\tMT_PICKLE\020h\022\n\n\006MT_TCL\020i\022\n\n\006MT_XML\020j" +
      "\022\013\n\007MT_JSON\020k\022\013\n\007MT_JPEG\020l\022\n\n\006MT_PNG\020m\022\013" +
      "\n\007MT_TIFF\020n\022\021\n\rMT_POSTSCRIPT\020o\022\n\n\006MT_SVG" +
      "\020p\022\025\n\020MT_ZMQ_SUBSCRIBE\020\226\001\022\027\n\022MT_ZMQ_UNSU",
      "BSCRIBE\020\227\001\022\014\n\007MT_PING\020\322\001\022\030\n\023MT_PING_ACKN" +
      "OWLEDGE\020\327\001\022\016\n\tMT_REJECT\020\334\001\022\014\n\007MT_DONE\020\360\001" +
      "\022\027\n\022MT_SERVICE_REQUEST\020\372\001\022\034\n\027MT_SERVICE_" +
      "ANNOUNCEMENT\020\373\001\022\025\n\020MT_SERVICE_PROBE\020\374\001\022!" +
      "\n\034MT_MESSAGEBUS_NO_DESTINATION\020\377\001\022\025\n\020MT_" +
      "HALRCOMP_BIND\020\200\002\022\035\n\030MT_HALRCOMP_BIND_CON" +
      "FIRM\020\201\002\022\034\n\027MT_HALRCOMP_BIND_REJECT\020\202\002\022\024\n" +
      "\017MT_HALRCOMP_SET\020\203\002\022\033\n\026MT_HALRCOMP_SET_R" +
      "EJECT\020\204\002\022\024\n\017MT_HALRCOMP_ACK\020\207\002\022\027\n\022MT_HAL" +
      "RCOMMAND_SET\020\211\002\022\036\n\031MT_HALRCOMMAND_SET_RE",
      "JECT\020\212\002\022\027\n\022MT_HALRCOMMAND_GET\020\213\002\022\036\n\031MT_H" +
      "ALRCOMMAND_GET_REJECT\020\214\002\022\032\n\025MT_HALRCOMMA" +
      "ND_CREATE\020\215\002\022!\n\034MT_HALRCOMMAND_CREATE_RE" +
      "JECT\020\216\002\022\032\n\025MT_HALRCOMMAND_DELETE\020\217\002\022!\n\034M" +
      "T_HALRCOMMAND_DELETE_REJECT\020\220\002\022\027\n\022MT_HAL" +
      "RCOMMAND_ACK\020\221\002\022\031\n\024MT_HALRCOMMAND_ERROR\020" +
      "\222\002\022\034\n\027MT_HALRCOMMAND_DESCRIBE\020\224\002\022\037\n\032MT_H" +
      "ALRCOMMAND_DESCRIPTION\020\225\002\022\034\n\027MT_HALRCOMP" +
      "_FULL_UPDATE\020\240\002\022#\n\036MT_HALRCOMP_INCREMENT" +
      "AL_UPDATE\020\241\002\022\026\n\021MT_HALRCOMP_ERROR\020\242\002\022\025\n\020",
      "MT_HALGROUP_BIND\020\246\002\022\035\n\030MT_HALGROUP_BIND_" +
      "CONFIRM\020\247\002\022\034\n\027MT_HALGROUP_BIND_REJECT\020\250\002" +
      "\022\034\n\027MT_HALGROUP_FULL_UPDATE\020\251\002\022#\n\036MT_HAL" +
      "GROUP_INCREMENTAL_UPDATE\020\252\002\022\026\n\021MT_HALGRO" +
      "UP_ERROR\020\253\002\022\026\n\021MT_RTAPI_APP_EXIT\020\254\002\022\026\n\021M" +
      "T_RTAPI_APP_PING\020\255\002\022\030\n\023MT_RTAPI_APP_LOAD" +
      "RT\020\256\002\022\025\n\020MT_RTAPI_APP_LOG\020\257\002\022\032\n\025MT_RTAPI" +
      "_APP_UNLOADRT\020\261\002\022\031\n\024MT_RTAPI_APP_NEWINST" +
      "\020\262\002\022\033\n\026MT_RTAPI_APP_NEWTHREAD\020\263\002\022\033\n\026MT_R" +
      "TAPI_APP_DELTHREAD\020\264\002\022\032\n\025MT_RTAPI_APP_CA",
      "LLFUNC\020\265\002\022\027\n\022MT_RTAPI_APP_REPLY\020\266\002\022\031\n\024MT" +
      "_RTAPI_APP_DELINST\020\267\002\022\031\n\024MT_LIST_APPLICA" +
      "TIONS\020\336\002\022\034\n\027MT_DESCRIBE_APPLICATION\020\337\002\022\034" +
      "\n\027MT_RETRIEVE_APPLICATION\020\340\002\022\032\n\025MT_APPLI" +
      "CATION_DETAIL\020\341\002\022\r\n\010MT_ERROR\020\350\002\022\022\n\rMT_TA" +
      "SK_REPLY\020\220\003\022\025\n\020MT_TICKET_UPDATE\020\221\003\022\025\n\020MT" +
      "_CREDIT_UPDATE\020\302\003\022\024\n\017MT_EMCMOT_LOWER\020\350\007\022" +
      "\024\n\017MT_EMCMOT_UPPER\020\314\010\022\024\n\017MT_EMCMOT_ABORT" +
      "\020\351\007\022\031\n\024MT_EMCMOT_AXIS_ABORT\020\352\007\022\025\n\020MT_EMC" +
      "MOT_ENABLE\020\353\007\022\026\n\021MT_EMCMOT_DISABLE\020\354\007\022\037\n",
      "\032MT_EMCMOT_ENABLE_AMPLIFIER\020\355\007\022 \n\033MT_EMC" +
      "MOT_DISABLE_AMPLIFIER\020\356\007\022\036\n\031MT_EMCMOT_EN" +
      "ABLE_WATCHDOG\020\357\007\022\037\n\032MT_EMCMOT_DISABLE_WA" +
      "TCHDOG\020\360\007\022\035\n\030MT_EMCMOT_ACTIVATE_JOINT\020\361\007" +
      "\022\037\n\032MT_EMCMOT_DEACTIVATE_JOINT\020\362\007\022\024\n\017MT_" +
      "EMCMOT_PAUSE\020\363\007\022\025\n\020MT_EMCMOT_RESUME\020\364\007\022\023" +
      "\n\016MT_EMCMOT_STEP\020\365\007\022\023\n\016MT_EMCMOT_FREE\020\366\007" +
      "\022\024\n\017MT_EMCMOT_COORD\020\367\007\022\025\n\020MT_EMCMOT_TELE" +
      "OP\020\370\007\022\034\n\027MT_EMCMOT_SPINDLE_SCALE\020\371\007\022\030\n\023M" +
      "T_EMCMOT_SS_ENABLE\020\372\007\022\031\n\024MT_EMCMOT_FEED_",
      "SCALE\020\373\007\022\030\n\023MT_EMCMOT_FS_ENABLE\020\374\007\022\030\n\023MT" +
      "_EMCMOT_FH_ENABLE\020\375\007\022\030\n\023MT_EMCMOT_AF_ENA" +
      "BLE\020\376\007\022\036\n\031MT_EMCMOT_OVERRIDE_LIMITS\020\377\007\022\023" +
      "\n\016MT_EMCMOT_HOME\020\200\010\022\025\n\020MT_EMCMOT_UNHOME\020" +
      "\201\010\022\027\n\022MT_EMCMOT_JOG_CONT\020\202\010\022\027\n\022MT_EMCMOT" +
      "_JOG_INCR\020\203\010\022\026\n\021MT_EMCMOT_JOG_ABS\020\204\010\022\027\n\022" +
      "MT_EMCMOT_SET_LINE\020\205\010\022\031\n\024MT_EMCMOT_SET_C" +
      "IRCLE\020\206\010\022 \n\033MT_EMCMOT_SET_TELEOP_VECTOR\020" +
      "\207\010\022 \n\033MT_EMCMOT_CLEAR_PROBE_FLAGS\020\210\010\022\024\n\017" +
      "MT_EMCMOT_PROBE\020\211\010\022\030\n\023MT_EMCMOT_RIGID_TA",
      "P\020\212\010\022\"\n\035MT_EMCMOT_SET_POSITION_LIMITS\020\213\010" +
      "\022\033\n\026MT_EMCMOT_SET_BACKLASH\020\214\010\022\035\n\030MT_EMCM" +
      "OT_SET_MIN_FERROR\020\215\010\022\035\n\030MT_EMCMOT_SET_MA" +
      "X_FERROR\020\216\010\022\026\n\021MT_EMCMOT_SET_VEL\020\217\010\022\034\n\027M" +
      "T_EMCMOT_SET_VEL_LIMIT\020\220\010\022\"\n\035MT_EMCMOT_S" +
      "ET_JOINT_VEL_LIMIT\020\221\010\022\"\n\035MT_EMCMOT_SET_J" +
      "OINT_ACC_LIMIT\020\222\010\022\026\n\021MT_EMCMOT_SET_ACC\020\223" +
      "\010\022\034\n\027MT_EMCMOT_SET_TERM_COND\020\224\010\022\033\n\026MT_EM" +
      "CMOT_SET_NUM_AXES\020\225\010\022\035\n\030MT_EMCMOT_SET_WO" +
      "RLD_HOME\020\226\010\022 \n\033MT_EMCMOT_SET_HOMING_PARA",
      "MS\020\227\010\022\030\n\023MT_EMCMOT_SET_DEBUG\020\230\010\022\027\n\022MT_EM" +
      "CMOT_SET_DOUT\020\231\010\022\027\n\022MT_EMCMOT_SET_AOUT\020\232" +
      "\010\022\036\n\031MT_EMCMOT_SET_SPINDLESYNC\020\233\010\022\031\n\024MT_" +
      "EMCMOT_SPINDLE_ON\020\234\010\022\032\n\025MT_EMCMOT_SPINDL" +
      "E_OFF\020\235\010\022\037\n\032MT_EMCMOT_SPINDLE_INCREASE\020\236" +
      "\010\022\037\n\032MT_EMCMOT_SPINDLE_DECREASE\020\237\010\022#\n\036MT" +
      "_EMCMOT_SPINDLE_BRAKE_ENGAGE\020\240\010\022$\n\037MT_EM" +
      "CMOT_SPINDLE_BRAKE_RELEASE\020\241\010\022\037\n\032MT_EMCM" +
      "OT_SET_MOTOR_OFFSET\020\242\010\022\035\n\030MT_EMCMOT_SET_" +
      "JOINT_COMP\020\243\010\022\031\n\024MT_EMCMOT_SET_OFFSET\020\244\010",
      "\022\031\n\024MT_EMCMOT_COMMAND_OK\020\245\010\022&\n!MT_EMCMOT" +
      "_COMMAND_UNKNOWN_COMMAND\020\246\010\022&\n!MT_EMCMOT" +
      "_COMMAND_INVALID_COMMAND\020\247\010\022%\n MT_EMCMOT" +
      "_COMMAND_INVALID_PARAMS\020\250\010\022\037\n\032MT_EMCMOT_" +
      "COMMAND_BAD_EXEC\020\251\010\022\036\n\031MT_EMCMOT_MOTION_" +
      "DISABLED\020\252\010\022\032\n\025MT_EMCMOT_MOTION_FREE\020\253\010\022" +
      "\034\n\027MT_EMCMOT_MOTION_TELEOP\020\254\010\022\033\n\026MT_EMCM" +
      "OT_MOTION_COORD\020\255\010\022\031\n\024MT_EMCMOT_JOINT_FL" +
      "AG\020\256\010\022\032\n\025MT_EMCMOT_MOTION_FLAG\020\257\010\022\024\n\017MT_" +
      "PRU_FIRMWARE\020\200\020\022\032\n\025MT_MESA_5I20_FIRMWARE",
      "\020\270\027\022\014\n\007MT_BLOB\020\240\037\022\r\n\010MT_TEST1\020\211\'\022\r\n\010MT_T" +
      "EST2\020\212\'\022\r\n\010MT_TEST3\020\213\'\022\025\n\020MT_EMC_NML_LOW" +
      "ER\020\220N\022\025\n\020MT_EMC_NML_UPPER\020\310e\022\032\n\025MT_EMC_O" +
      "PERATOR_ERROR\020\233N\022\031\n\024MT_EMC_OPERATOR_TEXT" +
      "\020\234N\022\034\n\027MT_EMC_OPERATOR_DISPLAY\020\235N\022\020\n\013MT_" +
      "EMC_NULL\020\245N\022\025\n\020MT_EMC_SET_DEBUG\020\246N\022\026\n\021MT" +
      "_EMC_SYSTEM_CMD\020\256N\022\031\n\024MT_EMC_AXIS_SET_AX" +
      "IS\020\365N\022\032\n\025MT_EMC_AXIS_SET_UNITS\020\366N\022\'\n\"MT_" +
      "EMC_AXIS_SET_MIN_POSITION_LIMIT\020\373N\022\'\n\"MT" +
      "_EMC_AXIS_SET_MAX_POSITION_LIMIT\020\374N\022\035\n\030M",
      "T_EMC_TOOL_START_CHANGE\020\326\010\022\034\n\027MT_EMC_EXE" +
      "C_PLUGIN_CALL\020\330\010\022\032\n\025MT_EMC_IO_PLUGIN_CAL" +
      "L\020\331\010\022\033\n\026MT_EMC_AXIS_SET_FERROR\020\377N\022\"\n\035MT_" +
      "EMC_AXIS_SET_HOMING_PARAMS\020\200O\022\037\n\032MT_EMC_" +
      "AXIS_SET_MIN_FERROR\020\203O\022!\n\034MT_EMC_AXIS_SE" +
      "T_MAX_VELOCITY\020\204O\022\025\n\020MT_EMC_AXIS_INIT\020\206O" +
      "\022\025\n\020MT_EMC_AXIS_HALT\020\207O\022\026\n\021MT_EMC_AXIS_A" +
      "BORT\020\210O\022\027\n\022MT_EMC_AXIS_ENABLE\020\211O\022\030\n\023MT_E" +
      "MC_AXIS_DISABLE\020\212O\022\025\n\020MT_EMC_AXIS_HOME\020\213" +
      "O\022\027\n\022MT_EMC_AXIS_UNHOME\020\227O\022\024\n\017MT_EMC_AXI",
      "S_JOG\020\214O\022\031\n\024MT_EMC_AXIS_INCR_JOG\020\215O\022\030\n\023M" +
      "T_EMC_AXIS_ABS_JOG\020\216O\022\031\n\024MT_EMC_AXIS_ACT" +
      "IVATE\020\217O\022\033\n\026MT_EMC_AXIS_DEACTIVATE\020\220O\022 \n" +
      "\033MT_EMC_AXIS_OVERRIDE_LIMITS\020\221O\022\032\n\025MT_EM" +
      "C_AXIS_LOAD_COMP\020\223O\022\035\n\030MT_EMC_AXIS_SET_B" +
      "ACKLASH\020\226O\022\025\n\020MT_EMC_AXIS_STAT\020\327O\022\031\n\024MT_" +
      "EMC_TRAJ_SET_AXES\020\331O\022\032\n\025MT_EMC_TRAJ_SET_" +
      "UNITS\020\332O\022\037\n\032MT_EMC_TRAJ_SET_CYCLE_TIME\020\333" +
      "O\022\031\n\024MT_EMC_TRAJ_SET_MODE\020\334O\022\035\n\030MT_EMC_T" +
      "RAJ_SET_VELOCITY\020\335O\022!\n\034MT_EMC_TRAJ_SET_A",
      "CCELERATION\020\336O\022!\n\034MT_EMC_TRAJ_SET_MAX_VE" +
      "LOCITY\020\337O\022%\n MT_EMC_TRAJ_SET_MAX_ACCELER" +
      "ATION\020\340O\022\032\n\025MT_EMC_TRAJ_SET_SCALE\020\341O\022\036\n\031" +
      "MT_EMC_TRAJ_SET_MOTION_ID\020\342O\022\025\n\020MT_EMC_T" +
      "RAJ_INIT\020\343O\022\025\n\020MT_EMC_TRAJ_HALT\020\344O\022\027\n\022MT" +
      "_EMC_TRAJ_ENABLE\020\345O\022\030\n\023MT_EMC_TRAJ_DISAB" +
      "LE\020\346O\022\026\n\021MT_EMC_TRAJ_ABORT\020\347O\022\026\n\021MT_EMC_" +
      "TRAJ_PAUSE\020\350O\022\025\n\020MT_EMC_TRAJ_STEP\020\351O\022\027\n\022" +
      "MT_EMC_TRAJ_RESUME\020\352O\022\026\n\021MT_EMC_TRAJ_DEL" +
      "AY\020\353O\022\034\n\027MT_EMC_TRAJ_LINEAR_MOVE\020\354O\022\036\n\031M",
      "T_EMC_TRAJ_CIRCULAR_MOVE\020\355O\022\036\n\031MT_EMC_TR" +
      "AJ_SET_TERM_COND\020\356O\022\033\n\026MT_EMC_TRAJ_SET_O" +
      "FFSET\020\357O\022\030\n\023MT_EMC_TRAJ_SET_G5X\020\360O\022\031\n\024MT" +
      "_EMC_TRAJ_SET_HOME\020\361O\022\035\n\030MT_EMC_TRAJ_SET" +
      "_ROTATION\020\362O\022\030\n\023MT_EMC_TRAJ_SET_G92\020\363O\022)" +
      "\n$MT_EMC_TRAJ_CLEAR_PROBE_TRIPPED_FLAG\020\364" +
      "O\022\026\n\021MT_EMC_TRAJ_PROBE\020\365O\022\"\n\035MT_EMC_TRAJ" +
      "_SET_TELEOP_ENABLE\020\366O\022\"\n\035MT_EMC_TRAJ_SET" +
      "_TELEOP_VECTOR\020\367O\022 \n\033MT_EMC_TRAJ_SET_SPI" +
      "NDLESYNC\020\370O\022\"\n\035MT_EMC_TRAJ_SET_SPINDLE_S",
      "CALE\020\371O\022\036\n\031MT_EMC_TRAJ_SET_FO_ENABLE\020\372O\022" +
      "\036\n\031MT_EMC_TRAJ_SET_SO_ENABLE\020\373O\022\036\n\031MT_EM" +
      "C_TRAJ_SET_FH_ENABLE\020\374O\022\032\n\025MT_EMC_TRAJ_R" +
      "IGID_TAP\020\375O\022\025\n\020MT_EMC_TRAJ_STAT\020\273P\022\027\n\022MT" +
      "_EMC_MOTION_INIT\020\275P\022\027\n\022MT_EMC_MOTION_HAL" +
      "T\020\276P\022\030\n\023MT_EMC_MOTION_ABORT\020\277P\022\033\n\026MT_EMC" +
      "_MOTION_SET_AOUT\020\300P\022\033\n\026MT_EMC_MOTION_SET" +
      "_DOUT\020\301P\022\033\n\026MT_EMC_MOTION_ADAPTIVE\020\302P\022\032\n" +
      "\025MT_EMC_SPINDLE_ORIENT\020\315P\022(\n#MT_EMC_SPIN" +
      "DLE_WAIT_ORIENT_COMPLETE\020\316P\022\027\n\022MT_EMC_MO",
      "TION_STAT\020\237Q\022\025\n\020MT_EMC_TASK_INIT\020\205R\022\025\n\020M" +
      "T_EMC_TASK_HALT\020\206R\022\026\n\021MT_EMC_TASK_ABORT\020" +
      "\207R\022\031\n\024MT_EMC_TASK_SET_MODE\020\210R\022\032\n\025MT_EMC_" +
      "TASK_SET_STATE\020\211R\022\032\n\025MT_EMC_TASK_PLAN_OP" +
      "EN\020\212R\022\031\n\024MT_EMC_TASK_PLAN_RUN\020\213R\022\032\n\025MT_E" +
      "MC_TASK_PLAN_READ\020\214R\022\035\n\030MT_EMC_TASK_PLAN" +
      "_EXECUTE\020\215R\022\033\n\026MT_EMC_TASK_PLAN_PAUSE\020\216R" +
      "\022\032\n\025MT_EMC_TASK_PLAN_STEP\020\217R\022\034\n\027MT_EMC_T" +
      "ASK_PLAN_RESUME\020\220R\022\031\n\024MT_EMC_TASK_PLAN_E" +
      "ND\020\221R\022\033\n\026MT_EMC_TASK_PLAN_CLOSE\020\222R\022\032\n\025MT",
      "_EMC_TASK_PLAN_INIT\020\223R\022\033\n\026MT_EMC_TASK_PL" +
      "AN_SYNCH\020\224R\022\'\n\"MT_EMC_TASK_PLAN_SET_OPTI" +
      "ONAL_STOP\020\225R\022&\n!MT_EMC_TASK_PLAN_SET_BLO" +
      "CK_DELETE\020\226R\022#\n\036MT_EMC_TASK_PLAN_OPTIONA" +
      "L_STOP\020\227R\022\033\n\026MT_EMC_TASK_PLAN_RESET\020\230R\022\033" +
      "\n\026MT_EMC_TASK_PLAN_REPLY\020\242R\022\025\n\020MT_EMC_TA" +
      "SK_STAT\020\347R\022\025\n\020MT_EMC_TOOL_INIT\020\335V\022\025\n\020MT_" +
      "EMC_TOOL_HALT\020\336V\022\026\n\021MT_EMC_TOOL_ABORT\020\337V" +
      "\022\030\n\023MT_EMC_TOOL_PREPARE\020\340V\022\025\n\020MT_EMC_TOO" +
      "L_LOAD\020\341V\022\027\n\022MT_EMC_TOOL_UNLOAD\020\342V\022 \n\033MT",
      "_EMC_TOOL_LOAD_TOOL_TABLE\020\343V\022\033\n\026MT_EMC_T" +
      "OOL_SET_OFFSET\020\344V\022\033\n\026MT_EMC_TOOL_SET_NUM" +
      "BER\020\345V\022\025\n\020MT_EMC_TOOL_STAT\020\277W\022\030\n\023MT_EMC_" +
      "AUX_ESTOP_ON\020\306W\022\031\n\024MT_EMC_AUX_ESTOP_OFF\020" +
      "\307W\022\033\n\026MT_EMC_AUX_ESTOP_RESET\020\310W\022\032\n\025MT_EM" +
      "C_AUX_INPUT_WAIT\020\311W\022\024\n\017MT_EMC_AUX_STAT\020\243" +
      "X\022\026\n\021MT_EMC_SPINDLE_ON\020\250X\022\027\n\022MT_EMC_SPIN" +
      "DLE_OFF\020\251X\022\034\n\027MT_EMC_SPINDLE_INCREASE\020\255X" +
      "\022\034\n\027MT_EMC_SPINDLE_DECREASE\020\256X\022\034\n\027MT_EMC" +
      "_SPINDLE_CONSTANT\020\257X\022!\n\034MT_EMC_SPINDLE_B",
      "RAKE_RELEASE\020\260X\022 \n\033MT_EMC_SPINDLE_BRAKE_" +
      "ENGAGE\020\261X\022\031\n\024MT_EMC_SPINDLE_SPEED\020\264X\022\030\n\023" +
      "MT_EMC_SPINDLE_STAT\020\207Y\022\033\n\026MT_EMC_COOLANT" +
      "_MIST_ON\020\214Y\022\034\n\027MT_EMC_COOLANT_MIST_OFF\020\215" +
      "Y\022\034\n\027MT_EMC_COOLANT_FLOOD_ON\020\216Y\022\035\n\030MT_EM" +
      "C_COOLANT_FLOOD_OFF\020\217Y\022\030\n\023MT_EMC_COOLANT" +
      "_STAT\020\353Y\022\023\n\016MT_EMC_LUBE_ON\020\360Y\022\024\n\017MT_EMC_" +
      "LUBE_OFF\020\361Y\022\025\n\020MT_EMC_LUBE_STAT\020\317Z\022\023\n\016MT" +
      "_EMC_IO_INIT\020\321Z\022\023\n\016MT_EMC_IO_HALT\020\322Z\022\024\n\017" +
      "MT_EMC_IO_ABORT\020\323Z\022\035\n\030MT_EMC_IO_SET_CYCL",
      "E_TIME\020\324Z\022\023\n\016MT_EMC_IO_STAT\020\263[\022\020\n\013MT_EMC" +
      "_INIT\020\375\\\022\020\n\013MT_EMC_HALT\020\376\\\022\021\n\014MT_EMC_ABO" +
      "RT\020\377\\\022\020\n\013MT_EMC_STAT\020\337]\022\033\n\026MT_EMCSTAT_FU" +
      "LL_UPDATE\020\324a\022\"\n\035MT_EMCSTAT_INCREMENTAL_U" +
      "PDATE\020\325a\022\025\n\020MT_EMC_NML_ERROR\020\336a\022\024\n\017MT_EM" +
      "C_NML_TEXT\020\337a\022\027\n\022MT_EMC_NML_DISPLAY\020\340a\022\027" +
      "\n\022MT_EMCCMD_EXECUTED\020\350a\022\030\n\023MT_EMCCMD_COM" +
      "PLETED\020\351a\022\034\n\027MT_LAUNCHER_FULL_UPDATE\020\270b\022" +
      "#\n\036MT_LAUNCHER_INCREMENTAL_UPDATE\020\271b\022\026\n\021" +
      "MT_LAUNCHER_ERROR\020\272b\022\026\n\021MT_LAUNCHER_STAR",
      "T\020\302b\022\032\n\025MT_LAUNCHER_TERMINATE\020\303b\022\025\n\020MT_L" +
      "AUNCHER_KILL\020\304b\022\034\n\027MT_LAUNCHER_WRITE_STD" +
      "IN\020\305b\022\025\n\020MT_LAUNCHER_CALL\020\306b\022\031\n\024MT_LAUNC" +
      "HER_SHUTDOWN\020\307b*\267\001\n\013OriginIndex\022\022\n\016ORIGI" +
      "N_UNKNOWN\020\000\022\016\n\nORIGIN_G54\020\001\022\016\n\nORIGIN_G5" +
      "5\020\002\022\016\n\nORIGIN_G56\020\003\022\016\n\nORIGIN_G57\020\004\022\016\n\nO" +
      "RIGIN_G58\020\005\022\016\n\nORIGIN_G59\020\006\022\020\n\014ORIGIN_G5" +
      "9_1\020\007\022\020\n\014ORIGIN_G59_2\020\010\022\020\n\014ORIGIN_G59_3\020" +
      "\t*P\n\021TermConditionType\022\034\n\030_EMC_TRAJ_TERM" +
      "_COND_STOP\020\001\022\035\n\031_EMC_TRAJ_TERM_COND_BLEN",
      "D\020\002*W\n\016CanonDirection\022\022\n\016_CANON_STOPPED\020" +
      "\001\022\024\n\020_CANON_CLOCKWISE\020\002\022\033\n\027_CANON_COUNTE" +
      "RCLOCKWISE\020\003*2\n\tInputType\022\021\n\r_ANALOG_INP" +
      "UT\020\000\022\022\n\016_DIGITAL_INPUT\020\001*F\n\010WaitType\022\r\n\t" +
      "IMMEDIATE\020\000\022\010\n\004RISE\020\001\022\010\n\004FALL\020\002\022\013\n\007BE_HI" +
      "GH\020\003\022\n\n\006BE_LOW\020\004*\252\001\n\024InterpreterStateTyp" +
      "e\022\017\n\013INTERP_IDLE\020\001\022\022\n\016INTERP_RUNNING\020\002\022\024" +
      "\n\020INTERP_SYNC_WAIT\020\003\022\021\n\rINTERP_PAUSED\020\004\022" +
      "\025\n\021INTERP_QUEUE_WAIT\020\005\022\025\n\021INTERP_ABORT_W" +
      "AIT\020\006\022\026\n\022INTERP_STATE_UNSET\020c"
    };
    com.google.protobuf.Descriptors.FileDescriptor.InternalDescriptorAssigner assigner =
        new com.google.protobuf.Descriptors.FileDescriptor.    InternalDescriptorAssigner() {
          public com.google.protobuf.ExtensionRegistry assignDescriptors(
              com.google.protobuf.Descriptors.FileDescriptor root) {
            descriptor = root;
            return null;
          }
        };
    com.google.protobuf.Descriptors.FileDescriptor
      .internalBuildGeneratedFileFrom(descriptorData,
        new com.google.protobuf.Descriptors.FileDescriptor[] {
          fi.kapsi.koti.jpa.nanopb.Nanopb.getDescriptor(),
        }, assigner);
    fi.kapsi.koti.jpa.nanopb.Nanopb.getDescriptor();
  }

  // @@protoc_insertion_point(outer_class_scope)
}
